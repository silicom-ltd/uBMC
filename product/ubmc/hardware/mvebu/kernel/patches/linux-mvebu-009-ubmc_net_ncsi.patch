--- linux-custom-orig/drivers/net/ethernet/marvell/mvneta.c	2019-10-21 23:25:44.000000000 +0800
+++ linux-custom-silicom/drivers/net/ethernet/marvell/mvneta.c	2020-10-07 22:07:33.060795496 +0800
@@ -38,6 +38,10 @@
 #include <net/ipv6.h>
 #include <net/tso.h>
 
+//#define NO_SILC_MOD
+#ifndef NO_SILC_MOD
+#include <net/ncsi.h>
+#endif
 /* Registers */
 #define MVNETA_RXQ_CONFIG_REG(q)                (0x1400 + ((q) << 2))
 #define      MVNETA_RXQ_HW_BUF_ALLOC            BIT(0)
@@ -332,7 +336,16 @@
 
 #define MVNETA_RX_GET_BM_POOL_ID(rxd) \
 	(((rxd)->status & MVNETA_RXD_BM_POOL_MASK) >> MVNETA_RXD_BM_POOL_SHIFT)
-
+#define SIL_VERSION		        "Silicom v1.10"
+/*
+#ifdef NO_SILC_MOD
+#define CPSW_MAX_PACKET_SIZE	(VLAN_ETH_FRAME_LEN +\
+ 				 ETH_FCS_LEN +\
+ 				 CPSW_RX_VLAN_ENCAP_HDR_SIZE)
+#else
+#define CPSW_MAX_PACKET_SIZE	10240
+#endif
+*/
 enum {
 	ETHTOOL_STAT_EEE_WAKEUP,
 	ETHTOOL_STAT_SKB_ALLOC_ERR,
@@ -461,6 +474,12 @@
 	bool neta_armada3700;
 	u16 rx_offset_correction;
 	const struct mbus_dram_target_info *dram_target_info;
+#ifndef NO_SILC_MOD
+	bool	use_ncsi;	/* Enable ncsi on this interface */
+	bool slave_ncsi;
+	struct ncsi_dev *ncsi_dev;
+	bool ncsi_dev_started;
+#endif
 };
 
 /* The mvneta_tx_desc and mvneta_rx_desc structures describe the
@@ -641,7 +660,7 @@
  */
 static int rxq_number = 8;
 static int txq_number = 8;
-
+static int ncsi_mask = 0;
 static int rxq_def;
 
 static int rx_copybreak __read_mostly = 256;
@@ -658,6 +677,25 @@
 
 #define MVNETA_MUSDK_QUEUE_MASK		1
 
+
+#ifndef NO_SILC_MOD
+static void mv_ncsi_handler(struct ncsi_dev *nd)
+{
+	if (unlikely(nd->state != ncsi_dev_state_functional))
+		return;
+
+#if 0
+	if (nd->dev)
+		netif_carrier_on(nd->dev);
+	else
+		netif_carrier_off(nd->dev);
+#endif
+//	dump_stack();
+	netdev_info(nd->dev, "NCSI interface %s\n",
+		    nd->link_up ? "up" : "down");
+
+}
+#endif
 /* Utility/helper methods */
 
 /* Write helper method */
@@ -3659,7 +3697,18 @@
 {
 	struct mvneta_port *pp = netdev_priv(ndev);
 	u32 val;
-
+	//printk("ncsi mvneta_mac_link_down \n");
+#ifndef NO_SILC_MOD
+		if(pp->ncsi_dev)
+		{
+			if(pp->ncsi_dev_started)
+			{
+				netdev_notice(pp->dev, "Stopping NCSI");
+				ncsi_stop_dev(pp->ncsi_dev);
+				pp->ncsi_dev_started = false;
+			}
+		}
+#endif
 	mvneta_port_down(pp);
 
 	if (!phylink_autoneg_inband(mode)) {
@@ -3679,7 +3728,6 @@
 {
 	struct mvneta_port *pp = netdev_priv(ndev);
 	u32 val;
-
 	if (!phylink_autoneg_inband(mode)) {
 		val = mvreg_read(pp, MVNETA_GMAC_AUTONEG_CONFIG);
 		val &= ~MVNETA_GMAC_FORCE_LINK_DOWN;
@@ -3693,6 +3741,33 @@
 		pp->eee_active = phy_init_eee(phy, 0) >= 0;
 		mvneta_set_eee(pp, pp->eee_active && pp->tx_lpi_enabled);
 	}
+#ifndef NO_SILC_MOD
+		if(pp->ncsi_dev)
+		{
+			if (!pp->ncsi_dev_started)
+			{
+				int rc;
+				//netdev_notice(ndev, "Starting NCSI");
+			/* Start the NCSI device */
+				rc = ncsi_start_dev(pp->ncsi_dev);
+				netdev_info(ndev,"ncsi :ncsi_start_dev \n");
+				if(rc == 0 )
+				{
+					pp->ncsi_dev_started = true;
+				}
+				else
+				{
+					netdev_info(ndev, "Failed Starting NCSI, %d", rc);
+				}
+			}
+		}
+		else
+		{
+					netdev_info(ndev, "No link stop tx");
+
+		}
+#endif
+
 }
 
 static const struct phylink_mac_ops mvneta_phylink_ops = {
@@ -3995,7 +4070,18 @@
 		netdev_warn(dev, "ndo_stop not supported on MUSDK port\n");
 		return 0;
 	}
-
+	//printk("ncsi mvneta_stop \n");
+#ifndef NO_SILC_MOD
+		if(pp->ncsi_dev)
+		{
+			if(pp->ncsi_dev_started)
+			{
+				netdev_notice(dev, "Stopping NCSI");
+				ncsi_stop_dev(pp->ncsi_dev);
+				pp->ncsi_dev_started = false;
+			}
+		}
+#endif
 	if (!pp->neta_armada3700) {
 		/* Inform that we are stopping so we don't want to setup the
 		 * driver for new CPUs in the notifiers. The code of the
@@ -4123,6 +4209,11 @@
 		sizeof(drvinfo->version));
 	strlcpy(drvinfo->bus_info, dev_name(&dev->dev),
 		sizeof(drvinfo->bus_info));
+/*
+#ifndef NO_SILC_MOD
+		data->slave_ncsi = 1;
+#endif
+*/
 }
 
 
@@ -4582,6 +4673,37 @@
 	return 0;
 }
 
+#ifdef CONFIG_BCM5421_SUPPORT
+static int thread_fn(void *cpsw)
+{
+	while (1)
+	{
+		config_rgmi_sgmii();
+		ssleep(1);
+	}
+
+	do_exit(0);
+	return 0;
+}
+#endif
+
+
+
+#ifndef NO_SILC_MOD
+static void mv_slave_ncsi_deinit(struct mvneta_port *pp)
+{
+	printk("Do mv_slave_ncsi_deinit \n");
+	if(pp->ncsi_dev && pp->ncsi_dev_started)
+		ncsi_stop_dev(pp->ncsi_dev);
+	printk("Do mv_slave_ncsi_deinit 1 \n");
+	pp->ncsi_dev_started = false;
+	printk("Do mv_slave_ncsi_deinit 2 n");
+	if(pp->ncsi_dev)
+		ncsi_unregister_dev(pp->ncsi_dev);
+	printk("Done mv_slave_ncsi_deinit \n");
+}
+#endif
+
 /* Device initialization routine */
 static int mvneta_probe(struct platform_device *pdev)
 {
@@ -4601,7 +4723,7 @@
 	int cpu;
 	const char *musdk_status;
 	int statlen;
-
+	char ncsi_if;
 	dev = alloc_etherdev_mqs(sizeof(struct mvneta_port), txq_number, rxq_number);
 	if (!dev)
 		return -ENOMEM;
@@ -4641,6 +4763,7 @@
 
 	dev->ethtool_ops = &mvneta_eth_tool_ops;
 
+
 	pp = netdev_priv(dev);
 	spin_lock_init(&pp->lock);
 	pp->phylink = phylink;
@@ -4827,6 +4950,38 @@
 	/* Port may be configured by Uboot to transmit IDLE, so a remote side
 	 * feels the link as UP. Stop TX in same way as in mvneta_start/stop.
 	 */
+#ifndef NO_SILC_MOD
+
+		if(strcmp(dev->name,"eth0") == 0)
+		{
+			ncsi_if = 0;
+		}
+		else if(strcmp(dev->name,"eth1") == 0)
+		{
+			ncsi_if = 1;
+		}
+		if( (ncsi_mask & BIT(ncsi_if)) != 0)
+		{
+			pp->slave_ncsi = 1;
+			printk("enable the NCSI on %s \n",dev->name);
+		}
+		else
+		{
+			pp->slave_ncsi = 0;
+		}
+		if(pp->slave_ncsi == 1)
+		{
+			printk("Do ncsi_register_dev  \n");
+			pp->ncsi_dev = ncsi_register_dev(dev, mv_ncsi_handler);
+			if (!pp->ncsi_dev)
+			{
+			//	dev_err(dev, "cpsw: failed to register with NCSI\n");
+				printk("ncsi_register_dev fail \n");
+				return -ENODEV;
+			}
+			printk("ncsi_register_dev done \n");
+		}
+#endif
 	if (pp->phylink) {
 		if (rtnl_is_locked()) {
 			if (!mvneta_mdio_probe(pp))
@@ -4837,6 +4992,7 @@
 				mvneta_mdio_remove(pp);
 			rtnl_unlock();
 		}
+
 	}
 
 	if (pp->musdk_port)
@@ -4874,7 +5030,12 @@
 {
 	struct net_device  *dev = platform_get_drvdata(pdev);
 	struct mvneta_port *pp = netdev_priv(dev);
-
+#ifndef NO_SILC_MOD
+	if(pp->slave_ncsi == 1)
+	{
+		mv_slave_ncsi_deinit(pp);
+	}
+#endif
 	unregister_netdev(dev);
 	clk_disable_unprepare(pp->clk_bus);
 	clk_disable_unprepare(pp->clk);
@@ -5039,6 +5200,7 @@
 		goto err_dead;
 
 	ret = platform_driver_register(&mvneta_driver);
+	printk("mvneta_driver_init netdev:ncsi_mask is %x \n",ncsi_mask);
 	if (ret)
 		goto err;
 	return 0;
@@ -5069,3 +5231,4 @@
 
 module_param(rxq_def, int, 0444);
 module_param(rx_copybreak, int, 0644);
+module_param(ncsi_mask, int, 0444);
--- linux-custom-orig/drivers/net/ethernet/marvell/Kconfig	2019-10-21 23:25:44.000000000 +0800
+++ linux-custom-silicom/drivers/net/ethernet/marvell/Kconfig	2020-10-07 22:07:33.060795496 +0800
@@ -57,7 +57,7 @@
 
 config MVNETA
 	tristate "Marvell Armada 370/38x/XP/37xx network interface support"
-	depends on ARCH_MVEBU || COMPILE_TEST
+	depends on ARCH_MVEBU || COMPILE_TEST || NET_NCSI
 	select MVMDIO
 	select PHYLINK
 	---help---
--- linux-custom-orig/net/ncsi/ncsi-cmd.c	2019-10-21 23:25:46.000000000 +0800
+++ linux-custom-silicom/net/ncsi/ncsi-cmd.c	2020-10-07 22:16:15.728556219 +0800
@@ -17,7 +17,7 @@
 #include <net/ncsi.h>
 #include <net/net_namespace.h>
 #include <net/sock.h>
-
+//#define NCSI_CMD_DUMP
 #include "internal.h"
 #include "ncsi-pkt.h"
 
@@ -47,8 +47,7 @@
 	h->reserved     = 0;
 	h->id           = nca->id;
 	h->type         = nca->type;
-	h->channel      = NCSI_TO_CHANNEL(nca->package,
-					  nca->channel);
+	h->channel      = NCSI_TO_CHANNEL(nca->package,nca->channel);
 	h->length       = htons(nca->payload);
 	h->reserved1[0] = 0;
 	h->reserved1[1] = 0;
@@ -56,8 +55,21 @@
 	/* Fill with calculated checksum */
 	checksum = ncsi_calculate_checksum((unsigned char *)h,
 					   sizeof(*h) + nca->payload);
+	/*
 	pchecksum = (__be32 *)((void *)h + sizeof(struct ncsi_pkt_hdr) +
 		    nca->payload);
+		    */
+	#ifdef NO_SILC_MOD
+		pchecksum = (__be32 *)((void *)(h + 1) + sizeof(struct ncsi_pkt_hdr) +
+				nca->payload);
+	#else
+		/*
+		 * Blair Wang :
+		 *  The value of payload does not include the padding in NCSI packet.
+		 *  For Intel i210 oem command 0x20, it's payload length must is 7.
+		 **/
+		pchecksum = (__be32 *)((void *)(h + 1) + NCSI_PAYLOAD_ELEN(nca->payload));
+	#endif
 	*pchecksum = htonl(checksum);
 }
 
@@ -198,7 +210,23 @@
 
 	return 0;
 }
+#ifndef NO_SILC_MOD
+static int ncsi_cmd_handler_oem_i210(struct sk_buff *skb,
+				 struct ncsi_cmd_arg *nca)
+{
+	struct ncsi_oem_i210_cmd_mgmt_pkt *cmd;
+
+	cmd = (struct ncsi_oem_i210_cmd_mgmt_pkt *)skb_put_zero(skb, sizeof(*cmd));
+	//see i210 data sheet 10.6.3
+	cmd->oem_id = htonl(0x157);
+	cmd->intel_cmd = 0x20U;
+	cmd->value1 = 0x0;
+	cmd->mgmt_ctl = 1;
+	ncsi_cmd_build_header(&cmd->cmd.common, nca);
 
+	return 0;
+}
+#endif
 static int ncsi_cmd_handler_snfc(struct sk_buff *skb,
 				 struct ncsi_cmd_arg *nca)
 {
@@ -244,7 +272,11 @@
 	{ NCSI_PKT_CMD_GNS,    0, ncsi_cmd_handler_default },
 	{ NCSI_PKT_CMD_GNPTS,  0, ncsi_cmd_handler_default },
 	{ NCSI_PKT_CMD_GPS,    0, ncsi_cmd_handler_default },
+#ifndef NO_SILC_MOD
+	{ NCSI_PKT_CMD_OEM,    7, ncsi_cmd_handler_oem_i210},
+#else
 	{ NCSI_PKT_CMD_OEM,    0, NULL                     },
+#endif
 	{ NCSI_PKT_CMD_PLDM,   0, NULL                     },
 	{ NCSI_PKT_CMD_GPUUID, 0, ncsi_cmd_handler_default }
 };
@@ -263,9 +295,10 @@
 	nr = ncsi_alloc_request(ndp, nca->req_flags);
 	if (!nr)
 		return NULL;
-
+#ifdef NO_SILC_MOD
 	/* NCSI command packet has 16-bytes header, payload, 4 bytes checksum.
 	 * The packet needs padding if its payload is less than 26 bytes to
+	 * The packet needs padding if its payload is less than 28 bytes to
 	 * meet 64 bytes minimal ethernet frame length.
 	 */
 	len += sizeof(struct ncsi_cmd_pkt_hdr) + 4;
@@ -273,7 +306,17 @@
 		len += 26;
 	else
 		len += nca->payload;
-
+#else
+		/*
+		 * Blair Wang -
+		 *  We should meet the requirement for VLAN_ETH_ZLEN
+		 */
+		len += sizeof(struct ncsi_cmd_pkt_hdr) + 4;
+		if (NCSI_PAYLOAD_ELEN(nca->payload) < 30)
+			len += 30;
+		else
+			len += NCSI_PAYLOAD_ELEN(nca->payload);
+#endif
 	/* Allocate skb */
 	skb = alloc_skb(len, GFP_ATOMIC);
 	if (!skb) {
@@ -290,14 +333,670 @@
 
 	return nr;
 }
+#ifndef NO_SILC_MOD
+static struct ncsi_cmd_name {
+	unsigned char type;
+	char* name;
+	char* desc;
+} ncsi_cmd_names[] = {
+		{ NCSI_PKT_CMD_CIS   , "CIS   ", "ClrInitState"},
+		{ NCSI_PKT_CMD_SP    , "SP    ", "SelPkg      "},
+		{ NCSI_PKT_CMD_DP    , "DP    ", "DeSelPkg    "},
+		{ NCSI_PKT_CMD_EC    , "EC    ", "EnaChannel  "},
+		{ NCSI_PKT_CMD_DC    , "DC    ", "DisChannel  "},
+		{ NCSI_PKT_CMD_RC    , "RC    ", "ResetChannel"},
+		{ NCSI_PKT_CMD_ECNT  , "ECNT  ", "EnaChanNetTX"},
+		{ NCSI_PKT_CMD_DCNT  , "DCNT  ", "DisChanNetTX"},
+		{ NCSI_PKT_CMD_AE    , "AE    ", "AenEna      "},
+		{ NCSI_PKT_CMD_SL    , "SL    ", "SetLink     "},
+		{ NCSI_PKT_CMD_GLS   , "GLS   ", "GetLinkSta  "},
+		{ NCSI_PKT_CMD_SVF   , "SVF   ", "SetVLANFltr "},
+		{ NCSI_PKT_CMD_EV    , "EV    ", "EnaVLan     "},
+		{ NCSI_PKT_CMD_DV    , "DV    ", "DisVLan     "},
+		{ NCSI_PKT_CMD_SMA   , "SMA   ", "SetMacAddr  "},
+		{ NCSI_PKT_CMD_EBF   , "EBF   ", "EnaBcastFltr"},
+		{ NCSI_PKT_CMD_DBF   , "DBF   ", "DisBcastFltr"},
+		{ NCSI_PKT_CMD_EGMF  , "EGMF  ", "EnaGloMcastF"},
+		{ NCSI_PKT_CMD_DGMF  , "DGMF  ", "DisGloMcastF"},
+		{ NCSI_PKT_CMD_SNFC  , "SNFC  ", "SetFlowCtrl "},
+		{ NCSI_PKT_CMD_GVI   , "GVI   ", "GetVersion  "},
+		{ NCSI_PKT_CMD_GC    , "GC    ", "GetCapa     "},
+		{ NCSI_PKT_CMD_GP    , "GP    ", "GetParam    "},
+		{ NCSI_PKT_CMD_GCPS  , "GCPS  ", "GetCntlPktSt"},
+		{ NCSI_PKT_CMD_GNS   , "GNS   ", "GetNCSIPktSt"},
+		{ NCSI_PKT_CMD_GNPTS , "GNPTS ", "GetPassThrSt"},
+		{ NCSI_PKT_CMD_GPS   , "GPS   ", "GetPkgStatus"},
+		{ NCSI_PKT_CMD_OEM   , "OEM   ", "OEMCommand  "},
+		{ NCSI_PKT_CMD_PLDM  , "PLDM  ", "PLDM        "},
+		{ NCSI_PKT_CMD_GPUUID, "GPUUID", "GPUUID      "},
+		{ 0xFFU              , "AED   ", "AEN         "},
+};
+static char ncsi_cmd_type_name_hex[32];
+
+char* ncsi_cmd_type_name_get(unsigned char type)
+{
+	uint32_t i;
+	for (i = 0; i < ARRAY_SIZE(ncsi_cmd_names); i++) {
+		if (ncsi_cmd_names[i].type == type) {
+			return ncsi_cmd_names[i].desc;
+		}
+	}
+	sprintf(ncsi_cmd_type_name_hex,  "UNK:0x%02x   ", type);
+	return ncsi_cmd_type_name_hex;
+}
+
+
+char ncsi_xmit_cmd_dump_buf[2048];
+#define NCSI_DUMP_PRN(fmt, ...)	\
+	do{ buf_off += sprintf(buf + buf_off, fmt, ## __VA_ARGS__ ); } while(0)
+#define NCSI_DUMP_FIELD_STR(parent_type, field)	\
+	do{ struct parent_type* __p_parent_struct = p_ncsi_head; \
+		buf_off += sprintf(buf + buf_off, "%s[%s]", #field, __p_parent_struct->field ); } while(0)
 
+#define NCSI_DUMP_FIELD_U8(parent_type, field)	\
+	do{ struct parent_type* __p_parent_struct = p_ncsi_head; \
+		buf_off += sprintf(buf + buf_off, "%s[%02x]", #field, __p_parent_struct->field ); } while(0)
+
+#define NCSI_DUMP_FIELD_U32(parent_type, field)	\
+	do{ struct parent_type* __p_parent_struct = p_ncsi_head; \
+		buf_off += sprintf(buf + buf_off, "%s[%08x]", #field, ntohl(__p_parent_struct->field) ); } while(0)
+
+#define NCSI_DUMP_FIELD_U16(parent_type, field)	\
+	do{ struct parent_type* __p_parent_struct = p_ncsi_head; \
+		buf_off += sprintf(buf + buf_off, "%s[%04x]", #field, ntohs(__p_parent_struct->field) ); } while(0)
+
+#define NCSI_DUMP_FIELD_MAC(parent_type, field)	\
+	do{ struct parent_type* __p_parent_struct = p_ncsi_head; \
+		buf_off += sprintf(buf + buf_off, "%s[%02x:%02x:%02x:%02x:%02x:%02x]",\
+				#field, __p_parent_struct->field[0], __p_parent_struct->field[1], \
+				__p_parent_struct->field[2], __p_parent_struct->field[3], \
+				__p_parent_struct->field[4], __p_parent_struct->field[5]); } while(0)
+
+
+#ifdef NCSI_CMD_DUMP
+
+
+void ncsi_cmd_dump(struct net_device* n,void* pkt)
+{
+	void* p_ncsi_head =  pkt;
+	struct ncsi_pkt_hdr* h  = p_ncsi_head;
+	struct ncsi_rsp_pkt_hdr* rsp = p_ncsi_head;
+	struct ncsi_aen_pkt_hdr* aen_hdr = p_ncsi_head;
+	uint8_t cmd_type = h->type & 0x7fU;
+	uint8_t is_resp = h->type &0x80U;
+	uint8_t is_aen = h->type == 0xFFU;
+	char* buf = ncsi_xmit_cmd_dump_buf;
+	uint32_t buf_off = 0;
+	NCSI_DUMP_PRN("id[%02x] typ[%s] chn[%02x] len[%3u]",
+			h->id,
+			ncsi_cmd_type_name_get(cmd_type),
+			h->channel,
+			htons(h->length) & 0xFFF);
+	if(is_resp)
+		NCSI_DUMP_PRN("Rsp[%04x] Reason[%04x]", ntohs(rsp->code), ntohs(rsp->reason));
+	if(is_aen)
+	{
+		char* aen_name;
+		struct ncsi_aen_lsc_pkt *lsc;
+		switch(aen_hdr->type)
+		{
+		case NCSI_PKT_AEN_LSC:
+			lsc = p_ncsi_head;
+			aen_name = "LinkChg   ";
+			NCSI_DUMP_PRN("AType[%s] Link[%x] OemLink[%x]", aen_name, ntohl(lsc->status), ntohl(lsc->oem_status));
+			break;
+		case NCSI_PKT_AEN_CR:
+			aen_name = "CfgChg    ";
+			NCSI_DUMP_PRN("AType[%s]", aen_name);
+			break;
+		case NCSI_PKT_AEN_HNCDSC:
+			aen_name = "HostDrvChg";
+			NCSI_DUMP_PRN("AType[%s]", aen_name);
+			break;
+		}
+		return;
+	}
+
+	switch(h->type)
+	{
+		case NCSI_PKT_CMD_CIS:
+			break;
+		case NCSI_PKT_CMD_SP:
+			NCSI_DUMP_FIELD_U8(ncsi_cmd_sp_pkt, hw_arbitration);
+			break;
+		case NCSI_PKT_CMD_DP	 :
+			break;
+		case NCSI_PKT_CMD_EC	 :
+			break;
+		case NCSI_PKT_CMD_DC	 :
+			NCSI_DUMP_FIELD_U8(ncsi_cmd_dc_pkt, ald);
+			break;
+		case NCSI_PKT_CMD_RC	 :
+			break;
+		case NCSI_PKT_CMD_ECNT	 :
+			break;
+		case NCSI_PKT_CMD_DCNT	 :
+			break;
+		case NCSI_PKT_CMD_AE	 :
+			NCSI_DUMP_FIELD_U8(ncsi_cmd_ae_pkt, mc_id);
+			NCSI_DUMP_FIELD_U32(ncsi_cmd_ae_pkt, mode);
+			break;
+		case NCSI_PKT_CMD_SL	 :
+			NCSI_DUMP_FIELD_U32(ncsi_cmd_sl_pkt, mode);
+			NCSI_DUMP_FIELD_U32(ncsi_cmd_sl_pkt, oem_mode);
+			break;
+		case NCSI_PKT_CMD_GLS	 :
+			return;//don't dump gls
+			break;
+		case NCSI_PKT_CMD_SVF	 :
+			NCSI_DUMP_FIELD_U16(ncsi_cmd_svf_pkt, vlan);
+			NCSI_DUMP_FIELD_U8(ncsi_cmd_svf_pkt, index);
+			NCSI_DUMP_FIELD_U8(ncsi_cmd_svf_pkt, enable);
+			break;
+		case NCSI_PKT_CMD_EV	 :
+			NCSI_DUMP_FIELD_U8(ncsi_cmd_ev_pkt, mode);
+			break;
+		case NCSI_PKT_CMD_DV	 :
+			break;
+		case NCSI_PKT_CMD_SMA	 :
+			NCSI_DUMP_FIELD_MAC(ncsi_cmd_sma_pkt, mac);
+			NCSI_DUMP_FIELD_U8(ncsi_cmd_sma_pkt, index);
+			NCSI_DUMP_FIELD_U8(ncsi_cmd_sma_pkt, at_e);
+			break;
+		case NCSI_PKT_CMD_EBF	 :
+			NCSI_DUMP_FIELD_U32(ncsi_cmd_ebf_pkt, mode);
+			break;
+		case NCSI_PKT_CMD_DBF	 :
+			break;
+		case NCSI_PKT_CMD_EGMF	 :
+			NCSI_DUMP_FIELD_U32(ncsi_cmd_ebf_pkt, mode);
+			break;
+		case NCSI_PKT_CMD_DGMF	 :
+			break;
+		case NCSI_PKT_CMD_SNFC	 :
+			NCSI_DUMP_FIELD_U8(ncsi_cmd_snfc_pkt, mode);
+			break;
+		case NCSI_PKT_CMD_GVI	 :
+			break;
+		case NCSI_PKT_CMD_GC	 :
+			break;
+		case NCSI_PKT_CMD_GP	 :
+			break;
+		case NCSI_PKT_CMD_GCPS	 :
+			break;
+		case NCSI_PKT_CMD_GNS	 :
+			break;
+		case NCSI_PKT_CMD_GNPTS	 :
+			break;
+		case NCSI_PKT_CMD_GPS	 :
+			break;
+		case NCSI_PKT_CMD_OEM	 :
+			NCSI_DUMP_FIELD_U32(ncsi_oem_i210_cmd_mgmt_pkt, oem_id );
+			NCSI_DUMP_FIELD_U8(ncsi_oem_i210_cmd_mgmt_pkt, intel_cmd );
+			NCSI_DUMP_FIELD_U8(ncsi_oem_i210_cmd_mgmt_pkt, value1);
+			NCSI_DUMP_FIELD_U8(ncsi_oem_i210_cmd_mgmt_pkt, mgmt_ctl);
+			break;
+		case NCSI_PKT_CMD_PLDM	 :
+			break;
+		case NCSI_PKT_CMD_GPUUID :
+			break;
+
+		case NCSI_PKT_RSP_CIS	 :
+			break;
+		case NCSI_PKT_RSP_SP	 :
+			break;
+		case NCSI_PKT_RSP_DP	 :
+		case NCSI_PKT_RSP_EC	 :
+		case NCSI_PKT_RSP_DC	 :
+		case NCSI_PKT_RSP_RC	 :
+		case NCSI_PKT_RSP_ECNT	 :
+		case NCSI_PKT_RSP_DCNT	 :
+		case NCSI_PKT_RSP_AE	 :
+		case NCSI_PKT_RSP_SL	 :
+			break;
+		case NCSI_PKT_RSP_GLS	 :
+			return; //don't dump gls
+			NCSI_DUMP_FIELD_U32(ncsi_rsp_gls_pkt, status);
+			NCSI_DUMP_FIELD_U32(ncsi_rsp_gls_pkt, other);
+			NCSI_DUMP_FIELD_U32(ncsi_rsp_gls_pkt, oem_status);
+			break;
+		case NCSI_PKT_RSP_SVF	 :
+		case NCSI_PKT_RSP_EV	 :
+		case NCSI_PKT_RSP_DV	 :
+		case NCSI_PKT_RSP_SMA	 :
+		case NCSI_PKT_RSP_EBF	 :
+		case NCSI_PKT_RSP_DBF	 :
+		case NCSI_PKT_RSP_EGMF	 :
+		case NCSI_PKT_RSP_DGMF	 :
+		case NCSI_PKT_RSP_SNFC	 :
+			break;
+		case NCSI_PKT_RSP_GVI	 :
+			NCSI_DUMP_FIELD_U32(ncsi_rsp_gvi_pkt, ncsi_version);
+			NCSI_DUMP_FIELD_U8(ncsi_rsp_gvi_pkt, alpha2);
+			NCSI_DUMP_FIELD_STR(ncsi_rsp_gvi_pkt, fw_name);
+			NCSI_DUMP_FIELD_U32(ncsi_rsp_gvi_pkt, fw_version);
+			NCSI_DUMP_FIELD_U16(ncsi_rsp_gvi_pkt, pci_ids[0]);
+			NCSI_DUMP_FIELD_U16(ncsi_rsp_gvi_pkt, pci_ids[1]);
+			NCSI_DUMP_FIELD_U16(ncsi_rsp_gvi_pkt, pci_ids[2]);
+			NCSI_DUMP_FIELD_U16(ncsi_rsp_gvi_pkt, pci_ids[3]);
+			NCSI_DUMP_FIELD_U32(ncsi_rsp_gvi_pkt, mf_id);
+			break;
+		case NCSI_PKT_RSP_GC	 :
+			NCSI_DUMP_FIELD_U32(ncsi_rsp_gc_pkt, cap);
+			NCSI_DUMP_FIELD_U32(ncsi_rsp_gc_pkt, bc_cap);
+			NCSI_DUMP_FIELD_U32(ncsi_rsp_gc_pkt, mc_cap);
+			NCSI_DUMP_FIELD_U32(ncsi_rsp_gc_pkt, buf_cap);
+			NCSI_DUMP_FIELD_U32(ncsi_rsp_gc_pkt, aen_cap);
+			NCSI_DUMP_FIELD_U8(ncsi_rsp_gc_pkt, vlan_cnt);
+			NCSI_DUMP_FIELD_U8(ncsi_rsp_gc_pkt, mixed_cnt);
+			NCSI_DUMP_FIELD_U8(ncsi_rsp_gc_pkt, mc_cnt);
+			NCSI_DUMP_FIELD_U8(ncsi_rsp_gc_pkt, uc_cnt);
+			NCSI_DUMP_FIELD_U8(ncsi_rsp_gc_pkt, vlan_mode);
+			break;
+		case NCSI_PKT_RSP_GP	 :
+			NCSI_DUMP_FIELD_U8(ncsi_rsp_gp_pkt, mac_cnt);
+			NCSI_DUMP_FIELD_U8(ncsi_rsp_gp_pkt, mac_enable);
+			NCSI_DUMP_FIELD_U8(ncsi_rsp_gp_pkt, vlan_cnt);
+			NCSI_DUMP_FIELD_U16(ncsi_rsp_gp_pkt, vlan_enable);
+			NCSI_DUMP_FIELD_U32(ncsi_rsp_gp_pkt, link_mode);
+			NCSI_DUMP_FIELD_U32(ncsi_rsp_gp_pkt, bc_mode);
+			NCSI_DUMP_FIELD_U32(ncsi_rsp_gp_pkt, valid_modes);
+			NCSI_DUMP_FIELD_U8(ncsi_rsp_gp_pkt, vlan_mode);
+			NCSI_DUMP_FIELD_U8(ncsi_rsp_gp_pkt, fc_mode);
+			NCSI_DUMP_FIELD_U32(ncsi_rsp_gp_pkt, aen_mode);
+			NCSI_DUMP_FIELD_MAC(ncsi_rsp_gp_pkt, mac);
+			NCSI_DUMP_FIELD_U16(ncsi_rsp_gp_pkt, vlan);
+			break;
+		case NCSI_PKT_RSP_GCPS	 :
+			NCSI_DUMP_FIELD_U32(ncsi_rsp_gcps_pkt, cnt_hi         );
+			NCSI_DUMP_FIELD_U32(ncsi_rsp_gcps_pkt, cnt_lo         );
+			NCSI_DUMP_FIELD_U32(ncsi_rsp_gcps_pkt, rx_bytes       );
+			NCSI_DUMP_FIELD_U32(ncsi_rsp_gcps_pkt, tx_bytes       );
+			NCSI_DUMP_FIELD_U32(ncsi_rsp_gcps_pkt, rx_uc_pkts     );
+			NCSI_DUMP_FIELD_U32(ncsi_rsp_gcps_pkt, rx_mc_pkts     );
+			NCSI_DUMP_FIELD_U32(ncsi_rsp_gcps_pkt, rx_bc_pkts     );
+			NCSI_DUMP_FIELD_U32(ncsi_rsp_gcps_pkt, tx_uc_pkts     );
+			NCSI_DUMP_FIELD_U32(ncsi_rsp_gcps_pkt, tx_mc_pkts     );
+			NCSI_DUMP_FIELD_U32(ncsi_rsp_gcps_pkt, tx_bc_pkts     );
+			NCSI_DUMP_FIELD_U32(ncsi_rsp_gcps_pkt, fcs_err        );
+			NCSI_DUMP_FIELD_U32(ncsi_rsp_gcps_pkt, align_err      );
+			NCSI_DUMP_FIELD_U32(ncsi_rsp_gcps_pkt, false_carrier  );
+			NCSI_DUMP_FIELD_U32(ncsi_rsp_gcps_pkt, runt_pkts      );
+			NCSI_DUMP_FIELD_U32(ncsi_rsp_gcps_pkt, jabber_pkts    );
+			NCSI_DUMP_FIELD_U32(ncsi_rsp_gcps_pkt, rx_pause_xon   );
+			NCSI_DUMP_FIELD_U32(ncsi_rsp_gcps_pkt, rx_pause_xoff  );
+			NCSI_DUMP_FIELD_U32(ncsi_rsp_gcps_pkt, tx_pause_xon   );
+			NCSI_DUMP_FIELD_U32(ncsi_rsp_gcps_pkt, tx_pause_xoff  );
+			NCSI_DUMP_FIELD_U32(ncsi_rsp_gcps_pkt, tx_s_collision );
+			NCSI_DUMP_FIELD_U32(ncsi_rsp_gcps_pkt, tx_m_collision );
+			NCSI_DUMP_FIELD_U32(ncsi_rsp_gcps_pkt, l_collision    );
+			NCSI_DUMP_FIELD_U32(ncsi_rsp_gcps_pkt, e_collision    );
+			NCSI_DUMP_FIELD_U32(ncsi_rsp_gcps_pkt, rx_ctl_frames  );
+			NCSI_DUMP_FIELD_U32(ncsi_rsp_gcps_pkt, rx_64_frames   );
+			NCSI_DUMP_FIELD_U32(ncsi_rsp_gcps_pkt, rx_127_frames  );
+			NCSI_DUMP_FIELD_U32(ncsi_rsp_gcps_pkt, rx_255_frames  );
+			NCSI_DUMP_FIELD_U32(ncsi_rsp_gcps_pkt, rx_511_frames  );
+			NCSI_DUMP_FIELD_U32(ncsi_rsp_gcps_pkt, rx_1023_frames );
+			NCSI_DUMP_FIELD_U32(ncsi_rsp_gcps_pkt, rx_1522_frames );
+			NCSI_DUMP_FIELD_U32(ncsi_rsp_gcps_pkt, rx_9022_frames );
+			NCSI_DUMP_FIELD_U32(ncsi_rsp_gcps_pkt, tx_64_frames   );
+			NCSI_DUMP_FIELD_U32(ncsi_rsp_gcps_pkt, tx_127_frames  );
+			NCSI_DUMP_FIELD_U32(ncsi_rsp_gcps_pkt, tx_255_frames  );
+			NCSI_DUMP_FIELD_U32(ncsi_rsp_gcps_pkt, tx_511_frames  );
+			NCSI_DUMP_FIELD_U32(ncsi_rsp_gcps_pkt, tx_1023_frames );
+			NCSI_DUMP_FIELD_U32(ncsi_rsp_gcps_pkt, tx_1522_frames );
+			NCSI_DUMP_FIELD_U32(ncsi_rsp_gcps_pkt, tx_9022_frames );
+			NCSI_DUMP_FIELD_U32(ncsi_rsp_gcps_pkt, rx_valid_bytes );
+			NCSI_DUMP_FIELD_U32(ncsi_rsp_gcps_pkt, rx_runt_pkts   );
+			NCSI_DUMP_FIELD_U32(ncsi_rsp_gcps_pkt, rx_jabber_pkts );
+			break;
+		case NCSI_PKT_RSP_GNS	 :
+			NCSI_DUMP_FIELD_U32(ncsi_rsp_gns_pkt, rx_cmds );
+			NCSI_DUMP_FIELD_U32(ncsi_rsp_gns_pkt, dropped_cmds );
+			NCSI_DUMP_FIELD_U32(ncsi_rsp_gns_pkt, cmd_type_errs );
+			NCSI_DUMP_FIELD_U32(ncsi_rsp_gns_pkt, cmd_csum_errs );
+			NCSI_DUMP_FIELD_U32(ncsi_rsp_gns_pkt, rx_pkts );
+			NCSI_DUMP_FIELD_U32(ncsi_rsp_gns_pkt, tx_pkts );
+			NCSI_DUMP_FIELD_U32(ncsi_rsp_gns_pkt, tx_aen_pkts );
+			break;
+		case NCSI_PKT_RSP_GNPTS	 :
+			NCSI_DUMP_FIELD_U32(ncsi_rsp_gnpts_pkt, tx_pkts );
+			NCSI_DUMP_FIELD_U32(ncsi_rsp_gnpts_pkt, tx_dropped );
+			NCSI_DUMP_FIELD_U32(ncsi_rsp_gnpts_pkt, tx_channel_err );
+			NCSI_DUMP_FIELD_U32(ncsi_rsp_gnpts_pkt, tx_us_err );
+			NCSI_DUMP_FIELD_U32(ncsi_rsp_gnpts_pkt, rx_pkts );
+			NCSI_DUMP_FIELD_U32(ncsi_rsp_gnpts_pkt, rx_dropped );
+			NCSI_DUMP_FIELD_U32(ncsi_rsp_gnpts_pkt, rx_channel_err );
+			NCSI_DUMP_FIELD_U32(ncsi_rsp_gnpts_pkt, rx_us_err );
+			NCSI_DUMP_FIELD_U32(ncsi_rsp_gnpts_pkt, rx_os_err );
+			break;
+		case NCSI_PKT_RSP_GPS	 :
+			NCSI_DUMP_FIELD_U32(ncsi_rsp_gps_pkt, status );
+			break;
+		case NCSI_PKT_RSP_OEM	 :
+			NCSI_DUMP_FIELD_U32(ncsi_rsp_oem_i210_cmd_mgmt_pkt, oem_id );
+			NCSI_DUMP_FIELD_U8(ncsi_rsp_oem_i210_cmd_mgmt_pkt, intel_cmd );
+			NCSI_DUMP_FIELD_U8(ncsi_rsp_oem_i210_cmd_mgmt_pkt, value1);
+			break;
+		case NCSI_PKT_RSP_PLDM	 :
+		case NCSI_PKT_RSP_GPUUID :
+			break;
+		case NCSI_PKT_AEN:
+			switch(aen_hdr->type) {
+			case NCSI_PKT_AEN_LSC	: /*Link status change       */
+				NCSI_DUMP_PRN("[AEN_LSC]");
+				NCSI_DUMP_FIELD_U32(ncsi_aen_lsc_pkt, status );
+				NCSI_DUMP_FIELD_U32(ncsi_aen_lsc_pkt, oem_status );
+				break;
+			case NCSI_PKT_AEN_CR	: /* Configuration required   */
+				NCSI_DUMP_PRN("[AEN_CR]");
+				break;
+			case NCSI_PKT_AEN_HNCDSC: /* HNC driver status change */
+				NCSI_DUMP_PRN("[AEN_HNCDSC]");
+				NCSI_DUMP_FIELD_U32(ncsi_aen_hncdsc_pkt, status);
+				break;
+			}
+			break;
+	}
+	netdev_warn(n, "%s\n", ncsi_xmit_cmd_dump_buf);
+
+}
+
+EXPORT_SYMBOL_GPL(ncsi_cmd_dump);
+#endif	//NCSI_CMD_DUMP
+#endif	//NO_SILC_MOD
+
+void ncsi_dump(struct net_device* n,void* pkt)
+{
+	void* p_ncsi_head =  pkt;
+	struct ncsi_pkt_hdr* h  = p_ncsi_head;
+	struct ncsi_rsp_pkt_hdr* rsp = p_ncsi_head;
+	struct ncsi_aen_pkt_hdr* aen_hdr = p_ncsi_head;
+	uint8_t cmd_type = h->type & 0x7fU;
+	uint8_t is_resp = h->type &0x80U;
+	uint8_t is_aen = h->type == 0xFFU;
+	char* buf = ncsi_xmit_cmd_dump_buf;
+	uint32_t buf_off = 0;
+	NCSI_DUMP_PRN("id[%02x] typ[%s] chn[%02x] len[%3u]",
+			h->id,
+			ncsi_cmd_type_name_get(cmd_type),
+			h->channel,
+			htons(h->length) & 0xFFF);
+	if(is_resp)
+		NCSI_DUMP_PRN("Rsp[%04x] Reason[%04x]", ntohs(rsp->code), ntohs(rsp->reason));
+	if(is_aen)
+	{
+		char* aen_name;
+		struct ncsi_aen_lsc_pkt *lsc;
+		switch(aen_hdr->type)
+		{
+		case NCSI_PKT_AEN_LSC:
+			lsc = p_ncsi_head;
+			aen_name = "LinkChg   ";
+			NCSI_DUMP_PRN("AType[%s] Link[%x] OemLink[%x]", aen_name, ntohl(lsc->status), ntohl(lsc->oem_status));
+			break;
+		case NCSI_PKT_AEN_CR:
+			aen_name = "CfgChg    ";
+			NCSI_DUMP_PRN("AType[%s]", aen_name);
+			break;
+		case NCSI_PKT_AEN_HNCDSC:
+			aen_name = "HostDrvChg";
+			NCSI_DUMP_PRN("AType[%s]", aen_name);
+			break;
+		}
+		return;
+	}
+
+	switch(h->type)
+	{
+		case NCSI_PKT_CMD_CIS:
+			break;
+		case NCSI_PKT_CMD_SP:
+			NCSI_DUMP_FIELD_U8(ncsi_cmd_sp_pkt, hw_arbitration);
+			break;
+		case NCSI_PKT_CMD_DP	 :
+			break;
+		case NCSI_PKT_CMD_EC	 :
+			break;
+		case NCSI_PKT_CMD_DC	 :
+			NCSI_DUMP_FIELD_U8(ncsi_cmd_dc_pkt, ald);
+			break;
+		case NCSI_PKT_CMD_RC	 :
+			break;
+		case NCSI_PKT_CMD_ECNT	 :
+			break;
+		case NCSI_PKT_CMD_DCNT	 :
+			break;
+		case NCSI_PKT_CMD_AE	 :
+			NCSI_DUMP_FIELD_U8(ncsi_cmd_ae_pkt, mc_id);
+			NCSI_DUMP_FIELD_U32(ncsi_cmd_ae_pkt, mode);
+			break;
+		case NCSI_PKT_CMD_SL	 :
+			NCSI_DUMP_FIELD_U32(ncsi_cmd_sl_pkt, mode);
+			NCSI_DUMP_FIELD_U32(ncsi_cmd_sl_pkt, oem_mode);
+			break;
+		case NCSI_PKT_CMD_GLS	 :
+			return;//don't dump gls
+			break;
+		case NCSI_PKT_CMD_SVF	 :
+			NCSI_DUMP_FIELD_U16(ncsi_cmd_svf_pkt, vlan);
+			NCSI_DUMP_FIELD_U8(ncsi_cmd_svf_pkt, index);
+			NCSI_DUMP_FIELD_U8(ncsi_cmd_svf_pkt, enable);
+			break;
+		case NCSI_PKT_CMD_EV	 :
+			NCSI_DUMP_FIELD_U8(ncsi_cmd_ev_pkt, mode);
+			break;
+		case NCSI_PKT_CMD_DV	 :
+			break;
+		case NCSI_PKT_CMD_SMA	 :
+			NCSI_DUMP_FIELD_MAC(ncsi_cmd_sma_pkt, mac);
+			NCSI_DUMP_FIELD_U8(ncsi_cmd_sma_pkt, index);
+			NCSI_DUMP_FIELD_U8(ncsi_cmd_sma_pkt, at_e);
+			break;
+		case NCSI_PKT_CMD_EBF	 :
+			NCSI_DUMP_FIELD_U32(ncsi_cmd_ebf_pkt, mode);
+			break;
+		case NCSI_PKT_CMD_DBF	 :
+			break;
+		case NCSI_PKT_CMD_EGMF	 :
+			NCSI_DUMP_FIELD_U32(ncsi_cmd_ebf_pkt, mode);
+			break;
+		case NCSI_PKT_CMD_DGMF	 :
+			break;
+		case NCSI_PKT_CMD_SNFC	 :
+			NCSI_DUMP_FIELD_U8(ncsi_cmd_snfc_pkt, mode);
+			break;
+		case NCSI_PKT_CMD_GVI	 :
+			break;
+		case NCSI_PKT_CMD_GC	 :
+			break;
+		case NCSI_PKT_CMD_GP	 :
+			break;
+		case NCSI_PKT_CMD_GCPS	 :
+			break;
+		case NCSI_PKT_CMD_GNS	 :
+			break;
+		case NCSI_PKT_CMD_GNPTS	 :
+			break;
+		case NCSI_PKT_CMD_GPS	 :
+			break;
+		case NCSI_PKT_CMD_OEM	 :
+			NCSI_DUMP_FIELD_U32(ncsi_oem_i210_cmd_mgmt_pkt, oem_id );
+			NCSI_DUMP_FIELD_U8(ncsi_oem_i210_cmd_mgmt_pkt, intel_cmd );
+			NCSI_DUMP_FIELD_U8(ncsi_oem_i210_cmd_mgmt_pkt, value1);
+			NCSI_DUMP_FIELD_U8(ncsi_oem_i210_cmd_mgmt_pkt, mgmt_ctl);
+			break;
+		case NCSI_PKT_CMD_PLDM	 :
+			break;
+		case NCSI_PKT_CMD_GPUUID :
+			break;
+
+		case NCSI_PKT_RSP_CIS	 :
+			break;
+		case NCSI_PKT_RSP_SP	 :
+			break;
+		case NCSI_PKT_RSP_DP	 :
+		case NCSI_PKT_RSP_EC	 :
+		case NCSI_PKT_RSP_DC	 :
+		case NCSI_PKT_RSP_RC	 :
+		case NCSI_PKT_RSP_ECNT	 :
+		case NCSI_PKT_RSP_DCNT	 :
+		case NCSI_PKT_RSP_AE	 :
+		case NCSI_PKT_RSP_SL	 :
+			break;
+		case NCSI_PKT_RSP_GLS	 :
+			return; //don't dump gls
+			NCSI_DUMP_FIELD_U32(ncsi_rsp_gls_pkt, status);
+			NCSI_DUMP_FIELD_U32(ncsi_rsp_gls_pkt, other);
+			NCSI_DUMP_FIELD_U32(ncsi_rsp_gls_pkt, oem_status);
+			break;
+		case NCSI_PKT_RSP_SVF	 :
+		case NCSI_PKT_RSP_EV	 :
+		case NCSI_PKT_RSP_DV	 :
+		case NCSI_PKT_RSP_SMA	 :
+		case NCSI_PKT_RSP_EBF	 :
+		case NCSI_PKT_RSP_DBF	 :
+		case NCSI_PKT_RSP_EGMF	 :
+		case NCSI_PKT_RSP_DGMF	 :
+		case NCSI_PKT_RSP_SNFC	 :
+			break;
+		case NCSI_PKT_RSP_GVI	 :
+			NCSI_DUMP_FIELD_U32(ncsi_rsp_gvi_pkt, ncsi_version);
+			NCSI_DUMP_FIELD_U8(ncsi_rsp_gvi_pkt, alpha2);
+			NCSI_DUMP_FIELD_STR(ncsi_rsp_gvi_pkt, fw_name);
+			NCSI_DUMP_FIELD_U32(ncsi_rsp_gvi_pkt, fw_version);
+			NCSI_DUMP_FIELD_U16(ncsi_rsp_gvi_pkt, pci_ids[0]);
+			NCSI_DUMP_FIELD_U16(ncsi_rsp_gvi_pkt, pci_ids[1]);
+			NCSI_DUMP_FIELD_U16(ncsi_rsp_gvi_pkt, pci_ids[2]);
+			NCSI_DUMP_FIELD_U16(ncsi_rsp_gvi_pkt, pci_ids[3]);
+			NCSI_DUMP_FIELD_U32(ncsi_rsp_gvi_pkt, mf_id);
+			break;
+		case NCSI_PKT_RSP_GC	 :
+			NCSI_DUMP_FIELD_U32(ncsi_rsp_gc_pkt, cap);
+			NCSI_DUMP_FIELD_U32(ncsi_rsp_gc_pkt, bc_cap);
+			NCSI_DUMP_FIELD_U32(ncsi_rsp_gc_pkt, mc_cap);
+			NCSI_DUMP_FIELD_U32(ncsi_rsp_gc_pkt, buf_cap);
+			NCSI_DUMP_FIELD_U32(ncsi_rsp_gc_pkt, aen_cap);
+			NCSI_DUMP_FIELD_U8(ncsi_rsp_gc_pkt, vlan_cnt);
+			NCSI_DUMP_FIELD_U8(ncsi_rsp_gc_pkt, mixed_cnt);
+			NCSI_DUMP_FIELD_U8(ncsi_rsp_gc_pkt, mc_cnt);
+			NCSI_DUMP_FIELD_U8(ncsi_rsp_gc_pkt, uc_cnt);
+			NCSI_DUMP_FIELD_U8(ncsi_rsp_gc_pkt, vlan_mode);
+			break;
+		case NCSI_PKT_RSP_GP	 :
+			NCSI_DUMP_FIELD_U8(ncsi_rsp_gp_pkt, mac_cnt);
+			NCSI_DUMP_FIELD_U8(ncsi_rsp_gp_pkt, mac_enable);
+			NCSI_DUMP_FIELD_U8(ncsi_rsp_gp_pkt, vlan_cnt);
+			NCSI_DUMP_FIELD_U16(ncsi_rsp_gp_pkt, vlan_enable);
+			NCSI_DUMP_FIELD_U32(ncsi_rsp_gp_pkt, link_mode);
+			NCSI_DUMP_FIELD_U32(ncsi_rsp_gp_pkt, bc_mode);
+			NCSI_DUMP_FIELD_U32(ncsi_rsp_gp_pkt, valid_modes);
+			NCSI_DUMP_FIELD_U8(ncsi_rsp_gp_pkt, vlan_mode);
+			NCSI_DUMP_FIELD_U8(ncsi_rsp_gp_pkt, fc_mode);
+			NCSI_DUMP_FIELD_U32(ncsi_rsp_gp_pkt, aen_mode);
+			NCSI_DUMP_FIELD_MAC(ncsi_rsp_gp_pkt, mac);
+			NCSI_DUMP_FIELD_U16(ncsi_rsp_gp_pkt, vlan);
+			break;
+		case NCSI_PKT_RSP_GCPS	 :
+			NCSI_DUMP_FIELD_U32(ncsi_rsp_gcps_pkt, cnt_hi         );
+			NCSI_DUMP_FIELD_U32(ncsi_rsp_gcps_pkt, cnt_lo         );
+			NCSI_DUMP_FIELD_U32(ncsi_rsp_gcps_pkt, rx_bytes       );
+			NCSI_DUMP_FIELD_U32(ncsi_rsp_gcps_pkt, tx_bytes       );
+			NCSI_DUMP_FIELD_U32(ncsi_rsp_gcps_pkt, rx_uc_pkts     );
+			NCSI_DUMP_FIELD_U32(ncsi_rsp_gcps_pkt, rx_mc_pkts     );
+			NCSI_DUMP_FIELD_U32(ncsi_rsp_gcps_pkt, rx_bc_pkts     );
+			NCSI_DUMP_FIELD_U32(ncsi_rsp_gcps_pkt, tx_uc_pkts     );
+			NCSI_DUMP_FIELD_U32(ncsi_rsp_gcps_pkt, tx_mc_pkts     );
+			NCSI_DUMP_FIELD_U32(ncsi_rsp_gcps_pkt, tx_bc_pkts     );
+			NCSI_DUMP_FIELD_U32(ncsi_rsp_gcps_pkt, fcs_err        );
+			NCSI_DUMP_FIELD_U32(ncsi_rsp_gcps_pkt, align_err      );
+			NCSI_DUMP_FIELD_U32(ncsi_rsp_gcps_pkt, false_carrier  );
+			NCSI_DUMP_FIELD_U32(ncsi_rsp_gcps_pkt, runt_pkts      );
+			NCSI_DUMP_FIELD_U32(ncsi_rsp_gcps_pkt, jabber_pkts    );
+			NCSI_DUMP_FIELD_U32(ncsi_rsp_gcps_pkt, rx_pause_xon   );
+			NCSI_DUMP_FIELD_U32(ncsi_rsp_gcps_pkt, rx_pause_xoff  );
+			NCSI_DUMP_FIELD_U32(ncsi_rsp_gcps_pkt, tx_pause_xon   );
+			NCSI_DUMP_FIELD_U32(ncsi_rsp_gcps_pkt, tx_pause_xoff  );
+			NCSI_DUMP_FIELD_U32(ncsi_rsp_gcps_pkt, tx_s_collision );
+			NCSI_DUMP_FIELD_U32(ncsi_rsp_gcps_pkt, tx_m_collision );
+			NCSI_DUMP_FIELD_U32(ncsi_rsp_gcps_pkt, l_collision    );
+			NCSI_DUMP_FIELD_U32(ncsi_rsp_gcps_pkt, e_collision    );
+			NCSI_DUMP_FIELD_U32(ncsi_rsp_gcps_pkt, rx_ctl_frames  );
+			NCSI_DUMP_FIELD_U32(ncsi_rsp_gcps_pkt, rx_64_frames   );
+			NCSI_DUMP_FIELD_U32(ncsi_rsp_gcps_pkt, rx_127_frames  );
+			NCSI_DUMP_FIELD_U32(ncsi_rsp_gcps_pkt, rx_255_frames  );
+			NCSI_DUMP_FIELD_U32(ncsi_rsp_gcps_pkt, rx_511_frames  );
+			NCSI_DUMP_FIELD_U32(ncsi_rsp_gcps_pkt, rx_1023_frames );
+			NCSI_DUMP_FIELD_U32(ncsi_rsp_gcps_pkt, rx_1522_frames );
+			NCSI_DUMP_FIELD_U32(ncsi_rsp_gcps_pkt, rx_9022_frames );
+			NCSI_DUMP_FIELD_U32(ncsi_rsp_gcps_pkt, tx_64_frames   );
+			NCSI_DUMP_FIELD_U32(ncsi_rsp_gcps_pkt, tx_127_frames  );
+			NCSI_DUMP_FIELD_U32(ncsi_rsp_gcps_pkt, tx_255_frames  );
+			NCSI_DUMP_FIELD_U32(ncsi_rsp_gcps_pkt, tx_511_frames  );
+			NCSI_DUMP_FIELD_U32(ncsi_rsp_gcps_pkt, tx_1023_frames );
+			NCSI_DUMP_FIELD_U32(ncsi_rsp_gcps_pkt, tx_1522_frames );
+			NCSI_DUMP_FIELD_U32(ncsi_rsp_gcps_pkt, tx_9022_frames );
+			NCSI_DUMP_FIELD_U32(ncsi_rsp_gcps_pkt, rx_valid_bytes );
+			NCSI_DUMP_FIELD_U32(ncsi_rsp_gcps_pkt, rx_runt_pkts   );
+			NCSI_DUMP_FIELD_U32(ncsi_rsp_gcps_pkt, rx_jabber_pkts );
+			break;
+		case NCSI_PKT_RSP_GNS	 :
+			NCSI_DUMP_FIELD_U32(ncsi_rsp_gns_pkt, rx_cmds );
+			NCSI_DUMP_FIELD_U32(ncsi_rsp_gns_pkt, dropped_cmds );
+			NCSI_DUMP_FIELD_U32(ncsi_rsp_gns_pkt, cmd_type_errs );
+			NCSI_DUMP_FIELD_U32(ncsi_rsp_gns_pkt, cmd_csum_errs );
+			NCSI_DUMP_FIELD_U32(ncsi_rsp_gns_pkt, rx_pkts );
+			NCSI_DUMP_FIELD_U32(ncsi_rsp_gns_pkt, tx_pkts );
+			NCSI_DUMP_FIELD_U32(ncsi_rsp_gns_pkt, tx_aen_pkts );
+			break;
+		case NCSI_PKT_RSP_GNPTS	 :
+			NCSI_DUMP_FIELD_U32(ncsi_rsp_gnpts_pkt, tx_pkts );
+			NCSI_DUMP_FIELD_U32(ncsi_rsp_gnpts_pkt, tx_dropped );
+			NCSI_DUMP_FIELD_U32(ncsi_rsp_gnpts_pkt, tx_channel_err );
+			NCSI_DUMP_FIELD_U32(ncsi_rsp_gnpts_pkt, tx_us_err );
+			NCSI_DUMP_FIELD_U32(ncsi_rsp_gnpts_pkt, rx_pkts );
+			NCSI_DUMP_FIELD_U32(ncsi_rsp_gnpts_pkt, rx_dropped );
+			NCSI_DUMP_FIELD_U32(ncsi_rsp_gnpts_pkt, rx_channel_err );
+			NCSI_DUMP_FIELD_U32(ncsi_rsp_gnpts_pkt, rx_us_err );
+			NCSI_DUMP_FIELD_U32(ncsi_rsp_gnpts_pkt, rx_os_err );
+			break;
+		case NCSI_PKT_RSP_GPS	 :
+			NCSI_DUMP_FIELD_U32(ncsi_rsp_gps_pkt, status );
+			break;
+		case NCSI_PKT_RSP_OEM	 :
+			NCSI_DUMP_FIELD_U32(ncsi_rsp_oem_i210_cmd_mgmt_pkt, oem_id );
+			NCSI_DUMP_FIELD_U8(ncsi_rsp_oem_i210_cmd_mgmt_pkt, intel_cmd );
+			NCSI_DUMP_FIELD_U8(ncsi_rsp_oem_i210_cmd_mgmt_pkt, value1);
+			break;
+		case NCSI_PKT_RSP_PLDM	 :
+		case NCSI_PKT_RSP_GPUUID :
+			break;
+		case NCSI_PKT_AEN:
+			switch(aen_hdr->type) {
+			case NCSI_PKT_AEN_LSC	: /*Link status change       */
+				NCSI_DUMP_PRN("[AEN_LSC]");
+				NCSI_DUMP_FIELD_U32(ncsi_aen_lsc_pkt, status );
+				NCSI_DUMP_FIELD_U32(ncsi_aen_lsc_pkt, oem_status );
+				break;
+			case NCSI_PKT_AEN_CR	: /* Configuration required   */
+				NCSI_DUMP_PRN("[AEN_CR]");
+				break;
+			case NCSI_PKT_AEN_HNCDSC: /* HNC driver status change */
+				NCSI_DUMP_PRN("[AEN_HNCDSC]");
+				NCSI_DUMP_FIELD_U32(ncsi_aen_hncdsc_pkt, status);
+				break;
+			}
+			break;
+	}
+	netdev_warn(n, "%s\n", ncsi_xmit_cmd_dump_buf);
+
+}
 int ncsi_xmit_cmd(struct ncsi_cmd_arg *nca)
 {
 	struct ncsi_request *nr;
 	struct ethhdr *eh;
 	struct ncsi_cmd_handler *nch = NULL;
 	int i, ret;
-
 	/* Search for the handler */
 	for (i = 0; i < ARRAY_SIZE(ncsi_cmd_handlers); i++) {
 		if (ncsi_cmd_handlers[i].type == nca->type) {
@@ -344,6 +1043,10 @@
 	mod_timer(&nr->timer, jiffies + 1 * HZ);
 
 	/* Send NCSI packet */
+#ifndef NO_SILC_MOD
+//ncsi_cmd_dump(nca->ndp->ndev.dev, eh+1);
+	ncsi_dump(nca->ndp->ndev.dev, eh+1);
+#endif
 	skb_get(nr->cmd);
 	ret = dev_queue_xmit(nr->cmd);
 	if (ret < 0) {
@@ -353,3 +1056,4 @@
 
 	return 0;
 }
+
--- linux-custom-orig/net/ncsi/ncsi-rsp.c	2019-10-21 23:25:46.000000000 +0800
+++ linux-custom-silicom/net/ncsi/ncsi-rsp.c	2020-10-15 10:55:20.557546607 +0800
@@ -24,9 +24,13 @@
 				 unsigned short payload)
 {
 	struct ncsi_rsp_pkt_hdr *h;
+	#ifdef NO_SILC_MOD
 	u32 checksum;
 	__be32 *pchecksum;
-
+	#endif
+	#ifdef SILC_EXTRA_DBG
+		unsigned expected_len;
+	#endif
 	/* Check NCSI packet header. We don't need validate
 	 * the packet type, which should have been checked
 	 * before calling this function.
@@ -36,7 +40,17 @@
 		return -EINVAL;
 	if (ntohs(h->common.length) != payload)
 		return -EINVAL;
+	#ifdef SILC_EXTRA_DBG
+		expected_len = ntohs(h->common.length) + skb_mac_header_len(nr->rsp) +
+				                    sizeof(h->common) + 4;
+		if (nr->rsp->len < expected_len) {
+			ncsi_warn("Failed : skb len %d, expected %d\n",
+						 nr->rsp->len, expected_len);
 
+	    print_hex_dump(KERN_WARNING, "EE : ", DUMP_PREFIX_OFFSET,
+	                   16, 1, skb_mac_header(nr->rsp), nr->rsp->len, 0);
+		}
+	#endif
 	/* Check on code and reason */
 	if (ntohs(h->code) != NCSI_PKT_RSP_C_COMPLETED ||
 	    ntohs(h->reason) != NCSI_PKT_RSP_R_NO_ERROR)
@@ -46,7 +60,15 @@
 	 * sender doesn't support checksum according to NCSI
 	 * specification.
 	 */
-	pchecksum = (__be32 *)((void *)(h + 1) + payload - 4);
+	//pchecksum = (__be32 *)((void *)(h + 1) + payload - 4);
+	  /*
+	   * Blair Wang:
+	   *  There're some data loss in the repsonse packet from Intel i210,
+	   *  such as GetVersion, GetCapa and GetLinkSta.
+	   *  So, disable the checking for checksum.
+	   */
+	#ifdef NO_SILC_MOD
+		pchecksum = (__be32 *)((void *)(h + 1) + payload);
 	if (ntohl(*pchecksum) == 0)
 		return 0;
 
@@ -54,7 +76,7 @@
 					   sizeof(*h) + payload - 4);
 	if (*pchecksum != htonl(checksum))
 		return -EINVAL;
-
+	#endif
 	return 0;
 }
 
@@ -123,7 +145,8 @@
 	/* Change state of all channels attached to the package */
 	NCSI_FOR_EACH_CHANNEL(np, nc) {
 		spin_lock_irqsave(&nc->lock, flags);
-		nc->state = NCSI_CHANNEL_INACTIVE;
+		//nc->state = NCSI_CHANNEL_INACTIVE;
+		ncsi_channel_state_set(nc, NCSI_CHANNEL_INACTIVE);
 		spin_unlock_irqrestore(&nc->lock, flags);
 	}
 
@@ -195,7 +218,8 @@
 
 	/* Update state for the specified channel */
 	spin_lock_irqsave(&nc->lock, flags);
-	nc->state = NCSI_CHANNEL_INACTIVE;
+	//nc->state = NCSI_CHANNEL_INACTIVE;
+	ncsi_channel_state_set(nc, NCSI_CHANNEL_INACTIVE);
 	spin_unlock_irqrestore(&nc->lock, flags);
 
 	return 0;
@@ -310,7 +334,13 @@
 	ncsi_find_package_and_channel(ndp, rsp->rsp.common.channel,
 				      NULL, &nc);
 	if (!nc)
+
+	{
+	#ifndef NO_SILC_MOD
+		ncsi_debug("ID %02x, channel not found for gls response", rsp->rsp.common.channel);
+	#endif
 		return -ENODEV;
+	}
 
 	ncm = &nc->modes[NCSI_MODE_LINK];
 	ncm->data[2] = ntohl(rsp->status);
@@ -318,7 +348,13 @@
 	ncm->data[4] = ntohl(rsp->oem_status);
 
 	if (nr->flags & NCSI_REQ_FLAG_EVENT_DRIVEN)
+	{
+	#ifndef NO_SILC_MOD
+		ncsi_debug("ID %02x, event driven, not resetting channel monitor state", rsp->rsp.common.channel);
+	#endif
 		return 0;
+	}
+
 
 	/* Reset the channel monitor if it has been enabled */
 	spin_lock_irqsave(&nc->lock, flags);
@@ -349,7 +385,12 @@
 	ncf = nc->filters[NCSI_FILTER_VLAN];
 	if (!ncf)
 		return -ENOENT;
-	if (cmd->index >= ncf->total)
+	//if (cmd->index >= ncf->total)
+	/*
+	 * Blair Wang :
+	 *   the cmd->index start from 1
+	 */
+	if (cmd->index > ncf->total)
 		return -ERANGE;
 
 	/* Add or remove the VLAN filter */
@@ -607,8 +648,9 @@
 	struct ncsi_dev_priv *ndp = nr->ndp;
 	struct ncsi_channel *nc;
 	struct ncsi_channel_version *ncv;
+#ifdef NO_SILC_MOD
 	int i;
-
+#endif
 	/* Find the channel */
 	rsp = (struct ncsi_rsp_gvi_pkt *)skb_network_header(nr->rsp);
 	ncsi_find_package_and_channel(ndp, rsp->rsp.common.channel,
@@ -622,10 +664,15 @@
 	ncv->alpha2 = rsp->alpha2;
 	memcpy(ncv->fw_name, rsp->fw_name, 12);
 	ncv->fw_version = ntohl(rsp->fw_version);
+#ifdef NO_SILC_MOD
 	for (i = 0; i < ARRAY_SIZE(ncv->pci_ids); i++)
 		ncv->pci_ids[i] = ntohs(rsp->pci_ids[i]);
 	ncv->mf_id = ntohl(rsp->mf_id);
-
+#else
+	/* Blair Wang : Workaround for i210 bug */
+	ncv->pci_ids[0] = ntohs(rsp->pci_ids[0]);
+	ncv->mf_id = 0xff;
+#endif
 	return 0;
 }
 
@@ -637,6 +684,9 @@
 	struct ncsi_channel_filter *ncf;
 	size_t size, entry_size;
 	int cnt, i;
+#ifndef NO_SILC_MOD
+	int j;
+#endif
 
 	/* Find the channel */
 	rsp = (struct ncsi_rsp_gc_pkt *)skb_network_header(nr->rsp);
@@ -653,13 +703,45 @@
 	nc->caps[NCSI_CAP_MC].cap = ntohl(rsp->mc_cap) &
 				    NCSI_CAP_MC_MASK;
 	nc->caps[NCSI_CAP_BUFFER].cap = ntohl(rsp->buf_cap);
+	/*
 	nc->caps[NCSI_CAP_AEN].cap = ntohl(rsp->aen_cap) &
 				     NCSI_CAP_AEN_MASK;
 	nc->caps[NCSI_CAP_VLAN].cap = rsp->vlan_mode &
 				      NCSI_CAP_VLAN_MASK;
-
+*/
+	#ifndef NO_SILC_MOD
+		/* Workaround for i210 bug - Blair Wang */
+		nc->caps[NCSI_CAP_AEN].cap = 0x01;
+		nc->caps[NCSI_CAP_VLAN].cap = 0;
+	#else
+		nc->caps[NCSI_CAP_AEN].cap = ntohl(rsp->aen_cap) & NCSI_CAP_AEN_MASK;
+		nc->caps[NCSI_CAP_VLAN].cap = rsp->vlan_mode & NCSI_CAP_VLAN_MASK;
+	#endif
 	/* Build filters */
 	for (i = 0; i < NCSI_FILTER_MAX; i++) {
+#ifndef NO_SILC_MOD
+		/* Workaround for i210 bug - Blair Wang */
+		switch (i) {
+		case NCSI_FILTER_VLAN:
+			cnt = 8;
+			entry_size = 2;
+		break;
+		case NCSI_FILTER_MIXED:
+			cnt = 0;
+			entry_size = 6;
+		break;
+		case NCSI_FILTER_MC:
+			cnt = 0;
+			entry_size = 6;
+		break;
+		case NCSI_FILTER_UC:
+			cnt = 0;
+			entry_size = 6;
+		break;
+		default:
+			continue;
+		}
+#else
 		switch (i) {
 		case NCSI_FILTER_VLAN:
 			cnt = rsp->vlan_cnt;
@@ -680,7 +762,7 @@
 		default:
 			continue;
 		}
-
+#endif
 		if (!cnt || nc->filters[i])
 			continue;
 
@@ -694,19 +776,49 @@
 
 		ncf->index = i;
 		ncf->total = cnt;
+#ifdef NO_SILC_MOD
 		if (i == NCSI_FILTER_VLAN) {
 			/* Set VLAN filters active so they are cleared in
 			 * first configuration state
 			 */
 			ncf->bitmap = U64_MAX;
 		} else {
-			ncf->bitmap = 0x0ul;
+			//ncf->bitmap = 0x0ul;
+			ncf->bitmap = 0x0ull;
 		}
+#else
+			if (i == NCSI_FILTER_VLAN) {
+				/* Set VLAN filters active so they are cleared in
+				 * first configuration state
+				 */
+				for (j = 0; j < ncf->total; j++)
+					set_bit(j, (void*)&ncf->bitmap);
+			}
+#endif
 		nc->filters[i] = ncf;
 	}
 
 	return 0;
 }
+#ifndef NO_SILC_MOD
+static int ncsi_rsp_handler_oem(struct ncsi_request *nr)
+{
+	struct ncsi_rsp_oem_i210_cmd_mgmt_pkt *rsp;
+	struct ncsi_dev_priv *ndp = nr->ndp;
+	struct ncsi_package *np;
+
+	/* Find the package */
+	rsp = (struct ncsi_rsp_oem_i210_cmd_mgmt_pkt *)skb_network_header(nr->rsp);
+	ncsi_find_package_and_channel(ndp, rsp->rsp.common.channel,
+																&np, NULL);
+	if (!np)
+		return -ENODEV;
+
+	netdev_dbg(nr->ndp->ndev.dev, "NCSI oem i210 succ\n");
+
+	return 0;
+}
+#endif
 
 static int ncsi_rsp_handler_gp(struct ncsi_request *nr)
 {
@@ -966,7 +1078,11 @@
 	{ NCSI_PKT_RSP_GNS,   172, ncsi_rsp_handler_gns     },
 	{ NCSI_PKT_RSP_GNPTS, 172, ncsi_rsp_handler_gnpts   },
 	{ NCSI_PKT_RSP_GPS,     8, ncsi_rsp_handler_gps     },
+#ifdef NO_SILC_MOD
 	{ NCSI_PKT_RSP_OEM,     0, NULL                     },
+#else
+	{ NCSI_PKT_RSP_OEM,     10, ncsi_rsp_handler_oem     },
+#endif
 	{ NCSI_PKT_RSP_PLDM,    0, NULL                     },
 	{ NCSI_PKT_RSP_GPUUID, 20, ncsi_rsp_handler_gpuuid  }
 };
@@ -981,8 +1097,8 @@
 	struct ncsi_pkt_hdr *hdr;
 	unsigned long flags;
 	int payload, i, ret;
-
 	/* Find the NCSI device */
+	printk("Do ncsi_rcv_rsp \n");
 	nd = ncsi_find_dev(dev);
 	ndp = nd ? TO_NCSI_DEV_PRIV(nd) : NULL;
 	if (!ndp)
@@ -990,6 +1106,9 @@
 
 	/* Check if it is AEN packet */
 	hdr = (struct ncsi_pkt_hdr *)skb_network_header(skb);
+//#ifndef NO_SILC_MOD
+	ncsi_dump(ndp->ndev.dev, hdr);
+//#endif
 	if (hdr->type == NCSI_PKT_AEN)
 		return ncsi_aen_handler(ndp, skb);
 
--- linux-custom-orig/net/ncsi/ncsi-manage.c	2019-10-21 23:25:46.000000000 +0800
+++ linux-custom-silicom/net/ncsi/ncsi-manage.c	2020-10-07 22:07:33.061795487 +0800
@@ -38,7 +38,7 @@
 	return sizes[table];
 }
 
-u32 *ncsi_get_filter(struct ncsi_channel *nc, int table, int index)
+u8 *ncsi_get_filter(struct ncsi_channel *nc, int table, int index)
 {
 	struct ncsi_channel_filter *ncf;
 	int size;
@@ -53,6 +53,102 @@
 
 	return ncf->data + size * index;
 }
+#ifndef NO_SILC_MOD
+static char* ncsi_state_name_get(int state)
+{
+	switch(state)
+	{
+	case ncsi_dev_state_registered:
+		return "registered";
+	case ncsi_dev_state_functional:
+		return "functional";
+	case ncsi_dev_state_probe	:
+		return "probe";
+	case ncsi_dev_state_config	:
+		return "config";
+	case ncsi_dev_state_suspend	:
+		return "suspend";
+
+	case ncsi_dev_state_probe_deselect:
+		return "probe_deselect";
+	case ncsi_dev_state_probe_package:
+		return "probe_package";
+	case ncsi_dev_state_probe_channel:
+		return "probe_channel";
+	case ncsi_dev_state_probe_cis:
+		return "probe_cis";
+	case ncsi_dev_state_probe_gvi:
+		return "probe_gvi";
+	case ncsi_dev_state_probe_gc:
+		return "probe_gc";
+	case ncsi_dev_state_probe_gls:
+		return "probe_gls";
+	case ncsi_dev_state_probe_dp:
+		return "probe_dp";
+	case ncsi_dev_state_config_sp	:
+		return "config_sp";
+	case ncsi_dev_state_config_ev	:
+		return "config_ev";
+	case ncsi_dev_state_config_cis	:
+		return "config_cis";
+	case ncsi_dev_state_config_clear_vids:
+		return "config_clear_vids";
+	case ncsi_dev_state_config_svf	:
+		return "config_svf";
+	case ncsi_dev_state_config_sma	:
+		return "config_sma";
+	case ncsi_dev_state_config_ebf	:
+		return "config_ebf";
+#if IS_ENABLED(CONFIG_IPV6)
+	case ncsi_dev_state_config_egmf	:
+		return "config_egmf";
+#endif
+	case ncsi_dev_state_config_ecnt	:
+		return "config_ecnt";
+	case ncsi_dev_state_config_ec	:
+		return "config_ec";
+	case ncsi_dev_state_config_ae	:
+		return "config_ae";
+	case ncsi_dev_state_config_gls	:
+		return "config_gls";
+	case ncsi_dev_state_config_intel_crit	:
+		return "config_intel_crit";
+	case ncsi_dev_state_config_done	:
+		return "config_done";
+	case ncsi_dev_state_suspend_select	:
+		return "suspend_select";
+	case ncsi_dev_state_suspend_gls	:
+		return "suspend_gls";
+	case ncsi_dev_state_suspend_dcnt	:
+		return "suspend_dcnt";
+	case ncsi_dev_state_suspend_dc	:
+		return "suspend_dc";
+	case ncsi_dev_state_suspend_deselect	:
+		return "suspend_deselect";
+	case ncsi_dev_state_suspend_done	:
+		return "suspend_done";
+	}
+	return "UNK";
+}
+
+#if 1
+#define ncsi_set_state(nd, new_state)	\
+	do { \
+		ncsi_debug("NCSI State changed: old %s, new %s", \
+		ncsi_state_name_get((nd)->state), ncsi_state_name_get(new_state)); \
+		(nd)->state=(new_state);\
+	}while(0)
+
+#else
+
+#define ncsi_set_state(nd, new_state)	\
+	do { \
+		(nd)->state=(new_state);\
+	}while(0)
+
+#endif
+
+#endif	//NO_SILC_MOD
 
 /* Find the first active filter in a filter table that matches the given
  * data parameter. If data is NULL, this returns the first active filter.
@@ -153,7 +249,8 @@
 	struct ncsi_channel *nc;
 	unsigned long flags;
 
-	nd->state = ncsi_dev_state_functional;
+	//nd->state = ncsi_dev_state_functional;
+	ncsi_set_state(nd, ncsi_dev_state_functional);
 	if (force_down) {
 		nd->link_up = 0;
 		goto report;
@@ -302,14 +399,17 @@
 	struct ncsi_channel *nc, *tmp;
 	int index;
 	unsigned long flags;
-
+#ifndef NO_SILC_MOD
+	ncsi_debug("NCSI pkg %u add channel %u", np->id, id);
+#endif
 	nc = kzalloc(sizeof(*nc), GFP_ATOMIC);
 	if (!nc)
 		return NULL;
 
 	nc->id = id;
 	nc->package = np;
-	nc->state = NCSI_CHANNEL_INACTIVE;
+	//nc->state = NCSI_CHANNEL_INACTIVE;
+	ncsi_channel_state_set(nc, NCSI_CHANNEL_INACTIVE);
 	nc->monitor.enabled = false;
 	setup_timer(&nc->monitor.timer,
 		    ncsi_channel_monitor, (unsigned long)nc);
@@ -325,11 +425,17 @@
 	if (tmp) {
 		spin_unlock_irqrestore(&np->lock, flags);
 		kfree(nc);
+#ifndef NO_SILC_MOD
+		ncsi_debug("NCSI pkg %u add channel %u, already exit", np->id, 	id);
+#endif
 		return tmp;
 	}
 
 	list_add_tail_rcu(&nc->node, &np->channels);
 	np->channel_num++;
+	#ifndef NO_SILC_MOD
+		ncsi_debug("NCSI pkg %u added channel %u, total %u", np->id, id, np->channel_num);
+	#endif
 	spin_unlock_irqrestore(&np->lock, flags);
 
 	return nc;
@@ -341,6 +447,9 @@
 	struct ncsi_channel_filter *ncf;
 	unsigned long flags;
 	int i;
+	#ifndef NO_SILC_MOD
+		ncsi_debug("NCSI pkg %u rmv channel %u", np->id, nc->id);
+	#endif
 
 	/* Release filters */
 	spin_lock_irqsave(&nc->lock, flags);
@@ -353,7 +462,8 @@
 		kfree(ncf);
 	}
 
-	nc->state = NCSI_CHANNEL_INACTIVE;
+	//nc->state = NCSI_CHANNEL_INACTIVE;
+	ncsi_channel_state_set(nc, NCSI_CHANNEL_INACTIVE);
 	spin_unlock_irqrestore(&nc->lock, flags);
 	ncsi_stop_channel_monitor(nc);
 
@@ -379,12 +489,35 @@
 	return NULL;
 }
 
+#ifndef NO_SILC_MOD
+
+void ncsi_oem_cmd_intel_crit(struct ncsi_dev_priv *ndp, struct ncsi_channel *nc)
+{
+//	struct ncsi_dev *nd = &ndp->ndev;
+	struct ncsi_package *np = nc->package;
+//	struct ncsi_channel *nc = ndp->active_channel;
+	struct ncsi_cmd_arg nca;
+//	int ret;
+
+	nca.ndp = ndp;
+	nca.req_flags = 0;
+	nca.type = NCSI_PKT_CMD_OEM;
+	nca.package = np->id;
+	nca.channel = nc->id;
+	ncsi_xmit_cmd(&nca);
+
+	return;
+}
+#endif
+
 struct ncsi_package *ncsi_add_package(struct ncsi_dev_priv *ndp,
 				      unsigned char id)
 {
 	struct ncsi_package *np, *tmp;
 	unsigned long flags;
-
+#ifndef NO_SILC_MOD
+	ncsi_debug("NCSI add pkg %u, total: %u", id, ndp->package_num);
+#endif
 	np = kzalloc(sizeof(*np), GFP_ATOMIC);
 	if (!np)
 		return NULL;
@@ -397,6 +530,9 @@
 	spin_lock_irqsave(&ndp->lock, flags);
 	tmp = ncsi_find_package(ndp, id);
 	if (tmp) {
+#ifndef NO_SILC_MOD
+		ncsi_debug("NCSI pkg %u exist", id);
+#endif
 		spin_unlock_irqrestore(&ndp->lock, flags);
 		kfree(np);
 		return tmp;
@@ -404,6 +540,9 @@
 
 	list_add_tail_rcu(&np->node, &ndp->packages);
 	ndp->package_num++;
+#ifndef NO_SILC_MOD
+	ncsi_debug("NCSI added pkg %u, total: %u", id, ndp->package_num);
+#endif
 	spin_unlock_irqrestore(&ndp->lock, flags);
 
 	return np;
@@ -414,7 +553,9 @@
 	struct ncsi_dev_priv *ndp = np->ndp;
 	struct ncsi_channel *nc, *tmp;
 	unsigned long flags;
-
+#ifndef NO_SILC_MOD
+	ncsi_debug("NCSI removing pkg %u , total: %u", np->id, ndp->package_num);
+#endif
 	/* Release all child channels */
 	list_for_each_entry_safe(nc, tmp, &np->channels, node)
 		ncsi_remove_channel(nc);
@@ -423,6 +564,9 @@
 	spin_lock_irqsave(&ndp->lock, flags);
 	list_del_rcu(&np->node);
 	ndp->package_num--;
+#ifndef NO_SILC_MOD
+	ncsi_debug("NCSI removed pkg %u , total: %u", np->id, ndp->package_num);
+#endif
 	spin_unlock_irqrestore(&ndp->lock, flags);
 
 	kfree(np);
@@ -561,7 +705,8 @@
 	nca.req_flags = NCSI_REQ_FLAG_EVENT_DRIVEN;
 	switch (nd->state) {
 	case ncsi_dev_state_suspend:
-		nd->state = ncsi_dev_state_suspend_select;
+		//nd->state = ncsi_dev_state_suspend_select;
+		ncsi_set_state(nd, ncsi_dev_state_suspend_select);
 		/* Fall through */
 	case ncsi_dev_state_suspend_select:
 		ndp->pending_req_num = 1;
@@ -583,9 +728,11 @@
 		 * inactive channels can't be updated with LSC AEN in time.
 		 */
 		if (ndp->flags & NCSI_DEV_RESHUFFLE)
-			nd->state = ncsi_dev_state_suspend_gls;
+			//nd->state = ncsi_dev_state_suspend_gls;
+			ncsi_set_state(nd, ncsi_dev_state_suspend_gls);
 		else
-			nd->state = ncsi_dev_state_suspend_dcnt;
+			//nd->state = ncsi_dev_state_suspend_dcnt;
+			ncsi_set_state(nd, ncsi_dev_state_suspend_dcnt);
 		ret = ncsi_xmit_cmd(&nca);
 		if (ret)
 			goto error;
@@ -597,7 +744,8 @@
 		nca.type = NCSI_PKT_CMD_GLS;
 		nca.package = np->id;
 
-		nd->state = ncsi_dev_state_suspend_dcnt;
+		//nd->state = ncsi_dev_state_suspend_dcnt;
+		ncsi_set_state(nd, ncsi_dev_state_suspend_dcnt);
 		NCSI_FOR_EACH_CHANNEL(np, nc) {
 			nca.channel = nc->id;
 			ret = ncsi_xmit_cmd(&nca);
@@ -613,7 +761,8 @@
 		nca.package = np->id;
 		nca.channel = nc->id;
 
-		nd->state = ncsi_dev_state_suspend_dc;
+		//nd->state = ncsi_dev_state_suspend_dc;
+		ncsi_set_state(nd, ncsi_dev_state_suspend_dc);
 		ret = ncsi_xmit_cmd(&nca);
 		if (ret)
 			goto error;
@@ -627,7 +776,8 @@
 		nca.channel = nc->id;
 		nca.bytes[0] = 1;
 
-		nd->state = ncsi_dev_state_suspend_deselect;
+		//nd->state = ncsi_dev_state_suspend_deselect;
+		ncsi_set_state(nd, ncsi_dev_state_suspend_deselect);
 		ret = ncsi_xmit_cmd(&nca);
 		if (ret)
 			goto error;
@@ -640,7 +790,8 @@
 		nca.package = np->id;
 		nca.channel = NCSI_RESERVED_CHANNEL;
 
-		nd->state = ncsi_dev_state_suspend_done;
+		//nd->state = ncsi_dev_state_suspend_done;
+		ncsi_set_state(nd, ncsi_dev_state_suspend_done);
 		ret = ncsi_xmit_cmd(&nca);
 		if (ret)
 			goto error;
@@ -648,7 +799,8 @@
 		break;
 	case ncsi_dev_state_suspend_done:
 		spin_lock_irqsave(&nc->lock, flags);
-		nc->state = NCSI_CHANNEL_INACTIVE;
+		//nc->state = NCSI_CHANNEL_INACTIVE;
+		ncsi_channel_state_set(nc, NCSI_CHANNEL_INACTIVE);
 		spin_unlock_irqrestore(&nc->lock, flags);
 		ncsi_process_next_channel(ndp);
 
@@ -660,7 +812,8 @@
 
 	return;
 error:
-	nd->state = ncsi_dev_state_functional;
+	//nd->state = ncsi_dev_state_functional;
+	ncsi_set_state(nd, ncsi_dev_state_functional);
 }
 
 /* Check the VLAN filter bitmap for a set filter, and construct a
@@ -670,7 +823,8 @@
 			 struct ncsi_cmd_arg *nca)
 {
 	int index;
-	u32 *data;
+	//u32 *data;
+	u8 *data;
 	u16 vid;
 
 	index = ncsi_find_filter(nc, NCSI_FILTER_VLAN, NULL);
@@ -766,6 +920,7 @@
 	struct ncsi_cmd_arg nca;
 	unsigned char index;
 	unsigned long flags;
+	unsigned short new_state;
 	int ret;
 
 	nca.ndp = ndp;
@@ -787,7 +942,8 @@
 		if (ret)
 			goto error;
 
-		nd->state = ncsi_dev_state_config_cis;
+		//nd->state = ncsi_dev_state_config_cis;
+		ncsi_set_state(nd, ncsi_dev_state_config_cis);
 		break;
 	case ncsi_dev_state_config_cis:
 		ndp->pending_req_num = 1;
@@ -800,7 +956,8 @@
 		if (ret)
 			goto error;
 
-		nd->state = ncsi_dev_state_config_clear_vids;
+		//nd->state = ncsi_dev_state_config_clear_vids;
+		ncsi_set_state(nd, ncsi_dev_state_config_clear_vids);
 		break;
 	case ncsi_dev_state_config_clear_vids:
 	case ncsi_dev_state_config_svf:
@@ -812,33 +969,40 @@
 #endif
 	case ncsi_dev_state_config_ecnt:
 	case ncsi_dev_state_config_ec:
+#ifndef NO_SILC_MOD
+	case ncsi_dev_state_config_intel_crit:
+#endif
 	case ncsi_dev_state_config_ae:
 	case ncsi_dev_state_config_gls:
 		ndp->pending_req_num = 1;
 
 		nca.package = np->id;
 		nca.channel = nc->id;
-
+		new_state = 0;
 		/* Clear any active filters on the channel before setting */
 		if (nd->state == ncsi_dev_state_config_clear_vids) {
 			ret = clear_one_vid(ndp, nc, &nca);
 			if (ret) {
-				nd->state = ncsi_dev_state_config_svf;
+				//nd->state = ncsi_dev_state_config_svf;
+				ncsi_set_state(nd, ncsi_dev_state_config_svf);
 				schedule_work(&ndp->work);
 				break;
 			}
 			/* Repeat */
-			nd->state = ncsi_dev_state_config_clear_vids;
+			//nd->state = ncsi_dev_state_config_clear_vids;
+			new_state = ncsi_dev_state_config_clear_vids;
 		/* Add known VLAN tags to the filter */
 		} else if (nd->state == ncsi_dev_state_config_svf) {
 			ret = set_one_vid(ndp, nc, &nca);
 			if (ret) {
-				nd->state = ncsi_dev_state_config_ev;
+				//nd->state = ncsi_dev_state_config_ev;
+				ncsi_set_state(nd, ncsi_dev_state_config_ev);
 				schedule_work(&ndp->work);
 				break;
 			}
 			/* Repeat */
-			nd->state = ncsi_dev_state_config_svf;
+			//nd->state = ncsi_dev_state_config_svf;
+			new_state = ncsi_dev_state_config_svf;
 		/* Enable/Disable the VLAN filter */
 		} else if (nd->state == ncsi_dev_state_config_ev) {
 			if (list_empty(&ndp->vlan_vids)) {
@@ -847,7 +1011,8 @@
 				nca.type = NCSI_PKT_CMD_EV;
 				nca.bytes[3] = NCSI_CAP_VLAN_NO;
 			}
-			nd->state = ncsi_dev_state_config_sma;
+			//nd->state = ncsi_dev_state_config_sma;
+			new_state = ncsi_dev_state_config_sma;
 		} else if (nd->state == ncsi_dev_state_config_sma) {
 		/* Use first entry in unicast filter table. Note that
 		 * the MAC filter table starts from entry 1 instead of
@@ -858,45 +1023,79 @@
 				nca.bytes[index] = dev->dev_addr[index];
 			nca.bytes[6] = 0x1;
 			nca.bytes[7] = 0x1;
-			nd->state = ncsi_dev_state_config_ebf;
+			//nd->state = ncsi_dev_state_config_ebf;
+			new_state = ncsi_dev_state_config_ebf;
 		} else if (nd->state == ncsi_dev_state_config_ebf) {
 			nca.type = NCSI_PKT_CMD_EBF;
 			nca.dwords[0] = nc->caps[NCSI_CAP_BC].cap;
-			nd->state = ncsi_dev_state_config_ecnt;
+			//nd->state = ncsi_dev_state_config_ecnt;
+			new_state = ncsi_dev_state_config_ecnt;
 #if IS_ENABLED(CONFIG_IPV6)
 			if (ndp->inet6_addr_num > 0 &&
 			    (nc->caps[NCSI_CAP_GENERIC].cap &
 			     NCSI_CAP_GENERIC_MC))
-				nd->state = ncsi_dev_state_config_egmf;
+				//nd->state = ncsi_dev_state_config_egmf;
+				new_state = ncsi_dev_state_config_egmf;
 			else
-				nd->state = ncsi_dev_state_config_ecnt;
+				//nd->state = ncsi_dev_state_config_ecnt;
+				new_state = ncsi_dev_state_config_ecnt;
 		} else if (nd->state == ncsi_dev_state_config_egmf) {
 			nca.type = NCSI_PKT_CMD_EGMF;
 			nca.dwords[0] = nc->caps[NCSI_CAP_MC].cap;
-			nd->state = ncsi_dev_state_config_ecnt;
+			//nd->state = ncsi_dev_state_config_ecnt;
+			new_state = ncsi_dev_state_config_ecnt;
 #endif /* CONFIG_IPV6 */
 		} else if (nd->state == ncsi_dev_state_config_ecnt) {
 			nca.type = NCSI_PKT_CMD_ECNT;
-			nd->state = ncsi_dev_state_config_ec;
+			//nd->state = ncsi_dev_state_config_ec;
+			new_state = ncsi_dev_state_config_ec;
 		} else if (nd->state == ncsi_dev_state_config_ec) {
 			/* Enable AEN if it's supported */
 			nca.type = NCSI_PKT_CMD_EC;
+			/*
 			nd->state = ncsi_dev_state_config_ae;
 			if (!(nc->caps[NCSI_CAP_AEN].cap & NCSI_CAP_AEN_MASK))
 				nd->state = ncsi_dev_state_config_gls;
+	*/
+		if (nc->caps[NCSI_CAP_AEN].cap & NCSI_CAP_AEN_MASK)
+				new_state = ncsi_dev_state_config_ae;
+		else
+#ifdef NO_SILC_MOD
+				new_state = ncsi_dev_state_config_gls;
+#else
+				new_state = ncsi_dev_state_config_intel_crit;
+#endif
 		} else if (nd->state == ncsi_dev_state_config_ae) {
+			/*
 			nca.type = NCSI_PKT_CMD_AE;
 			nca.bytes[0] = 0;
 			nca.dwords[1] = nc->caps[NCSI_CAP_AEN].cap;
 			nd->state = ncsi_dev_state_config_gls;
+			*/
+			nca.type = NCSI_PKT_CMD_AE;
+			nca.bytes[0] = 0;
+			nca.dwords[1] = nc->caps[NCSI_CAP_AEN].cap;
+#ifndef NO_SILC_MOD
+			new_state = ncsi_dev_state_config_intel_crit;
+		} else if (nd->state == ncsi_dev_state_config_intel_crit) {
+			nca.type = NCSI_PKT_CMD_OEM;
+#endif
+			new_state = ncsi_dev_state_config_gls;
 		} else if (nd->state == ncsi_dev_state_config_gls) {
+			printk(KERN_ERR "State gls\n");
 			nca.type = NCSI_PKT_CMD_GLS;
-			nd->state = ncsi_dev_state_config_done;
+			//nd->state = ncsi_dev_state_config_done;
+			new_state = ncsi_dev_state_config_done;
 		}
 
 		ret = ncsi_xmit_cmd(&nca);
 		if (ret)
 			goto error;
+		/*
+		 * Blair Wang :
+		 *   Only change state after xmit succ
+		 */
+		ncsi_set_state(nd, new_state);
 		break;
 	case ncsi_dev_state_config_done:
 		spin_lock_irqsave(&nc->lock, flags);
@@ -921,10 +1120,12 @@
 
 		if (nc->modes[NCSI_MODE_LINK].data[2] & 0x1) {
 			hot_nc = nc;
-			nc->state = NCSI_CHANNEL_ACTIVE;
+			//nc->state = NCSI_CHANNEL_ACTIVE;
+			ncsi_channel_state_set(nc, NCSI_CHANNEL_ACTIVE);
 		} else {
 			hot_nc = NULL;
-			nc->state = NCSI_CHANNEL_INACTIVE;
+			//nc->state = NCSI_CHANNEL_INACTIVE;
+			ncsi_channel_state_set(nc, NCSI_CHANNEL_INACTIVE);
 		}
 		spin_unlock_irqrestore(&nc->lock, flags);
 
@@ -1075,7 +1276,8 @@
 	nca.req_flags = NCSI_REQ_FLAG_EVENT_DRIVEN;
 	switch (nd->state) {
 	case ncsi_dev_state_probe:
-		nd->state = ncsi_dev_state_probe_deselect;
+		//nd->state = ncsi_dev_state_probe_deselect;
+		ncsi_set_state(nd, ncsi_dev_state_probe_deselect);
 		/* Fall through */
 	case ncsi_dev_state_probe_deselect:
 		ndp->pending_req_num = 8;
@@ -1090,7 +1292,8 @@
 				goto error;
 		}
 
-		nd->state = ncsi_dev_state_probe_package;
+		//nd->state = ncsi_dev_state_probe_package;
+		ncsi_set_state(nd, ncsi_dev_state_probe_package);
 		break;
 	case ncsi_dev_state_probe_package:
 		ndp->pending_req_num = 16;
@@ -1115,7 +1318,8 @@
 				goto error;
 		}
 
-		nd->state = ncsi_dev_state_probe_channel;
+		//nd->state = ncsi_dev_state_probe_channel;
+		ncsi_set_state(nd, ncsi_dev_state_probe_channel);
 		break;
 	case ncsi_dev_state_probe_channel:
 		if (!ndp->active_package)
@@ -1156,7 +1360,8 @@
 		if (ret)
 			goto error;
 
-		nd->state = ncsi_dev_state_probe_cis;
+		//nd->state = ncsi_dev_state_probe_cis;
+		ncsi_set_state(nd, ncsi_dev_state_probe_cis);
 		break;
 	case ncsi_dev_state_probe_cis:
 		ndp->pending_req_num = NCSI_RESERVED_CHANNEL;
@@ -1171,7 +1376,8 @@
 				goto error;
 		}
 
-		nd->state = ncsi_dev_state_probe_gvi;
+		//nd->state = ncsi_dev_state_probe_gvi;
+		ncsi_set_state(nd, ncsi_dev_state_probe_gvi);
 		break;
 	case ncsi_dev_state_probe_gvi:
 	case ncsi_dev_state_probe_gc:
@@ -1196,11 +1402,14 @@
 		}
 
 		if (nd->state == ncsi_dev_state_probe_gvi)
-			nd->state = ncsi_dev_state_probe_gc;
+			//nd->state = ncsi_dev_state_probe_gc;
+			ncsi_set_state(nd, ncsi_dev_state_probe_gc);
 		else if (nd->state == ncsi_dev_state_probe_gc)
-			nd->state = ncsi_dev_state_probe_gls;
+			//nd->state = ncsi_dev_state_probe_gls;
+			ncsi_set_state(nd, ncsi_dev_state_probe_gls);
 		else
-			nd->state = ncsi_dev_state_probe_dp;
+			//nd->state = ncsi_dev_state_probe_dp;
+			ncsi_set_state(nd, ncsi_dev_state_probe_dp);
 		break;
 	case ncsi_dev_state_probe_dp:
 		ndp->pending_req_num = 1;
@@ -1214,7 +1423,8 @@
 			goto error;
 
 		/* Scan channels in next package */
-		nd->state = ncsi_dev_state_probe_channel;
+		//nd->state = ncsi_dev_state_probe_channel;
+		ncsi_set_state(nd, ncsi_dev_state_probe_channel);
 		break;
 	default:
 		netdev_warn(nd->dev, "Wrong NCSI state 0x%0x in enumeration\n",
@@ -1267,7 +1477,8 @@
 
 	spin_lock_irqsave(&nc->lock, flags);
 	old_state = nc->state;
-	nc->state = NCSI_CHANNEL_INVISIBLE;
+	//nc->state = NCSI_CHANNEL_INVISIBLE;
+	ncsi_channel_state_set(nc, NCSI_CHANNEL_INVISIBLE);
 	spin_unlock_irqrestore(&nc->lock, flags);
 
 	ndp->active_channel = nc;
@@ -1275,11 +1486,13 @@
 
 	switch (old_state) {
 	case NCSI_CHANNEL_INACTIVE:
-		ndp->ndev.state = ncsi_dev_state_config;
+		//ndp->ndev.state = ncsi_dev_state_config;
+		ncsi_set_state(&ndp->ndev, ncsi_dev_state_config);
 		ncsi_configure_channel(ndp);
 		break;
 	case NCSI_CHANNEL_ACTIVE:
-		ndp->ndev.state = ncsi_dev_state_suspend;
+		//ndp->ndev.state = ncsi_dev_state_suspend;
+		ncsi_set_state(&ndp->ndev, ncsi_dev_state_suspend);
 		ncsi_suspend_channel(ndp);
 		break;
 	default:
@@ -1527,7 +1740,8 @@
 		return NULL;
 
 	nd = &ndp->ndev;
-	nd->state = ncsi_dev_state_registered;
+	//nd->state = ncsi_dev_state_registered;
+	ncsi_set_state(nd, ncsi_dev_state_registered);
 	nd->dev = dev;
 	nd->handler = handler;
 	ndp->pending_req_num = 0;
@@ -1576,7 +1790,8 @@
 		return -ENOTTY;
 
 	if (!(ndp->flags & NCSI_DEV_PROBED)) {
-		nd->state = ncsi_dev_state_probe;
+		//nd->state = ncsi_dev_state_probe;
+		ncsi_set_state(nd, ncsi_dev_state_probe);
 		schedule_work(&ndp->work);
 		return 0;
 	}
@@ -1607,7 +1822,8 @@
 			spin_lock_irqsave(&nc->lock, flags);
 			chained = !list_empty(&nc->link);
 			old_state = nc->state;
-			nc->state = NCSI_CHANNEL_INACTIVE;
+			//nc->state = NCSI_CHANNEL_INACTIVE;
+			ncsi_channel_state_set(nc, NCSI_CHANNEL_INACTIVE);
 			spin_unlock_irqrestore(&nc->lock, flags);
 
 			WARN_ON_ONCE(chained ||
--- linux-custom-orig/net/ncsi/ncsi-pkt.h	2019-10-21 23:25:46.000000000 +0800
+++ linux-custom-silicom/net/ncsi/ncsi-pkt.h	2020-10-07 22:07:33.062795479 +0800
@@ -326,6 +326,32 @@
 	unsigned char           pad[18];
 };
 
+#ifndef NO_SILC_MOD
+/*
+ * Blair Wang:
+ *  The offset of checksum should be 4bytes aligned
+ */
+struct ncsi_oem_i210_cmd_mgmt_pkt {
+	struct ncsi_cmd_pkt_hdr cmd;      /* Command header */
+	__be32					oem_id;		/* must be 0x157 */
+	unsigned char			intel_cmd;	/* must be 0x20 */
+	unsigned char			value1;		/* must be 0x0*/
+	unsigned char			mgmt_ctl;	/* 1 to enable critical session mode*/
+	unsigned char     pad;
+	__be32            checksum;
+};
+struct ncsi_rsp_oem_i210_cmd_mgmt_pkt {
+	struct ncsi_rsp_pkt_hdr rsp;      /* Response header             */
+	__be32					oem_id;		/* must be 0x157 */
+	unsigned char			intel_cmd;	/* must be 0x20 */
+	unsigned char			value1;		/* must be 0x0*/
+	unsigned char     pad[2];
+	__be32            checksum;
+};
+
+#endif
+
+
 /* NCSI packet revision */
 #define NCSI_PKT_REVISION	0x01
 
@@ -411,5 +437,12 @@
 #define NCSI_PKT_AEN_LSC	0x00 /* Link status change       */
 #define NCSI_PKT_AEN_CR		0x01 /* Configuration required   */
 #define NCSI_PKT_AEN_HNCDSC	0x02 /* HNC driver status change */
+#ifndef NO_SILC_MOD
+/*
+ * Blair Wang:
+ *  The value of payload does not include the padding in NCSI packet.
+ */
+#define NCSI_PAYLOAD_ELEN(p) (((p) + 3) & 0xFFFC)
+#endif
 
 #endif /* __NCSI_PKT_H__ */
--- linux-custom-orig/net/ncsi/internal.h	2019-10-21 23:25:46.000000000 +0800
+++ linux-custom-silicom/net/ncsi/internal.h	2020-10-15 10:54:47.089806817 +0800
@@ -97,12 +97,16 @@
 	u32 size;	/* Valid entries in ncm_data[] */
 	u32 data[8];	/* Data entries                */
 };
-
+/*
+ * Blair Wang :
+ *   the field 'data' should be u8 type.
+ */
 struct ncsi_channel_filter {
 	u32 index;	/* Index of channel filters          */
 	u32 total;	/* Total entries in the filter table */
 	u64 bitmap;	/* Bitmap of valid entries           */
-	u32 data[];	/* Data for the valid entries        */
+	//u32 data[];	/* Data for the valid entries        */
+	u8  data[];	/* Data for the valid entries*/
 };
 
 struct ncsi_channel_stats {
@@ -246,6 +250,9 @@
 #endif
 	ncsi_dev_state_config_ecnt,
 	ncsi_dev_state_config_ec,
+#ifndef NO_SILC_MOD
+	ncsi_dev_state_config_intel_crit,
+#endif
 	ncsi_dev_state_config_ae,
 	ncsi_dev_state_config_gls,
 	ncsi_dev_state_config_done,
@@ -348,5 +355,35 @@
 int ncsi_rcv_rsp(struct sk_buff *skb, struct net_device *dev,
 		 struct packet_type *pt, struct net_device *orig_dev);
 int ncsi_aen_handler(struct ncsi_dev_priv *ndp, struct sk_buff *skb);
+void ncsi_dump(struct net_device* n,void* pkt);
+#ifndef NO_SILC_MOD
+#define ncsi_debug(fmt, ...)	printk(KERN_NOTICE "[%s:%u] "fmt "\n", __func__, __LINE__, ## __VA_ARGS__)
+#define ncsi_warn(fmt, ...)	printk(KERN_WARNING "[%s:%u] "fmt "\n", __func__, __LINE__, ## __VA_ARGS__)
+
+static inline char* ncsi_channel_state_name_get(int state)
+{
+	switch(state) {
+	case NCSI_CHANNEL_INACTIVE:
+		return "CHANNEL_INACTIVE ";
+	case NCSI_CHANNEL_ACTIVE:
+		return "CHANNEL_ACTIVE   ";
+	case NCSI_CHANNEL_INVISIBLE:
+		return "CHANNEL_INVISIBLE";
+	}
+	return "UNKNOWN       ";
+}
+#define ncsi_channel_state_set(nc, new_state)	\
+	do { \
+	ncsi_debug("Channel State Change, pkg %u, chn %u, old state %s new_state %s", \
+			(nc)->package->id, (nc)->id, ncsi_channel_state_name_get(nc->state), ncsi_channel_state_name_get(new_state)); \
+			(nc)->state = new_state; \
+	}while(0)
+
+
+void ncsi_oem_cmd_intel_crit(struct ncsi_dev_priv *ndp, struct ncsi_channel *nc);
+
+//#define SILC_EXTRA_DBG
+
+#endif
 
 #endif /* __NCSI_INTERNAL_H__ */
--- linux-custom-orig/net/ncsi/Kconfig	2019-10-21 23:25:46.000000000 +0800
+++ linux-custom-silicom/net/ncsi/Kconfig	2020-10-07 22:07:33.062795479 +0800
@@ -3,7 +3,7 @@
 #
 
 config NET_NCSI
-	bool "NCSI interface support"
+	tristate "NCSI interface support"
 	depends on INET
 	---help---
 	  This module provides NCSI (Network Controller Sideband Interface)
--- linux-custom-orig/net/ncsi/Makefile	2019-10-21 23:25:46.000000000 +0800
+++ linux-custom-silicom/net/ncsi/Makefile	2020-10-07 22:07:33.062795479 +0800
@@ -1,4 +1,6 @@
 #
 # Makefile for NCSI API
 #
-obj-$(CONFIG_NET_NCSI) += ncsi-cmd.o ncsi-rsp.o ncsi-aen.o ncsi-manage.o
+#obj-$(CONFIG_NET_NCSI) += ncsi-cmd.o ncsi-rsp.o ncsi-aen.o ncsi-manage.o
+ncsi-objs := ncsi-cmd.o ncsi-rsp.o ncsi-aen.o ncsi-manage.o
+obj-$(CONFIG_NET_NCSI)	+= ncsi.o
\ No newline at end of file
--- linux-custom-orig/include/net/ncsi.h	2019-10-21 23:25:46.000000000 +0800
+++ linux-custom-silicom/include/net/ncsi.h	2020-10-07 22:07:33.062795479 +0800
@@ -28,7 +28,8 @@
 	void		  (*handler)(struct ncsi_dev *ndev);
 };
 
-#ifdef CONFIG_NET_NCSI
+//#ifdef CONFIG_NET_NCSI
+#if defined(CONFIG_NET_NCSI) || defined(CONFIG_NET_NCSI_MODULE)
 int ncsi_vlan_rx_add_vid(struct net_device *dev, __be16 proto, u16 vid);
 int ncsi_vlan_rx_kill_vid(struct net_device *dev, __be16 proto, u16 vid);
 struct ncsi_dev *ncsi_register_dev(struct net_device *dev,
@@ -36,6 +37,14 @@
 int ncsi_start_dev(struct ncsi_dev *nd);
 void ncsi_stop_dev(struct ncsi_dev *nd);
 void ncsi_unregister_dev(struct ncsi_dev *nd);
+#ifndef NO_SILC_MOD
+#undef NCSI_CMD_DUMP
+#ifdef NCSI_CMD_DUMP
+void ncsi_cmd_dump(struct net_device* n, void* pkt);
+#else
+#define ncsi_cmd_dump(n, pkt)
+#endif
+#endif
 #else /* !CONFIG_NET_NCSI */
 static inline int ncsi_vlan_rx_add_vid(struct net_device *dev, __be16 proto, u16 vid)
 {
