diff -uNr uboot-custom-orig/board/silicom/ubmc_eval/board.c uboot-custom-silicom/board/silicom/ubmc_eval/board.c
--- uboot-custom-orig/board/silicom/ubmc_eval/board.c	1970-01-01 08:00:00.000000000 +0800
+++ uboot-custom-silicom/board/silicom/ubmc_eval/board.c	2018-08-05 13:30:37.130057216 +0800
@@ -0,0 +1,1243 @@
+/*
+ * board.c
+ *
+ * Board functions for TI AM335X based boards
+ *
+ * Copyright (C) 2011, Texas Instruments, Incorporated - http://www.ti.com/
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <errno.h>
+#include <spl.h>
+#include <serial.h>
+#include <asm/arch/cpu.h>
+#include <asm/arch/hardware.h>
+#include <asm/arch/omap.h>
+#include <asm/arch/ddr_defs.h>
+#include <asm/arch/clock.h>
+#include <asm/arch/clk_synthesizer.h>
+#include <asm/arch/gpio.h>
+#include <asm/arch/mmc_host_def.h>
+#include <asm/arch/sys_proto.h>
+#include <asm/arch/mem.h>
+#include <asm/io.h>
+#include <asm/emif.h>
+#include <asm/gpio.h>
+#include <asm/omap_sec_common.h>
+#include <i2c.h>
+#include <miiphy.h>
+#include <cpsw.h>
+#include <power/tps65217.h>
+#include <power/tps65910.h>
+#include <environment.h>
+#include <watchdog.h>
+#include <environment.h>
+#include <libfdt.h>
+#include <fdt_support.h>
+
+#include "mmc.h"
+#include "malloc.h"
+//#include "board_detect.h"
+#include "board.h"
+
+DECLARE_GLOBAL_DATA_PTR;
+
+/* GPIO that controls power to DDR on EVM-SK */
+#define GPIO_TO_PIN(bank, gpio)		(32 * (bank) + (gpio))
+#define GPIO_DDR_VTT_EN		GPIO_TO_PIN(0, 7)
+#define ICE_GPIO_DDR_VTT_EN	GPIO_TO_PIN(0, 18)
+#define GPIO_PR1_MII_CTRL	GPIO_TO_PIN(3, 4)
+#define GPIO_MUX_MII_CTRL	GPIO_TO_PIN(3, 10)
+#define GPIO_FET_SWITCH_CTRL	GPIO_TO_PIN(0, 7)
+#define GPIO_PHY_RESET		GPIO_TO_PIN(2, 5)
+#define GPIO_ETH0_MODE		GPIO_TO_PIN(0, 11)
+#define GPIO_ETH1_MODE		GPIO_TO_PIN(1, 26)
+
+static struct ctrl_dev *cdev = (struct ctrl_dev *)CTRL_DEVICE_BASE;
+
+#define GPIO0_RISINGDETECT	(AM33XX_GPIO0_BASE + OMAP_GPIO_RISINGDETECT)
+#define GPIO1_RISINGDETECT	(AM33XX_GPIO1_BASE + OMAP_GPIO_RISINGDETECT)
+
+#define GPIO0_IRQSTATUS1	(AM33XX_GPIO0_BASE + OMAP_GPIO_IRQSTATUS1)
+#define GPIO1_IRQSTATUS1	(AM33XX_GPIO1_BASE + OMAP_GPIO_IRQSTATUS1)
+
+#define GPIO0_IRQSTATUSRAW	(AM33XX_GPIO0_BASE + 0x024)
+#define GPIO1_IRQSTATUSRAW	(AM33XX_GPIO1_BASE + 0x024)
+
+/*
+ * Read header information from EEPROM into global structure.
+ */
+#ifdef CONFIG_TI_I2C_BOARD_DETECT
+void do_board_detect(void)
+{
+	enable_i2c0_pin_mux();
+	i2c_init(CONFIG_SYS_OMAP24_I2C_SPEED, CONFIG_SYS_OMAP24_I2C_SLAVE);
+
+	if (ti_i2c_eeprom_am_get(-1, CONFIG_SYS_I2C_EEPROM_ADDR))
+		printf("ti_i2c_eeprom_init failed\n");
+}
+#endif
+
+#ifndef CONFIG_DM_SERIAL
+struct serial_device *default_serial_console(void)
+{
+#if 0
+	if (board_is_icev2())
+		return &eserial4_device;
+	else
+		return &eserial2_device;
+#else
+	return &eserial1_device;
+#endif
+}
+#endif
+
+#ifndef CONFIG_SKIP_LOWLEVEL_INIT
+static const struct ddr_data ddr2_data = {
+	.datardsratio0 = MT47H128M16RT25E_RD_DQS,
+	.datafwsratio0 = MT47H128M16RT25E_PHY_FIFO_WE,
+	.datawrsratio0 = MT47H128M16RT25E_PHY_WR_DATA,
+};
+
+static const struct cmd_control ddr2_cmd_ctrl_data = {
+	.cmd0csratio = MT47H128M16RT25E_RATIO,
+
+	.cmd1csratio = MT47H128M16RT25E_RATIO,
+
+	.cmd2csratio = MT47H128M16RT25E_RATIO,
+};
+
+static const struct emif_regs ddr2_emif_reg_data = {
+	.sdram_config = MT47H128M16RT25E_EMIF_SDCFG,
+	.ref_ctrl = MT47H128M16RT25E_EMIF_SDREF,
+	.sdram_tim1 = MT47H128M16RT25E_EMIF_TIM1,
+	.sdram_tim2 = MT47H128M16RT25E_EMIF_TIM2,
+	.sdram_tim3 = MT47H128M16RT25E_EMIF_TIM3,
+	.emif_ddr_phy_ctlr_1 = MT47H128M16RT25E_EMIF_READ_LATENCY,
+};
+
+static const struct emif_regs ddr2_evm_emif_reg_data = {
+	.sdram_config = MT47H128M16RT25E_EMIF_SDCFG,
+	.ref_ctrl = MT47H128M16RT25E_EMIF_SDREF,
+	.sdram_tim1 = MT47H128M16RT25E_EMIF_TIM1,
+	.sdram_tim2 = MT47H128M16RT25E_EMIF_TIM2,
+	.sdram_tim3 = MT47H128M16RT25E_EMIF_TIM3,
+	.ocp_config = EMIF_OCP_CONFIG_AM335X_EVM,
+	.emif_ddr_phy_ctlr_1 = MT47H128M16RT25E_EMIF_READ_LATENCY,
+};
+
+static const struct ddr_data ddr3_data = {
+	.datardsratio0 = MT41J128MJT125_RD_DQS,
+	.datawdsratio0 = MT41J128MJT125_WR_DQS,
+	.datafwsratio0 = MT41J128MJT125_PHY_FIFO_WE,
+	.datawrsratio0 = MT41J128MJT125_PHY_WR_DATA,
+};
+
+static const struct ddr_data ddr3_beagleblack_data = {
+	.datardsratio0 = MT41K256M16HA125E_RD_DQS,
+	.datawdsratio0 = MT41K256M16HA125E_WR_DQS,
+	.datafwsratio0 = MT41K256M16HA125E_PHY_FIFO_WE,
+	.datawrsratio0 = MT41K256M16HA125E_PHY_WR_DATA,
+};
+
+static const struct ddr_data ddr3_evm_data = {
+	.datardsratio0 = MT41J512M8RH125_RD_DQS,
+	.datawdsratio0 = MT41J512M8RH125_WR_DQS,
+	.datafwsratio0 = MT41J512M8RH125_PHY_FIFO_WE,
+	.datawrsratio0 = MT41J512M8RH125_PHY_WR_DATA,
+};
+
+static const struct ddr_data ddr3_icev2_data = {
+	.datardsratio0 = MT41J128MJT125_RD_DQS_400MHz,
+	.datawdsratio0 = MT41J128MJT125_WR_DQS_400MHz,
+	.datafwsratio0 = MT41J128MJT125_PHY_FIFO_WE_400MHz,
+	.datawrsratio0 = MT41J128MJT125_PHY_WR_DATA_400MHz,
+};
+
+static const struct cmd_control ddr3_cmd_ctrl_data = {
+	.cmd0csratio = MT41J128MJT125_RATIO,
+	.cmd0iclkout = MT41J128MJT125_INVERT_CLKOUT,
+
+	.cmd1csratio = MT41J128MJT125_RATIO,
+	.cmd1iclkout = MT41J128MJT125_INVERT_CLKOUT,
+
+	.cmd2csratio = MT41J128MJT125_RATIO,
+	.cmd2iclkout = MT41J128MJT125_INVERT_CLKOUT,
+};
+
+static const struct cmd_control ddr3_beagleblack_cmd_ctrl_data = {
+	.cmd0csratio = MT41K256M16HA125E_RATIO,
+	.cmd0iclkout = MT41K256M16HA125E_INVERT_CLKOUT,
+
+	.cmd1csratio = MT41K256M16HA125E_RATIO,
+	.cmd1iclkout = MT41K256M16HA125E_INVERT_CLKOUT,
+
+	.cmd2csratio = MT41K256M16HA125E_RATIO,
+	.cmd2iclkout = MT41K256M16HA125E_INVERT_CLKOUT,
+};
+
+static const struct cmd_control ddr3_evm_cmd_ctrl_data = {
+	.cmd0csratio = MT41J512M8RH125_RATIO,
+	.cmd0iclkout = MT41J512M8RH125_INVERT_CLKOUT,
+
+	.cmd1csratio = MT41J512M8RH125_RATIO,
+	.cmd1iclkout = MT41J512M8RH125_INVERT_CLKOUT,
+
+	.cmd2csratio = MT41J512M8RH125_RATIO,
+	.cmd2iclkout = MT41J512M8RH125_INVERT_CLKOUT,
+};
+
+#ifdef NO_SILC_MOD
+static const struct cmd_control ddr3_icev2_cmd_ctrl_data = {
+	.cmd0csratio = MT41J128MJT125_RATIO_400MHz,
+	.cmd0iclkout = MT41J128MJT125_INVERT_CLKOUT_400MHz,
+
+	.cmd1csratio = MT41J128MJT125_RATIO_400MHz,
+	.cmd1iclkout = MT41J128MJT125_INVERT_CLKOUT_400MHz,
+
+	.cmd2csratio = MT41J128MJT125_RATIO_400MHz,
+	.cmd2iclkout = MT41J128MJT125_INVERT_CLKOUT_400MHz,
+};
+
+static struct emif_regs ddr3_emif_reg_data = {
+	.sdram_config = MT41J128MJT125_EMIF_SDCFG,
+	.ref_ctrl = MT41J128MJT125_EMIF_SDREF,
+	.sdram_tim1 = MT41J128MJT125_EMIF_TIM1,
+	.sdram_tim2 = MT41J128MJT125_EMIF_TIM2,
+	.sdram_tim3 = MT41J128MJT125_EMIF_TIM3,
+	.zq_config = MT41J128MJT125_ZQ_CFG,
+	.emif_ddr_phy_ctlr_1 = MT41J128MJT125_EMIF_READ_LATENCY |
+				PHY_EN_DYN_PWRDN,
+};
+
+static struct emif_regs ddr3_beagleblack_emif_reg_data = {
+	.sdram_config = MT41K256M16HA125E_EMIF_SDCFG,
+	.ref_ctrl = MT41K256M16HA125E_EMIF_SDREF,
+	.sdram_tim1 = MT41K256M16HA125E_EMIF_TIM1,
+	.sdram_tim2 = MT41K256M16HA125E_EMIF_TIM2,
+	.sdram_tim3 = MT41K256M16HA125E_EMIF_TIM3,
+	.ocp_config = EMIF_OCP_CONFIG_BEAGLEBONE_BLACK,
+	.zq_config = MT41K256M16HA125E_ZQ_CFG,
+	.emif_ddr_phy_ctlr_1 = MT41K256M16HA125E_EMIF_READ_LATENCY,
+};
+#endif
+
+static struct emif_regs ddr3_evm_emif_reg_data = {
+	.sdram_config = MT41J512M8RH125_EMIF_SDCFG,
+	.ref_ctrl = MT41J512M8RH125_EMIF_SDREF,
+	.sdram_tim1 = MT41J512M8RH125_EMIF_TIM1,
+	.sdram_tim2 = MT41J512M8RH125_EMIF_TIM2,
+	.sdram_tim3 = MT41J512M8RH125_EMIF_TIM3,
+	.ocp_config = EMIF_OCP_CONFIG_AM335X_EVM,
+	.zq_config = MT41J512M8RH125_ZQ_CFG,
+	.emif_ddr_phy_ctlr_1 = MT41J512M8RH125_EMIF_READ_LATENCY |
+				PHY_EN_DYN_PWRDN,
+};
+
+#ifdef NO_SILC_MOD
+static struct emif_regs ddr3_icev2_emif_reg_data = {
+	.sdram_config = MT41J128MJT125_EMIF_SDCFG_400MHz,
+	.ref_ctrl = MT41J128MJT125_EMIF_SDREF_400MHz,
+	.sdram_tim1 = MT41J128MJT125_EMIF_TIM1_400MHz,
+	.sdram_tim2 = MT41J128MJT125_EMIF_TIM2_400MHz,
+	.sdram_tim3 = MT41J128MJT125_EMIF_TIM3_400MHz,
+	.zq_config = MT41J128MJT125_ZQ_CFG_400MHz,
+	.emif_ddr_phy_ctlr_1 = MT41J128MJT125_EMIF_READ_LATENCY_400MHz |
+				PHY_EN_DYN_PWRDN,
+};
+#endif
+
+#ifdef CONFIG_SPL_OS_BOOT
+int spl_start_uboot(void)
+{
+	/* break into full u-boot on 'c' */
+	if (serial_tstc() && serial_getc() == 'c')
+		return 1;
+
+#ifdef CONFIG_SPL_ENV_SUPPORT
+	env_init();
+	env_relocate_spec();
+	if (getenv_yesno("boot_os") != 1)
+		return 1;
+#endif
+
+	return 0;
+}
+#endif
+
+const struct dpll_params *get_dpll_ddr_params(void)
+{
+	int ind = get_sys_clk_index();
+
+#ifdef NO_SILC_MOD
+	if (board_is_evm_sk())
+		return &dpll_ddr3_303MHz[ind];
+	else if (board_is_bone_lt() || board_is_icev2())
+		return &dpll_ddr3_400MHz[ind];
+	else if (board_is_evm_15_or_later())
+		return &dpll_ddr3_303MHz[ind];
+	else
+#endif
+		return &dpll_ddr2_266MHz[ind];
+}
+
+#ifdef NO_SILC_MOD
+static u8 bone_not_connected_to_ac_power(void)
+{
+	if (board_is_bone()) {
+		uchar pmic_status_reg;
+		if (tps65217_reg_read(TPS65217_STATUS,
+				      &pmic_status_reg))
+			return 1;
+		if (!(pmic_status_reg & TPS65217_PWR_SRC_AC_BITMASK)) {
+			puts("No AC power, switching to default OPP\n");
+			return 1;
+		}
+	}
+	return 0;
+}
+#endif
+
+const struct dpll_params *get_dpll_mpu_params(void)
+{
+	int ind = get_sys_clk_index();
+	int freq = am335x_get_efuse_mpu_max_freq(cdev);
+
+#ifdef NO_SILC_MOD
+	if (bone_not_connected_to_ac_power())
+		freq = MPUPLL_M_600;
+
+	if (board_is_bone_lt())
+		freq = MPUPLL_M_1000;
+#endif
+
+	switch (freq) {
+	case MPUPLL_M_1000:
+		return &dpll_mpu_opp[ind][5];
+	case MPUPLL_M_800:
+		return &dpll_mpu_opp[ind][4];
+	case MPUPLL_M_720:
+		return &dpll_mpu_opp[ind][3];
+	case MPUPLL_M_600:
+		return &dpll_mpu_opp[ind][2];
+	case MPUPLL_M_500:
+		return &dpll_mpu_opp100;
+	case MPUPLL_M_300:
+		return &dpll_mpu_opp[ind][0];
+	}
+
+	return &dpll_mpu_opp[ind][0];
+}
+
+#ifdef NO_SILC_MOD
+static void scale_vcores_bone(int freq)
+{
+	int usb_cur_lim, mpu_vdd;
+
+	/*
+	 * Only perform PMIC configurations if board rev > A1
+	 * on Beaglebone White
+	 */
+	if (board_is_bone() && !strncmp(board_ti_get_rev(), "00A1", 4))
+		return;
+
+	if (i2c_probe(TPS65217_CHIP_PM))
+		return;
+
+	/*
+	 * On Beaglebone White we need to ensure we have AC power
+	 * before increasing the frequency.
+	 */
+	if (bone_not_connected_to_ac_power())
+		freq = MPUPLL_M_600;
+
+	/*
+	 * Override what we have detected since we know if we have
+	 * a Beaglebone Black it supports 1GHz.
+	 */
+	if (board_is_bone_lt())
+		freq = MPUPLL_M_1000;
+
+	switch (freq) {
+	case MPUPLL_M_1000:
+		mpu_vdd = TPS65217_DCDC_VOLT_SEL_1325MV;
+		usb_cur_lim = TPS65217_USB_INPUT_CUR_LIMIT_1800MA;
+		break;
+	case MPUPLL_M_800:
+		mpu_vdd = TPS65217_DCDC_VOLT_SEL_1275MV;
+		usb_cur_lim = TPS65217_USB_INPUT_CUR_LIMIT_1300MA;
+		break;
+	case MPUPLL_M_720:
+		mpu_vdd = TPS65217_DCDC_VOLT_SEL_1200MV;
+		usb_cur_lim = TPS65217_USB_INPUT_CUR_LIMIT_1300MA;
+		break;
+	case MPUPLL_M_600:
+	case MPUPLL_M_500:
+	case MPUPLL_M_300:
+	default:
+		mpu_vdd = TPS65217_DCDC_VOLT_SEL_1100MV;
+		usb_cur_lim = TPS65217_USB_INPUT_CUR_LIMIT_1300MA;
+		break;
+	}
+
+	if (tps65217_reg_write(TPS65217_PROT_LEVEL_NONE,
+			       TPS65217_POWER_PATH,
+			       usb_cur_lim,
+			       TPS65217_USB_INPUT_CUR_LIMIT_MASK))
+		puts("tps65217_reg_write failure\n");
+
+	/* Set DCDC3 (CORE) voltage to 1.10V */
+	if (tps65217_voltage_update(TPS65217_DEFDCDC3,
+				    TPS65217_DCDC_VOLT_SEL_1100MV)) {
+		puts("tps65217_voltage_update failure\n");
+		return;
+	}
+
+	/* Set DCDC2 (MPU) voltage */
+	if (tps65217_voltage_update(TPS65217_DEFDCDC2, mpu_vdd)) {
+		puts("tps65217_voltage_update failure\n");
+		return;
+	}
+
+	/*
+	 * Set LDO3, LDO4 output voltage to 3.3V for Beaglebone.
+	 * Set LDO3 to 1.8V and LDO4 to 3.3V for Beaglebone Black.
+	 */
+	if (board_is_bone()) {
+		if (tps65217_reg_write(TPS65217_PROT_LEVEL_2,
+				       TPS65217_DEFLS1,
+				       TPS65217_LDO_VOLTAGE_OUT_3_3,
+				       TPS65217_LDO_MASK))
+			puts("tps65217_reg_write failure\n");
+	} else {
+		if (tps65217_reg_write(TPS65217_PROT_LEVEL_2,
+				       TPS65217_DEFLS1,
+				       TPS65217_LDO_VOLTAGE_OUT_1_8,
+				       TPS65217_LDO_MASK))
+			puts("tps65217_reg_write failure\n");
+	}
+
+	if (tps65217_reg_write(TPS65217_PROT_LEVEL_2,
+			       TPS65217_DEFLS2,
+			       TPS65217_LDO_VOLTAGE_OUT_3_3,
+			       TPS65217_LDO_MASK))
+		puts("tps65217_reg_write failure\n");
+}
+#endif
+
+void scale_vcores_generic(int freq)
+{
+	int sil_rev, mpu_vdd;
+
+	/*
+	 * The GP EVM, IDK and EVM SK use a TPS65910 PMIC.  For all
+	 * MPU frequencies we support we use a CORE voltage of
+	 * 1.10V.  For MPU voltage we need to switch based on
+	 * the frequency we are running at.
+	 */
+	if (i2c_probe(TPS65910_CTRL_I2C_ADDR))
+		return;
+
+	/*
+	 * Depending on MPU clock and PG we will need a different
+	 * VDD to drive at that speed.
+	 */
+	sil_rev = readl(&cdev->deviceid) >> 28;
+	mpu_vdd = am335x_get_tps65910_mpu_vdd(sil_rev, freq);
+
+	/* Tell the TPS65910 to use i2c */
+	tps65910_set_i2c_control();
+
+	/* First update MPU voltage. */
+	if (tps65910_voltage_update(MPU, mpu_vdd))
+		return;
+
+	/* Second, update the CORE voltage. */
+	if (tps65910_voltage_update(CORE, TPS65910_OP_REG_SEL_1_1_0))
+		return;
+
+}
+
+void gpi2c_init(void)
+{
+	/* When needed to be invoked prior to BSS initialization */
+	static bool first_time = true;
+
+	if (first_time) {
+		enable_i2c0_pin_mux();
+		i2c_init(CONFIG_SYS_OMAP24_I2C_SPEED,
+			 CONFIG_SYS_OMAP24_I2C_SLAVE);
+		first_time = false;
+	}
+}
+
+void scale_vcores(void)
+{
+	int freq;
+
+	gpi2c_init();
+	freq = am335x_get_efuse_mpu_max_freq(cdev);
+
+#ifdef NO_SILC_MOD
+	if (board_is_beaglebonex())
+		scale_vcores_bone(freq);
+	else
+#endif
+		scale_vcores_generic(freq);
+}
+
+void set_uart_mux_conf(void)
+{
+#if 0
+#if CONFIG_CONS_INDEX == 1
+	enable_uart0_pin_mux();
+#elif CONFIG_CONS_INDEX == 2
+	enable_uart1_pin_mux();
+#elif CONFIG_CONS_INDEX == 3
+	enable_uart2_pin_mux();
+#elif CONFIG_CONS_INDEX == 4
+	enable_uart3_pin_mux();
+#elif CONFIG_CONS_INDEX == 5
+	enable_uart4_pin_mux();
+#elif CONFIG_CONS_INDEX == 6
+	enable_uart5_pin_mux();
+#endif
+#else
+	enable_uart0_pin_mux();
+#endif
+}
+
+void set_mux_conf_regs(void)
+{
+	enable_board_pin_mux();
+}
+
+const struct ctrl_ioregs ioregs_evmsk = {
+	.cm0ioctl		= MT41J128MJT125_IOCTRL_VALUE,
+	.cm1ioctl		= MT41J128MJT125_IOCTRL_VALUE,
+	.cm2ioctl		= MT41J128MJT125_IOCTRL_VALUE,
+	.dt0ioctl		= MT41J128MJT125_IOCTRL_VALUE,
+	.dt1ioctl		= MT41J128MJT125_IOCTRL_VALUE,
+};
+
+const struct ctrl_ioregs ioregs_bonelt = {
+	.cm0ioctl		= MT41K256M16HA125E_IOCTRL_VALUE,
+	.cm1ioctl		= MT41K256M16HA125E_IOCTRL_VALUE,
+	.cm2ioctl		= MT41K256M16HA125E_IOCTRL_VALUE,
+	.dt0ioctl		= MT41K256M16HA125E_IOCTRL_VALUE,
+	.dt1ioctl		= MT41K256M16HA125E_IOCTRL_VALUE,
+};
+
+const struct ctrl_ioregs ioregs_evm15 = {
+	.cm0ioctl		= MT41J512M8RH125_IOCTRL_VALUE,
+	.cm1ioctl		= MT41J512M8RH125_IOCTRL_VALUE,
+	.cm2ioctl		= MT41J512M8RH125_IOCTRL_VALUE,
+	.dt0ioctl		= MT41J512M8RH125_IOCTRL_VALUE,
+	.dt1ioctl		= MT41J512M8RH125_IOCTRL_VALUE,
+};
+
+const struct ctrl_ioregs ioregs = {
+	.cm0ioctl		= MT47H128M16RT25E_IOCTRL_VALUE,
+	.cm1ioctl		= MT47H128M16RT25E_IOCTRL_VALUE,
+	.cm2ioctl		= MT47H128M16RT25E_IOCTRL_VALUE,
+	.dt0ioctl		= MT47H128M16RT25E_IOCTRL_VALUE,
+	.dt1ioctl		= MT47H128M16RT25E_IOCTRL_VALUE,
+};
+
+void sdram_init(void)
+{
+#ifdef NO_SILC_UBMC
+	if (board_is_evm_sk()) {
+		/*
+		 * EVM SK 1.2A and later use gpio0_7 to enable DDR3.
+		 * This is safe enough to do on older revs.
+		 */
+		gpio_request(GPIO_DDR_VTT_EN, "ddr_vtt_en");
+		gpio_direction_output(GPIO_DDR_VTT_EN, 1);
+	}
+
+	if (board_is_icev2()) {
+		printf("board_init ubmc_eval evm_sk\n")
+		gpio_request(ICE_GPIO_DDR_VTT_EN, "ddr_vtt_en");
+		gpio_direction_output(ICE_GPIO_DDR_VTT_EN, 1);
+	}
+
+	if (board_is_evm_sk())
+		config_ddr(303, &ioregs_evmsk, &ddr3_data,
+			   &ddr3_cmd_ctrl_data, &ddr3_emif_reg_data, 0);
+	else if (board_is_bone_lt())
+		config_ddr(400, &ioregs_bonelt,
+			   &ddr3_beagleblack_data,
+			   &ddr3_beagleblack_cmd_ctrl_data,
+			   &ddr3_beagleblack_emif_reg_data, 0);
+	else if (board_is_evm_15_or_later())
+		config_ddr(303, &ioregs_evm15, &ddr3_evm_data,
+			   &ddr3_evm_cmd_ctrl_data, &ddr3_evm_emif_reg_data, 0);
+	else if (board_is_icev2())
+		config_ddr(400, &ioregs_evmsk, &ddr3_icev2_data,
+			   &ddr3_icev2_cmd_ctrl_data, &ddr3_icev2_emif_reg_data,
+			   0);
+	else if (board_is_gp_evm())
+		config_ddr(266, &ioregs, &ddr2_data,
+			   &ddr2_cmd_ctrl_data, &ddr2_evm_emif_reg_data, 0);
+	else
+		config_ddr(266, &ioregs, &ddr2_data,
+			   &ddr2_cmd_ctrl_data, &ddr2_emif_reg_data, 0);
+#else
+	config_ddr(303, &ioregs_evm15, &ddr3_evm_data,
+		   &ddr3_evm_cmd_ctrl_data, &ddr3_evm_emif_reg_data, 0);
+#endif
+}
+#endif
+
+#if !defined(CONFIG_SPL_BUILD) || \
+	(defined(CONFIG_SPL_ETH_SUPPORT) && defined(CONFIG_SPL_BUILD))
+#ifdef NO_SILC_MOD
+static void request_and_set_gpio(int gpio, char *name, int val)
+{
+	int ret;
+
+	ret = gpio_request(gpio, name);
+	if (ret < 0) {
+		printf("%s: Unable to request %s\n", __func__, name);
+		return;
+	}
+
+	ret = gpio_direction_output(gpio, 0);
+	if (ret < 0) {
+		printf("%s: Unable to set %s  as output\n", __func__, name);
+		goto err_free_gpio;
+	}
+
+	gpio_set_value(gpio, val);
+
+	return;
+
+err_free_gpio:
+	gpio_free(gpio);
+}
+#define REQUEST_AND_SET_GPIO(N)	request_and_set_gpio(N, #N, 1);
+#define REQUEST_AND_CLR_GPIO(N)	request_and_set_gpio(N, #N, 0);
+
+/**
+ * RMII mode on ICEv2 board needs 50MHz clock. Given the clock
+ * synthesizer With a capacitor of 18pF, and 25MHz input clock cycle
+ * PLL1 gives an output of 100MHz. So, configuring the div2/3 as 2 to
+ * give 50MHz output for Eth0 and 1.
+ */
+static struct clk_synth cdce913_data = {
+	.id = 0x81,
+	.capacitor = 0x90,
+	.mux = 0x6d,
+	.pdiv2 = 0x2,
+	.pdiv3 = 0x2,
+};
+#endif
+#endif
+
+#if !defined(CONFIG_SPL_BUILD) || \
+	(defined(CONFIG_SPL_ETH_SUPPORT) && defined(CONFIG_SPL_BUILD)) || \
+	(defined(CONFIG_OF_LIBFDT) && defined(CONFIG_OF_BOARD_SETUP))
+
+static bool eth0_is_mii;
+static bool eth1_is_mii;
+#endif
+
+/*
+ * Basic board specific setup.  Pinmux has been handled already.
+ */
+int board_init(void)
+{
+	printf("board_init ubmc_eval\n");
+#if defined(CONFIG_HW_WATCHDOG)
+	hw_watchdog_init();
+#endif
+
+	gd->bd->bi_boot_params = CONFIG_SYS_SDRAM_BASE + 0x100;
+#if defined(CONFIG_NOR) || defined(CONFIG_NAND)
+	gpmc_init();
+#endif
+
+#if !defined(CONFIG_SPL_BUILD) || \
+	(defined(CONFIG_SPL_ETH_SUPPORT) && defined(CONFIG_SPL_BUILD))
+#ifdef NO_SILC_MOD
+	if (board_is_icev2()) {
+		int rv;
+		u32 reg;
+
+		/* factory default configuration */
+		eth0_is_mii = true;
+		eth1_is_mii = true;
+
+		REQUEST_AND_SET_GPIO(GPIO_PR1_MII_CTRL);
+		/* Make J19 status available on GPIO1_26 */
+		REQUEST_AND_CLR_GPIO(GPIO_MUX_MII_CTRL);
+
+		REQUEST_AND_SET_GPIO(GPIO_FET_SWITCH_CTRL);
+		/*
+		 * Both ports can be set as RMII-CPSW or MII-PRU-ETH using
+		 * jumpers near the port. Read the jumper value and set
+		 * the pinmux, external mux and PHY clock accordingly.
+		 * As jumper line is overridden by PHY RX_DV pin immediately
+		 * after bootstrap (power-up/reset), we need to sample
+		 * it during PHY reset using GPIO rising edge detection.
+		 */
+		REQUEST_AND_SET_GPIO(GPIO_PHY_RESET);
+		/* Enable rising edge IRQ on GPIO0_11 and GPIO 1_26 */
+		reg = readl(GPIO0_RISINGDETECT) | BIT(11);
+		writel(reg, GPIO0_RISINGDETECT);
+		reg = readl(GPIO1_RISINGDETECT) | BIT(26);
+		writel(reg, GPIO1_RISINGDETECT);
+		/* Reset PHYs to capture the Jumper setting */
+		gpio_set_value(GPIO_PHY_RESET, 0);
+		udelay(2);	/* PHY datasheet states 1uS min. */
+		gpio_set_value(GPIO_PHY_RESET, 1);
+
+		reg = readl(GPIO0_IRQSTATUSRAW) & BIT(11);
+		if (reg) {
+			writel(reg, GPIO0_IRQSTATUS1); /* clear irq */
+			/* RMII mode */
+			printf("ETH0, CPSW\n");
+			eth0_is_mii = false;
+		} else {
+			/* MII mode */
+			printf("ETH0, PRU\n");
+			cdce913_data.pdiv3 = 4;	/* 25MHz PHY clk */
+		}
+
+		reg = readl(GPIO1_IRQSTATUSRAW) & BIT(26);
+		if (reg) {
+			writel(reg, GPIO1_IRQSTATUS1); /* clear irq */
+			/* RMII mode */
+			printf("ETH1, CPSW\n");
+			gpio_set_value(GPIO_MUX_MII_CTRL, 1);
+			eth1_is_mii = false;
+		} else {
+			/* MII mode */
+			printf("ETH1, PRU\n");
+			cdce913_data.pdiv2 = 4;	/* 25MHz PHY clk */
+		}
+
+		/* disable rising edge IRQs */
+		reg = readl(GPIO0_RISINGDETECT) & ~BIT(11);
+		writel(reg, GPIO0_RISINGDETECT);
+		reg = readl(GPIO1_RISINGDETECT) & ~BIT(26);
+		writel(reg, GPIO1_RISINGDETECT);
+
+		rv = setup_clock_synthesizer(&cdce913_data);
+		if (rv) {
+			printf("Clock synthesizer setup failed %d\n", rv);
+			return rv;
+		}
+
+		/* reset PHYs */
+		gpio_set_value(GPIO_PHY_RESET, 0);
+		udelay(2);	/* PHY datasheet states 1uS min. */
+		gpio_set_value(GPIO_PHY_RESET, 1);
+	}
+#endif
+#endif
+
+	return 0;
+}
+
+#if defined(CONFIG_GENERIC_MMC)
+#define boot_prn(fmt, ...)	printf("====\nBOOT:"fmt"\n====\n", ## __VA_ARGS__)
+int board_mmc_read_flag(struct blk_desc * mmc_blk_dev, unsigned long addr, char* ret_flag)
+{
+	unsigned long blksz=mmc_blk_dev->blksz;
+	unsigned long start_blk=addr/blksz;
+	char* tmp_buf;
+	int ret;
+	if ((start_blk*mmc_blk_dev->blksz) != addr)
+	{
+		boot_prn("Error: Unaligned mmc read, addr %lx, blksz %lx", addr, blksz);
+		return -EINVAL;
+	}
+	tmp_buf = malloc(mmc_blk_dev->blksz*2);
+	if(tmp_buf == NULL)
+	{
+		boot_prn("Error: not enough memory\n");
+		return -ENOMEM;
+	}
+	ret = blk_dread(mmc_blk_dev, start_blk, 1, tmp_buf);
+	if(ret!=1)
+	{
+		boot_prn("Error: MMC read returned %d, addr %lx, blksz %lx", ret, addr, blksz);
+		free(tmp_buf);
+		return -EINVAL;
+	}
+	*ret_flag = tmp_buf[0];
+	free(tmp_buf);
+	
+	return 0;
+}
+
+int board_mmc_write_flag(struct blk_desc * mmc_blk_dev, unsigned long addr, char wr_flag)
+{
+	unsigned long blksz=mmc_blk_dev->blksz;
+	unsigned long start_blk=addr/blksz;
+	int ret;
+	char* tmp_buf;
+	if ((start_blk*mmc_blk_dev->blksz) != addr)
+	{
+		boot_prn("Error: Unaligned mmc write, addr %lx, blksz %lx", addr, blksz);
+		return -EINVAL;
+	}
+	tmp_buf = malloc(mmc_blk_dev->blksz*2);
+	if(tmp_buf == NULL)
+	{
+		boot_prn("Error: not enough memory\n");
+		return -ENOMEM;
+	}
+	memset(tmp_buf, 0, blksz);
+	tmp_buf[0] = wr_flag;
+	ret = blk_dwrite(mmc_blk_dev, start_blk, 1, tmp_buf);
+	if(ret!=1)
+	{
+		boot_prn("Error: MMC write returned %d, addr %lx, blksz %lx", ret, addr, blksz);
+		free(tmp_buf);
+		return -EINVAL;
+	}
+	free(tmp_buf);
+	return 0;
+}
+
+
+static struct mmc *init_mmc_device(int dev, bool force_init)
+{
+	struct mmc *mmc;
+	mmc = find_mmc_device(dev);
+	if (!mmc) {
+		boot_prn("no mmc device at slot %x\n", dev);
+		return NULL;
+	}
+
+	if (force_init)
+		mmc->has_init = 0;
+	if (mmc_init(mmc))
+		return NULL;
+	return mmc;
+}
+
+#include "../silicom_autoboot.c"
+int board_get_boot_info(void)
+{
+	//ubmc eval has only one mmc device
+	return silicom_autoboot_mmc(0, 0);
+}
+
+#endif
+
+#ifdef CONFIG_BOARD_LATE_INIT
+void __maybe_unused set_board_info_env(char *name)
+{
+	setenv("board_name", "ubmc_eval");
+	setenv("board_rev", "R300");
+//	setenv("board_serial", "XXXX-XXXXX");
+}
+
+int board_late_init(void)
+{
+#if !defined(CONFIG_SPL_BUILD)
+	uint8_t mac_addr[6];
+	uint32_t mac_hi, mac_lo;
+#endif
+
+#ifdef CONFIG_ENV_VARS_UBOOT_RUNTIME_CONFIG
+#ifdef NO_SILC_MOD
+	char *name = NULL;
+
+	if (board_is_bbg1())
+		name = "BBG1";
+	set_board_info_env(name);
+#else
+	set_board_info_env("ubmc_eval");
+#endif
+
+	/*
+	 * Default FIT boot on HS devices. Non FIT images are not allowed
+	 * on HS devices.
+	 */
+	if (get_device_type() == HS_DEVICE)
+		setenv("boot_fit", "1");
+#endif
+
+#if !defined(CONFIG_SPL_BUILD)
+	/* try reading mac address from efuse */
+	mac_lo = readl(&cdev->macid0l);
+	mac_hi = readl(&cdev->macid0h);
+	mac_addr[0] = mac_hi & 0xFF;
+	mac_addr[1] = (mac_hi & 0xFF00) >> 8;
+	mac_addr[2] = (mac_hi & 0xFF0000) >> 16;
+	mac_addr[3] = (mac_hi & 0xFF000000) >> 24;
+	mac_addr[4] = mac_lo & 0xFF;
+	mac_addr[5] = (mac_lo & 0xFF00) >> 8;
+
+	if (!getenv("ethaddr")) {
+		printf("<ethaddr> not set. Validating first E-fuse MAC\n");
+
+		if (is_valid_ethaddr(mac_addr))
+			eth_setenv_enetaddr("ethaddr", mac_addr);
+	}
+
+	mac_lo = readl(&cdev->macid1l);
+	mac_hi = readl(&cdev->macid1h);
+	mac_addr[0] = mac_hi & 0xFF;
+	mac_addr[1] = (mac_hi & 0xFF00) >> 8;
+	mac_addr[2] = (mac_hi & 0xFF0000) >> 16;
+	mac_addr[3] = (mac_hi & 0xFF000000) >> 24;
+	mac_addr[4] = mac_lo & 0xFF;
+	mac_addr[5] = (mac_lo & 0xFF00) >> 8;
+
+	if (!getenv("eth1addr")) {
+		if (is_valid_ethaddr(mac_addr))
+			eth_setenv_enetaddr("eth1addr", mac_addr);
+	}
+#endif
+
+	board_get_boot_info();
+	return 0;
+}
+#endif
+
+#ifndef CONFIG_DM_ETH
+
+#if (defined(CONFIG_DRIVER_TI_CPSW) && !defined(CONFIG_SPL_BUILD)) || \
+	(defined(CONFIG_SPL_ETH_SUPPORT) && defined(CONFIG_SPL_BUILD))
+static void cpsw_control(int enabled)
+{
+	/* VTP can be added here */
+
+	return;
+}
+
+static struct cpsw_slave_data cpsw_slaves[] = {
+	{
+		.slave_reg_ofs	= 0x208,
+		.sliver_reg_ofs	= 0xd80,
+		.phy_addr	= 0,
+	},
+	{
+		.slave_reg_ofs	= 0x308,
+		.sliver_reg_ofs	= 0xdc0,
+		.phy_addr	= 1,
+	},
+};
+
+static struct cpsw_platform_data cpsw_data = {
+	.mdio_base		= CPSW_MDIO_BASE,
+	.cpsw_base		= CPSW_BASE,
+	.mdio_div		= 0xff,
+	.channels		= 8,
+	.cpdma_reg_ofs		= 0x800,
+	.slaves			= 1,
+	.slave_data		= cpsw_slaves,
+	.ale_reg_ofs		= 0xd00,
+	.ale_entries		= 1024,
+	.host_port_reg_ofs	= 0x108,
+	.hw_stats_reg_ofs	= 0x900,
+	.bd_ram_ofs		= 0x2000,
+	.mac_control		= (1 << 5),
+	.control		= cpsw_control,
+	.host_port_num		= 0,
+	.version		= CPSW_CTRL_VERSION_2,
+};
+#endif
+
+#if ((defined(CONFIG_SPL_ETH_SUPPORT) || defined(CONFIG_SPL_USBETH_SUPPORT)) &&\
+	defined(CONFIG_SPL_BUILD)) || \
+	((defined(CONFIG_DRIVER_TI_CPSW) || \
+	  defined(CONFIG_USB_ETHER) && defined(CONFIG_MUSB_GADGET)) && \
+	 !defined(CONFIG_SPL_BUILD))
+
+/*
+ * This function will:
+ * Read the eFuse for MAC addresses, and set ethaddr/eth1addr/usbnet_devaddr
+ * in the environment
+ * Perform fixups to the PHY present on certain boards.  We only need this
+ * function in:
+ * - SPL with either CPSW or USB ethernet support
+ * - Full U-Boot, with either CPSW or USB ethernet
+ * Build in only these cases to avoid warnings about unused variables
+ * when we build an SPL that has neither option but full U-Boot will.
+ */
+int board_eth_init(bd_t *bis)
+{
+	int rv, n = 0;
+	uint8_t mac_addr[6];
+#if defined(CONFIG_USB_ETHER) && \
+	(!defined(CONFIG_SPL_BUILD) || defined(CONFIG_SPL_USBETH_SUPPORT))
+	uint32_t mac_hi, mac_lo;
+
+	/*
+	 * use efuse mac address for USB ethernet as we know that
+	 * both CPSW and USB ethernet will never be active at the same time
+	 */
+	mac_lo = readl(&cdev->macid0l);
+	mac_hi = readl(&cdev->macid0h);
+	mac_addr[0] = mac_hi & 0xFF;
+	mac_addr[1] = (mac_hi & 0xFF00) >> 8;
+	mac_addr[2] = (mac_hi & 0xFF0000) >> 16;
+	mac_addr[3] = (mac_hi & 0xFF000000) >> 24;
+	mac_addr[4] = mac_lo & 0xFF;
+	mac_addr[5] = (mac_lo & 0xFF00) >> 8;
+#endif
+
+
+#if (defined(CONFIG_DRIVER_TI_CPSW) && !defined(CONFIG_SPL_BUILD)) || \
+	(defined(CONFIG_SPL_ETH_SUPPORT) && defined(CONFIG_SPL_BUILD))
+	if (!getenv("ethaddr")) {
+		puts("<ethaddr> not set. Validating first E-fuse MAC\n");
+		if (is_valid_ethaddr(mac_addr))
+			eth_setenv_enetaddr("ethaddr", mac_addr);
+	}
+
+#ifdef CONFIG_DRIVER_TI_CPSW
+#ifdef NO_SILC_MOD
+	if (board_is_bone() || board_is_bone_lt() ||
+	    board_is_idk()) {
+		writel(MII_MODE_ENABLE, &cdev->miisel);
+		cpsw_slaves[0].phy_if = cpsw_slaves[1].phy_if =
+				PHY_INTERFACE_MODE_MII;
+	} else if (board_is_icev2()) {
+		writel(RMII_MODE_ENABLE | RMII_CHIPCKL_ENABLE, &cdev->miisel);
+		cpsw_slaves[0].phy_if = PHY_INTERFACE_MODE_RMII;
+		cpsw_slaves[1].phy_if = PHY_INTERFACE_MODE_RMII;
+		cpsw_slaves[0].phy_addr = 1;
+		cpsw_slaves[1].phy_addr = 3;
+	} else {
+#endif
+		writel((RGMII_MODE_ENABLE | RGMII_INT_DELAY), &cdev->miisel);
+		cpsw_slaves[0].phy_if = cpsw_slaves[1].phy_if =
+				PHY_INTERFACE_MODE_RGMII;
+#ifdef NO_SILC_MOD
+	}
+#endif
+
+	rv = cpsw_register(&cpsw_data);
+	if (rv < 0)
+		printf("Error %d registering CPSW switch\n", rv);
+	else
+		n += rv;
+#endif
+
+	/*
+	 *
+	 * CPSW RGMII Internal Delay Mode is not supported in all PVT
+	 * operating points.  So we must set the TX clock delay feature
+	 * in the AR8051 PHY.  Since we only support a single ethernet
+	 * device in U-Boot, we only do this for the first instance.
+	 */
+#define AR8051_PHY_DEBUG_ADDR_REG	0x1d
+#define AR8051_PHY_DEBUG_DATA_REG	0x1e
+#define AR8051_DEBUG_RGMII_CLK_DLY_REG	0x5
+#define AR8051_RGMII_TX_CLK_DLY		0x100
+
+#ifdef NO_SILC_MOD
+	if (board_is_evm_sk() || board_is_gp_evm()) {
+		const char *devname;
+		devname = miiphy_get_current_dev();
+
+		miiphy_write(devname, 0x0, AR8051_PHY_DEBUG_ADDR_REG,
+				AR8051_DEBUG_RGMII_CLK_DLY_REG);
+		miiphy_write(devname, 0x0, AR8051_PHY_DEBUG_DATA_REG,
+				AR8051_RGMII_TX_CLK_DLY);
+	}
+#endif
+#endif
+#if defined(CONFIG_USB_ETHER) && \
+	(!defined(CONFIG_SPL_BUILD) || defined(CONFIG_SPL_USBETH_SUPPORT))
+	if (is_valid_ethaddr(mac_addr))
+		eth_setenv_enetaddr("usbnet_devaddr", mac_addr);
+
+	rv = usb_eth_initialize(bis);
+	if (rv < 0)
+		printf("Error %d registering USB_ETHER\n", rv);
+	else
+		n += rv;
+#endif
+	return n;
+}
+#endif
+
+#endif /* CONFIG_DM_ETH */
+
+#ifdef CONFIG_SPL_LOAD_FIT
+int board_fit_config_name_match(const char *name)
+{
+#ifdef NO_SILC_MOD
+	if (board_is_gp_evm() && !strcmp(name, "am335x-evm"))
+		return 0;
+	else if (board_is_bone() && !strcmp(name, "am335x-bone"))
+		return 0;
+	else if (board_is_bone_lt() && !strcmp(name, "am335x-boneblack"))
+		return 0;
+	else if (board_is_evm_sk() && !strcmp(name, "am335x-evmsk"))
+		return 0;
+	else if (board_is_bbg1() && !strcmp(name, "am335x-bonegreen"))
+		return 0;
+	else if (board_is_icev2() && !strcmp(name, "am335x-icev2"))
+		return 0;
+	else
+		return -1;
+#else
+	if (strcmp(name, "ubmc_eval")==0)
+		return 0;
+	return -1;
+#endif
+}
+#endif
+
+#ifdef CONFIG_TI_SECURE_DEVICE
+void board_fit_image_post_process(void **p_image, size_t *p_size)
+{
+	secure_boot_verify_image(p_image, p_size);
+}
+#endif
+
+#if defined(CONFIG_OF_LIBFDT) && defined(CONFIG_OF_BOARD_SETUP)
+
+static const char pruss_eth0_alias[] = "/pruss_eth/ethernet-mii0";
+static const char pruss_eth1_alias[] = "/pruss_eth/ethernet-mii1";
+
+int ft_board_setup(void *fdt, bd_t *bd)
+{
+	const char *path;
+	int offs;
+	int ret;
+
+#ifdef NO_SILC_MOD
+	if (!board_is_icev2())
+#endif
+		return 0;
+
+	/* Board DT default is both ports are RMII */
+	if (!eth0_is_mii && !eth1_is_mii)
+		return 0;
+
+	if (eth0_is_mii != eth1_is_mii) {
+		printf("Unsupported Ethernet port configuration\n");
+		printf("Both ports must be set as RMII or MII\n");
+		return 0;
+	}
+
+	printf("Fixing up ETH0 & ETH1 to PRUSS Ethernet\n");
+	/* Enable PRUSS-MDIO */
+	path = "/ocp/pruss_soc_bus@4a326000/pruss@4a300000/mdio@4a332400";
+	offs = fdt_path_offset(fdt, path);
+	if (offs < 0)
+		goto no_node;
+
+	ret = fdt_status_okay(fdt, offs);
+	if (ret < 0)
+		goto enable_failed;
+
+	/* Enable PRU-ICSS Ethernet */
+	path = "/pruss_eth";
+	offs = fdt_path_offset(fdt, path);
+	if (offs < 0)
+		goto no_node;
+
+	ret = fdt_status_okay(fdt, offs);
+	if (ret < 0)
+		goto enable_failed;
+
+	/* Disable CPSW Ethernet */
+	path = "/ocp/ethernet@4a100000";
+	offs = fdt_path_offset(fdt, path);
+	if (offs < 0)
+		goto no_node;
+
+	ret = fdt_status_disabled(fdt, offs);
+	if (ret < 0)
+		goto disable_failed;
+
+	/* Disable CPSW-MDIO */
+	path = "/ocp/ethernet@4a100000/mdio@4a101000";
+	offs = fdt_path_offset(fdt, path);
+	if (offs < 0)
+		goto no_node;
+
+	ret = fdt_status_disabled(fdt, offs);
+	if (ret < 0)
+		goto disable_failed;
+
+	/* Set MUX_MII_CTL1 pin low */
+	path = "/ocp/gpio@481ae000/p10";
+	offs = fdt_path_offset(fdt, path);
+	if (offs < 0) {
+		printf("Node %s not found.\n", path);
+		return offs;
+	}
+
+	ret = fdt_delprop(fdt, offs, "output-high");
+	if (ret < 0) {
+		printf("Could not delete output-high property from node %s: %s\n",
+		       path, fdt_strerror(ret));
+		return ret;
+	}
+
+	ret = fdt_setprop(fdt, offs, "output-low", NULL, 0);
+	if (ret < 0) {
+		printf("Could not add output-low property to node %s: %s\n",
+		       path, fdt_strerror(ret));
+		return ret;
+	}
+
+	/* Fixup ethernet aliases */
+	path = "/aliases";
+	offs = fdt_path_offset(fdt, path);
+	if (offs < 0)
+		goto no_node;
+
+	ret = fdt_setprop(fdt, offs, "ethernet0", pruss_eth0_alias,
+			  strlen(pruss_eth0_alias) + 1);
+	if (ret < 0) {
+		printf("Could not change ethernet0 alias: %s\n",
+		       fdt_strerror(ret));
+		return ret;
+	}
+
+	ret = fdt_setprop(fdt, offs, "ethernet1", pruss_eth1_alias,
+			  strlen(pruss_eth0_alias) + 1);
+	if (ret < 0) {
+		printf("Could not change ethernet0 alias: %s\n",
+		       fdt_strerror(ret));
+		return ret;
+	}
+
+	return 0;
+
+no_node:
+	printf("Node %s not found. Please update DTB.\n", path);
+
+	/* Return 0 as we don't want to prevent booting with older DTBs */
+	return 0;
+
+disable_failed:
+	printf("Could not disable node %s: %s\n",
+	       path, fdt_strerror(ret));
+	return ret;
+
+enable_failed:
+	printf("Could not enable node %s: %s\n",
+	       path, fdt_strerror(ret));
+	return ret;
+}
+#endif
+
+#if defined(CONFIG_GENERIC_MMC)
+
+int board_mmc_init(bd_t *bis)
+{
+	int ret;
+	//we have only mmc1 as emmc, and it will be BOOT_DEVICE_MMC1
+	ret = omap_mmc_init(1, 0, 0, -1, -1);
+	printf("EMMC init %d\n", ret);
+	gd->arch.omap_boot_mode = MMCSD_MODE_FS;
+	return 0;
+}
+#endif
diff -uNr uboot-custom-orig/board/silicom/ubmc_eval/board_detect.c uboot-custom-silicom/board/silicom/ubmc_eval/board_detect.c
--- uboot-custom-orig/board/silicom/ubmc_eval/board_detect.c	1970-01-01 08:00:00.000000000 +0800
+++ uboot-custom-silicom/board/silicom/ubmc_eval/board_detect.c	2018-08-04 21:16:32.309348238 +0800
@@ -0,0 +1,395 @@
+/*
+ * Library to support early TI EVM EEPROM handling
+ *
+ * Copyright (C) 2015-2016 Texas Instruments Incorporated - http://www.ti.com/
+ *	Lokesh Vutla
+ *	Steve Kipisz
+ *
+ * SPDX-License-Identifier:    GPL-2.0+
+ */
+
+#include <common.h>
+#include <asm/omap_common.h>
+#include <i2c.h>
+
+#include "board_detect.h"
+
+/**
+ * ti_i2c_eeprom_init - Initialize an i2c bus and probe for a device
+ * @i2c_bus: i2c bus number to initialize
+ * @dev_addr: Device address to probe for
+ *
+ * Return: 0 on success or corresponding error on failure.
+ */
+static int __maybe_unused ti_i2c_eeprom_init(int i2c_bus, int dev_addr)
+{
+	int rc;
+
+	if (i2c_bus >= 0) {
+		rc = i2c_set_bus_num(i2c_bus);
+		if (rc)
+			return rc;
+	}
+
+	return i2c_probe(dev_addr);
+}
+
+/**
+ * ti_i2c_eeprom_read - Read data from an EEPROM
+ * @dev_addr: The device address of the EEPROM
+ * @offset: Offset to start reading in the EEPROM
+ * @ep: Pointer to a buffer to read into
+ * @epsize: Size of buffer
+ *
+ * Return: 0 on success or corresponding result of i2c_read
+ */
+static int __maybe_unused ti_i2c_eeprom_read(int dev_addr, int offset,
+					     uchar *ep, int epsize)
+{
+	return i2c_read(dev_addr, offset, 2, ep, epsize);
+}
+
+/**
+ * ti_eeprom_string_cleanup() - Handle eeprom programming errors
+ * @s:	eeprom string (should be NULL terminated)
+ *
+ * Some Board manufacturers do not add a NULL termination at the
+ * end of string, instead some binary information is kludged in, hence
+ * convert the string to just printable characters of ASCII chart.
+ */
+static void __maybe_unused ti_eeprom_string_cleanup(char *s)
+{
+	int i, l;
+
+	l = strlen(s);
+	for (i = 0; i < l; i++, s++)
+		if (*s < ' ' || *s > '~') {
+			*s = 0;
+			break;
+		}
+}
+
+__weak void gpi2c_init(void)
+{
+}
+
+static int __maybe_unused ti_i2c_eeprom_get(int bus_addr, int dev_addr,
+					    u32 header, u32 size, uint8_t *ep)
+{
+	u32 byte, hdr_read;
+	int rc;
+
+	gpi2c_init();
+	rc = ti_i2c_eeprom_init(bus_addr, dev_addr);
+	if (rc)
+		return rc;
+
+	/*
+	 * Read the header first then only read the other contents.
+	 */
+	byte = 2;
+	rc = i2c_read(dev_addr, 0x0, byte, (uint8_t *)&hdr_read, 4);
+	if (rc)
+		return rc;
+
+	/* Corrupted data??? */
+	if (hdr_read != header) {
+		rc = i2c_read(dev_addr, 0x0, byte, (uint8_t *)&hdr_read, 4);
+		/*
+		 * read the eeprom header using i2c again, but use only a
+		 * 1 byte address (some legacy boards need this..)
+		 */
+		byte = 1;
+		if (rc)
+			rc = i2c_read(dev_addr, 0x0, byte, (uint8_t *)&hdr_read,
+				      4);
+		if (rc)
+			return rc;
+	}
+	if (hdr_read != header)
+		return -1;
+
+	rc = i2c_read(dev_addr, 0x0, byte, ep, size);
+	if (rc)
+		return rc;
+
+	return 0;
+}
+
+int __maybe_unused ti_i2c_eeprom_am_set(const char *name, const char *rev)
+{
+	struct ti_common_eeprom *ep;
+
+	if (!name || !rev)
+		return -1;
+
+	ep = TI_EEPROM_DATA;
+	if (ep->header == TI_EEPROM_HEADER_MAGIC)
+		goto already_set;
+
+	/* Set to 0 all fields */
+	memset(ep, 0, sizeof(*ep));
+	strncpy(ep->name, name, TI_EEPROM_HDR_NAME_LEN);
+	strncpy(ep->version, rev, TI_EEPROM_HDR_REV_LEN);
+	/* Some dummy serial number to identify the platform */
+	strncpy(ep->serial, "0000", TI_EEPROM_HDR_SERIAL_LEN);
+	/* Mark it with a valid header */
+	ep->header = TI_EEPROM_HEADER_MAGIC;
+
+already_set:
+	return 0;
+}
+
+int __maybe_unused ti_i2c_eeprom_am_get(int bus_addr, int dev_addr)
+{
+	int rc;
+	struct ti_am_eeprom am_ep;
+	struct ti_common_eeprom *ep;
+
+	ep = TI_EEPROM_DATA;
+#ifndef CONFIG_SPL_BUILD
+	if (ep->header == TI_EEPROM_HEADER_MAGIC)
+		return 0; /* EEPROM has already been read */
+#endif
+
+	/* Initialize with a known bad marker for i2c fails.. */
+	ep->header = TI_DEAD_EEPROM_MAGIC;
+	ep->name[0] = 0x0;
+	ep->version[0] = 0x0;
+	ep->serial[0] = 0x0;
+	ep->config[0] = 0x0;
+
+	rc = ti_i2c_eeprom_get(bus_addr, dev_addr, TI_EEPROM_HEADER_MAGIC,
+			       sizeof(am_ep), (uint8_t *)&am_ep);
+	if (rc)
+		return rc;
+
+	ep->header = am_ep.header;
+	strlcpy(ep->name, am_ep.name, TI_EEPROM_HDR_NAME_LEN + 1);
+	ti_eeprom_string_cleanup(ep->name);
+
+	/* BeagleBone Green '1' eeprom, board_rev: 0x1a 0x00 0x00 0x00 */
+	if (am_ep.version[0] == 0x1a && am_ep.version[1] == 0x00 &&
+	    am_ep.version[2] == 0x00 && am_ep.version[3] == 0x00)
+		strlcpy(ep->version, "BBG1", TI_EEPROM_HDR_REV_LEN + 1);
+	else
+		strlcpy(ep->version, am_ep.version, TI_EEPROM_HDR_REV_LEN + 1);
+	ti_eeprom_string_cleanup(ep->version);
+	strlcpy(ep->serial, am_ep.serial, TI_EEPROM_HDR_SERIAL_LEN + 1);
+	ti_eeprom_string_cleanup(ep->serial);
+	strlcpy(ep->config, am_ep.config, TI_EEPROM_HDR_CONFIG_LEN + 1);
+	ti_eeprom_string_cleanup(ep->config);
+
+	memcpy(ep->mac_addr, am_ep.mac_addr,
+	       TI_EEPROM_HDR_NO_OF_MAC_ADDR * TI_EEPROM_HDR_ETH_ALEN);
+
+	return 0;
+}
+
+int __maybe_unused ti_i2c_eeprom_dra7_get(int bus_addr, int dev_addr)
+{
+	int rc, offset = 0;
+	struct dra7_eeprom dra7_ep;
+	struct ti_common_eeprom *ep;
+
+	ep = TI_EEPROM_DATA;
+#ifndef CONFIG_SPL_BUILD
+	if (ep->header == DRA7_EEPROM_HEADER_MAGIC)
+		return 0; /* EEPROM has already been read */
+#endif
+
+	/* Initialize with a known bad marker for i2c fails.. */
+	ep->header = TI_DEAD_EEPROM_MAGIC;
+	ep->name[0] = 0x0;
+	ep->version[0] = 0x0;
+	ep->serial[0] = 0x0;
+	ep->config[0] = 0x0;
+	ep->emif1_size = 0;
+	ep->emif2_size = 0;
+
+	rc = ti_i2c_eeprom_get(bus_addr, dev_addr, DRA7_EEPROM_HEADER_MAGIC,
+			       sizeof(dra7_ep), (uint8_t *)&dra7_ep);
+	if (rc)
+		return rc;
+
+	ep->header = dra7_ep.header;
+	strlcpy(ep->name, dra7_ep.name, TI_EEPROM_HDR_NAME_LEN + 1);
+	ti_eeprom_string_cleanup(ep->name);
+
+	offset = dra7_ep.version_major - 1;
+
+	/* Rev F is skipped */
+	if (offset >= 5)
+		offset = offset + 1;
+	snprintf(ep->version, TI_EEPROM_HDR_REV_LEN + 1, "%c.%d",
+		 'A' + offset, dra7_ep.version_minor);
+	ti_eeprom_string_cleanup(ep->version);
+	ep->emif1_size = (u64)dra7_ep.emif1_size;
+	ep->emif2_size = (u64)dra7_ep.emif2_size;
+	strlcpy(ep->config, dra7_ep.config, TI_EEPROM_HDR_CONFIG_LEN + 1);
+	ti_eeprom_string_cleanup(ep->config);
+
+	return 0;
+}
+
+bool __maybe_unused board_ti_is(char *name_tag)
+{
+	struct ti_common_eeprom *ep = TI_EEPROM_DATA;
+
+	if (ep->header == TI_DEAD_EEPROM_MAGIC)
+		return false;
+	return !strncmp(ep->name, name_tag, TI_EEPROM_HDR_NAME_LEN);
+}
+
+bool __maybe_unused board_ti_rev_is(char *rev_tag, int cmp_len)
+{
+	struct ti_common_eeprom *ep = TI_EEPROM_DATA;
+	int l;
+
+	if (ep->header == TI_DEAD_EEPROM_MAGIC)
+		return false;
+
+	l = cmp_len > TI_EEPROM_HDR_REV_LEN ? TI_EEPROM_HDR_REV_LEN : cmp_len;
+	return !strncmp(ep->version, rev_tag, l);
+}
+
+char * __maybe_unused board_ti_get_rev(void)
+{
+	struct ti_common_eeprom *ep = TI_EEPROM_DATA;
+
+	/* if ep->header == TI_DEAD_EEPROM_MAGIC, this is empty already */
+	return ep->version;
+}
+
+char * __maybe_unused board_ti_get_config(void)
+{
+	struct ti_common_eeprom *ep = TI_EEPROM_DATA;
+
+	/* if ep->header == TI_DEAD_EEPROM_MAGIC, this is empty already */
+	return ep->config;
+}
+
+char * __maybe_unused board_ti_get_name(void)
+{
+	struct ti_common_eeprom *ep = TI_EEPROM_DATA;
+
+	/* if ep->header == TI_DEAD_EEPROM_MAGIC, this is empty already */
+	return ep->name;
+}
+
+void __maybe_unused
+board_ti_get_eth_mac_addr(int index,
+			  u8 mac_addr[TI_EEPROM_HDR_ETH_ALEN])
+{
+	struct ti_common_eeprom *ep = TI_EEPROM_DATA;
+
+	if (ep->header == TI_DEAD_EEPROM_MAGIC)
+		goto fail;
+
+	if (index < 0 || index >= TI_EEPROM_HDR_NO_OF_MAC_ADDR)
+		goto fail;
+
+	memcpy(mac_addr, ep->mac_addr[index], TI_EEPROM_HDR_ETH_ALEN);
+	return;
+
+fail:
+	memset(mac_addr, 0, TI_EEPROM_HDR_ETH_ALEN);
+}
+
+u64 __maybe_unused board_ti_get_emif1_size(void)
+{
+	struct ti_common_eeprom *ep = TI_EEPROM_DATA;
+
+	if (ep->header != DRA7_EEPROM_HEADER_MAGIC)
+		return 0;
+
+	return ep->emif1_size;
+}
+
+u64 __maybe_unused board_ti_get_emif2_size(void)
+{
+	struct ti_common_eeprom *ep = TI_EEPROM_DATA;
+
+	if (ep->header != DRA7_EEPROM_HEADER_MAGIC)
+		return 0;
+
+	return ep->emif2_size;
+}
+
+void __maybe_unused set_board_info_env(char *name)
+{
+	char *unknown = "unknown";
+	struct ti_common_eeprom *ep = TI_EEPROM_DATA;
+
+	setenv("board_name", "ubmc_eval");
+	setenv("board_rev", "0.9");
+	setenv("board_serial", "XXXX-XXXXX");
+
+}
+
+static u64 mac_to_u64(u8 mac[6])
+{
+	int i;
+	u64 addr = 0;
+
+	for (i = 0; i < 6; i++) {
+		addr <<= 8;
+		addr |= mac[i];
+	}
+
+	return addr;
+}
+
+static void u64_to_mac(u64 addr, u8 mac[6])
+{
+	mac[5] = addr;
+	mac[4] = addr >> 8;
+	mac[3] = addr >> 16;
+	mac[2] = addr >> 24;
+	mac[1] = addr >> 32;
+	mac[0] = addr >> 40;
+}
+
+void board_ti_set_ethaddr(int index)
+{
+	uint8_t mac_addr[6];
+	int i;
+	u64 mac1, mac2;
+	u8 mac_addr1[6], mac_addr2[6];
+	int num_macs;
+	/*
+	 * Export any Ethernet MAC addresses from EEPROM.
+	 * The 2 MAC addresses in EEPROM define the address range.
+	 */
+	board_ti_get_eth_mac_addr(0, mac_addr1);
+	board_ti_get_eth_mac_addr(1, mac_addr2);
+
+	if (is_valid_ethaddr(mac_addr1) && is_valid_ethaddr(mac_addr2)) {
+		mac1 = mac_to_u64(mac_addr1);
+		mac2 = mac_to_u64(mac_addr2);
+
+		/* must contain an address range */
+		num_macs = mac2 - mac1 + 1;
+		/* <= 50 to protect against user programming error */
+		if (num_macs > 0 && num_macs <= 50) {
+			for (i = 0; i < num_macs; i++) {
+				u64_to_mac(mac1 + i, mac_addr);
+				if (is_valid_ethaddr(mac_addr)) {
+					eth_setenv_enetaddr_by_index("eth",
+								     i + index,
+								     mac_addr);
+				}
+			}
+		}
+	}
+}
+
+bool __maybe_unused board_ti_was_eeprom_read(void)
+{
+	struct ti_common_eeprom *ep = TI_EEPROM_DATA;
+
+	if (ep->header == TI_EEPROM_HEADER_MAGIC)
+		return true;
+	else
+		return false;
+}
diff -uNr uboot-custom-orig/board/silicom/ubmc_eval/board_detect.h uboot-custom-silicom/board/silicom/ubmc_eval/board_detect.h
--- uboot-custom-orig/board/silicom/ubmc_eval/board_detect.h	1970-01-01 08:00:00.000000000 +0800
+++ uboot-custom-silicom/board/silicom/ubmc_eval/board_detect.h	2018-08-04 21:16:32.310348228 +0800
@@ -0,0 +1,234 @@
+/*
+ * Library to support early TI EVM EEPROM handling
+ *
+ * Copyright (C) 2015-2016 Texas Instruments Incorporated - http://www.ti.com
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __BOARD_DETECT_H
+#define __BOARD_DETECT_H
+
+/* TI EEPROM MAGIC Header identifier */
+#define TI_EEPROM_HEADER_MAGIC	0xEE3355AA
+#define TI_DEAD_EEPROM_MAGIC	0xADEAD12C
+
+#define TI_EEPROM_HDR_NAME_LEN		8
+#define TI_EEPROM_HDR_REV_LEN		4
+#define TI_EEPROM_HDR_SERIAL_LEN	12
+#define TI_EEPROM_HDR_CONFIG_LEN	32
+#define TI_EEPROM_HDR_NO_OF_MAC_ADDR	3
+#define TI_EEPROM_HDR_ETH_ALEN		6
+
+/**
+ * struct ti_am_eeprom - This structure holds data read in from the
+ *                     AM335x, AM437x, AM57xx TI EVM EEPROMs.
+ * @header: This holds the magic number
+ * @name: The name of the board
+ * @version: Board revision
+ * @serial: Board serial number
+ * @config: Reserved
+ * @mac_addr: Any MAC addresses written in the EEPROM
+ *
+ * The data is this structure is read from the EEPROM on the board.
+ * It is used for board detection which is based on name. It is used
+ * to configure specific TI boards. This allows booting of multiple
+ * TI boards with a single MLO and u-boot.
+ */
+struct ti_am_eeprom {
+	unsigned int header;
+	char name[TI_EEPROM_HDR_NAME_LEN];
+	char version[TI_EEPROM_HDR_REV_LEN];
+	char serial[TI_EEPROM_HDR_SERIAL_LEN];
+	char config[TI_EEPROM_HDR_CONFIG_LEN];
+	char mac_addr[TI_EEPROM_HDR_NO_OF_MAC_ADDR][TI_EEPROM_HDR_ETH_ALEN];
+} __attribute__ ((__packed__));
+
+/* DRA7 EEPROM MAGIC Header identifier */
+#define DRA7_EEPROM_HEADER_MAGIC	0xAA5533EE
+#define DRA7_EEPROM_HDR_NAME_LEN	16
+#define DRA7_EEPROM_HDR_CONFIG_LEN	4
+
+/**
+ * struct dra7_eeprom - This structure holds data read in from the DRA7 EVM
+ *			EEPROMs.
+ * @header: This holds the magic number
+ * @name: The name of the board
+ * @version_major: Board major version
+ * @version_minor: Board minor version
+ * @config: Board specific config options
+ * @emif1_size: Size of DDR attached to EMIF1
+ * @emif2_size: Size of DDR attached to EMIF2
+ *
+ * The data is this structure is read from the EEPROM on the board.
+ * It is used for board detection which is based on name. It is used
+ * to configure specific DRA7 boards. This allows booting of multiple
+ * DRA7 boards with a single MLO and u-boot.
+ */
+struct dra7_eeprom {
+	u32 header;
+	char name[DRA7_EEPROM_HDR_NAME_LEN];
+	u16 version_major;
+	u16 version_minor;
+	char config[DRA7_EEPROM_HDR_CONFIG_LEN];
+	u32 emif1_size;
+	u32 emif2_size;
+} __attribute__ ((__packed__));
+
+/**
+ * struct ti_common_eeprom - Null terminated, usable EEPROM contents.
+ * header:	Magic number
+ * @name:	NULL terminated name
+ * @version:	NULL terminated version
+ * @serial:	NULL terminated serial number
+ * @config:	NULL terminated Board specific config options
+ * @mac_addr:	MAC addresses
+ * @emif1_size:	Size of the ddr available on emif1
+ * @emif2_size:	Size of the ddr available on emif2
+ */
+struct ti_common_eeprom {
+	u32 header;
+	char name[TI_EEPROM_HDR_NAME_LEN + 1];
+	char version[TI_EEPROM_HDR_REV_LEN + 1];
+	char serial[TI_EEPROM_HDR_SERIAL_LEN + 1];
+	char config[TI_EEPROM_HDR_CONFIG_LEN + 1];
+	char mac_addr[TI_EEPROM_HDR_NO_OF_MAC_ADDR][TI_EEPROM_HDR_ETH_ALEN];
+	u64 emif1_size;
+	u64 emif2_size;
+};
+
+#define TI_EEPROM_DATA ((struct ti_common_eeprom *)\
+				TI_SRAM_SCRATCH_BOARD_EEPROM_START)
+
+/**
+ * ti_i2c_eeprom_am_get() - Consolidated eeprom data collection for AM* TI EVMs
+ * @bus_addr:	I2C bus address
+ * @dev_addr:	I2C slave address
+ *
+ * ep in SRAM is populated by the this AM generic function that consolidates
+ * the basic initialization logic common across all AM* platforms.
+ */
+int ti_i2c_eeprom_am_get(int bus_addr, int dev_addr);
+
+/**
+ * ti_i2c_eeprom_dra7_get() - Consolidated eeprom data for DRA7 TI EVMs
+ * @bus_addr:	I2C bus address
+ * @dev_addr:	I2C slave address
+ */
+int ti_i2c_eeprom_dra7_get(int bus_addr, int dev_addr);
+
+/**
+ * board_ti_is() - Board detection logic for TI EVMs
+ * @name_tag:	Tag used in eeprom for the board
+ *
+ * Return: false if board information does not match OR eeprom wasn't read.
+ *	   true otherwise
+ */
+bool board_ti_is(char *name_tag);
+
+/**
+ * board_ti_rev_is() - Compare board revision for TI EVMs
+ * @rev_tag:	Revision tag to check in eeprom
+ * @cmp_len:	How many chars to compare?
+ *
+ * NOTE: revision information is often messed up (hence the str len match) :(
+ *
+ * Return: false if board information does not match OR eeprom wasn't read.
+ *	   true otherwise
+ */
+bool board_ti_rev_is(char *rev_tag, int cmp_len);
+
+/**
+ * board_ti_get_rev() - Get board revision for TI EVMs
+ *
+ * Return: Empty string if eeprom wasn't read.
+ *	   Board revision otherwise
+ */
+char *board_ti_get_rev(void);
+
+/**
+ * board_ti_get_config() - Get board config for TI EVMs
+ *
+ * Return: Empty string if eeprom wasn't read.
+ *	   Board config otherwise
+ */
+char *board_ti_get_config(void);
+
+/**
+ * board_ti_get_name() - Get board name for TI EVMs
+ *
+ * Return: Empty string if eeprom wasn't read.
+ *	   Board name otherwise
+ */
+char *board_ti_get_name(void);
+
+/**
+ * board_ti_get_eth_mac_addr() - Get Ethernet MAC address from EEPROM MAC list
+ * @index:	0 based index within the list of MAC addresses
+ * @mac_addr:	MAC address contained at the index is returned here
+ *
+ * Does not sanity check the mac_addr. Whatever is stored in EEPROM is returned.
+ */
+void board_ti_get_eth_mac_addr(int index, u8 mac_addr[TI_EEPROM_HDR_ETH_ALEN]);
+
+/**
+ * board_ti_get_emif1_size() - Get size of the DDR on emif1 for TI EVMs
+ *
+ * Return: NULL if eeprom wasn't read or emif1_size is not available.
+ */
+u64 board_ti_get_emif1_size(void);
+
+/**
+ * board_ti_get_emif2_size() - Get size of the DDR on emif2 for TI EVMs
+ *
+ * Return: NULL if eeprom wasn't read or emif2_size is not available.
+ */
+u64 board_ti_get_emif2_size(void);
+
+/**
+ * set_board_info_env() - Setup commonly used board information environment vars
+ * @name:	Name of the board
+ *
+ * If name is NULL, default_name is used.
+ */
+void set_board_info_env(char *name);
+
+/**
+ * board_ti_was_eeprom_read() - Check to see if the eeprom contents have been read
+ *
+ * This function is useful to determine if the eeprom has already been read and
+ * its contents have already been loaded into memory. It utiltzes the magic
+ * number that the header value is set to upon successful eeprom read.
+ */
+bool board_ti_was_eeprom_read(void);
+
+/**
+ * ti_i2c_eeprom_am_set() - Setup the eeprom data with predefined values
+ * @name:	Name of the board
+ * @rev:	Revision of the board
+ *
+ * In some cases such as in RTC-only mode, we are able to skip reading eeprom
+ * and wasting i2c based initialization time by using predefined flags for
+ * detecting what platform we are booting on. For those platforms, provide
+ * a handy function to pre-program information.
+ *
+ * NOTE: many eeprom information such as serial number, mac address etc is not
+ * available.
+ *
+ * Return: 0 if all went fine, else return error.
+ */
+int ti_i2c_eeprom_am_set(const char *name, const char *rev);
+
+/**
+ * board_ti_set_ethaddr- Sets the ethaddr environment from EEPROM
+ * @index: The first eth<index>addr environment variable to set
+ *
+ * EEPROM should be already read before calling this function.
+ * The EEPROM contains 2 MAC addresses which define the MAC address
+ * range (i.e. first and last MAC address).
+ * This function sets the ethaddr environment variable for all
+ * the available MAC addresses starting from eth<index>addr.
+ */
+void board_ti_set_ethaddr(int index);
+
+#endif	/* __BOARD_DETECT_H */
diff -uNr uboot-custom-orig/board/silicom/ubmc_eval/board.h uboot-custom-silicom/board/silicom/ubmc_eval/board.h
--- uboot-custom-orig/board/silicom/ubmc_eval/board.h	1970-01-01 08:00:00.000000000 +0800
+++ uboot-custom-silicom/board/silicom/ubmc_eval/board.h	2018-08-04 21:16:32.310348228 +0800
@@ -0,0 +1,89 @@
+/*
+ * board.h
+ *
+ * TI AM335x boards information header
+ *
+ * Copyright (C) 2011, Texas Instruments, Incorporated - http://www.ti.com/
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef _BOARD_H_
+#define _BOARD_H_
+
+/**
+ * AM335X (EMIF_4D) EMIF REG_COS_COUNT_1, REG_COS_COUNT_2, and
+ * REG_PR_OLD_COUNT values to avoid LCDC DMA FIFO underflows and Frame
+ * Synchronization Lost errors. The values are the biggest that work
+ * reliably with offered video modes and the memory subsystem on the
+ * boards. These register have are briefly documented in "7.3.3.5.2
+ * Command Starvation" section of AM335x TRM. The REG_COS_COUNT_1 and
+ * REG_COS_COUNT_2 do not have any effect on current versions of
+ * AM335x.
+ */
+#define EMIF_OCP_CONFIG_BEAGLEBONE_BLACK       0x00141414
+#define EMIF_OCP_CONFIG_AM335X_EVM             0x003d3d3d
+
+#ifdef NO_SILC_MOD
+static inline int board_is_bone(void)
+{
+	return board_ti_is("A335BONE");
+}
+
+static inline int board_is_bone_lt(void)
+{
+	return board_ti_is("A335BNLT");
+}
+
+static inline int board_is_bbg1(void)
+{
+	return board_is_bone_lt() && !strncmp(board_ti_get_rev(), "BBG1", 4);
+}
+
+static inline int board_is_beaglebonex(void)
+{
+	return board_is_bone() || board_is_bone_lt() || board_is_bbg1();
+}
+
+static inline int board_is_evm_sk(void)
+{
+	return board_ti_is("A335X_SK");
+}
+
+static inline int board_is_idk(void)
+{
+	return !strncmp(board_ti_get_config(), "SKU#02", 6);
+}
+
+static inline int board_is_gp_evm(void)
+{
+	return board_ti_is("A33515BB");
+}
+
+static inline int board_is_evm_15_or_later(void)
+{
+	return (board_is_gp_evm() &&
+		strncmp("1.5", board_ti_get_rev(), 3) <= 0);
+}
+
+static inline int board_is_icev2(void)
+{
+	return board_ti_is("A335_ICE") && !strncmp("2", board_ti_get_rev(), 1);
+}
+#endif
+
+/*
+ * We have three pin mux functions that must exist.  We must be able to enable
+ * uart0, for initial output and i2c0 to read the main EEPROM.  We then have a
+ * main pinmux function that can be overridden to enable all other pinmux that
+ * is required on the board.
+ */
+void enable_uart0_pin_mux(void);
+void enable_uart1_pin_mux(void);
+void enable_uart2_pin_mux(void);
+void enable_uart3_pin_mux(void);
+void enable_uart4_pin_mux(void);
+void enable_uart5_pin_mux(void);
+void enable_i2c0_pin_mux(void);
+void enable_board_pin_mux(void);
+#endif
diff -uNr uboot-custom-orig/board/silicom/ubmc_eval/Kconfig uboot-custom-silicom/board/silicom/ubmc_eval/Kconfig
--- uboot-custom-orig/board/silicom/ubmc_eval/Kconfig	1970-01-01 08:00:00.000000000 +0800
+++ uboot-custom-silicom/board/silicom/ubmc_eval/Kconfig	2018-08-04 21:16:32.310348228 +0800
@@ -0,0 +1,41 @@
+if TARGET_UBMC_EVAL
+
+config SYS_BOARD
+	default "ubmc_eval"
+
+config SYS_VENDOR
+	default "silicom"
+
+config SYS_SOC
+	default "am33xx"
+
+config SYS_CONFIG_NAME
+	default "ubmc_eval"
+
+config CONS_INDEX
+	int "UART used for console"
+	range 1 6
+	default 1
+	help
+	  The AM335x SoC has a total of 6 UARTs (UART0 to UART5 as referenced
+	  in documentation, etc) available to it.  Depending on your specific
+	  board you may want something other than UART0 as for example the IDK
+	  uses UART3 so enter 4 here.
+
+config UMBC_SD_UBOOT
+	bool "Select to enable uboot build for sd card booting"
+	help
+		Select this, would cause the SPL MLO to load uboot from sdcard.
+		Also enables auto loading of dtb/zimage/rootfs from sd card
+		if not selected, then default autobooting from emmc with upgrade support
+
+config UBMC_UBOOT_ETH_INDX
+	int "uboot ethnet default out port"
+	range 1 2
+	default 2
+	help 
+		Note that, this does not select eth0 or eth1, uboot for cpsw only have eth0
+		select which port to use for uboot ethernet traffic in the cpsw driver.
+		Default to 2, as ubmc_eval uses the second port for back panel port
+
+endif
diff -uNr uboot-custom-orig/board/silicom/ubmc_eval/MAINTAINERS uboot-custom-silicom/board/silicom/ubmc_eval/MAINTAINERS
--- uboot-custom-orig/board/silicom/ubmc_eval/MAINTAINERS	1970-01-01 08:00:00.000000000 +0800
+++ uboot-custom-silicom/board/silicom/ubmc_eval/MAINTAINERS	2018-08-04 21:16:32.310348228 +0800
@@ -0,0 +1,13 @@
+BAV335x BOARD
+M:	Gilles Gameiro <gilles@gigadevices.com>
+S:	Maintained
+F:	include/configs/bav335x.h
+F:	board/birdland/bav335x/Kconfig
+F:	board/birdland/bav335x/Makefile
+F:	board/birdland/bav335x/README
+F:	board/birdland/bav335x/board.c
+F:	board/birdland/bav335x/board.h
+F:	board/birdland/bav335x/mux.c
+F:	board/birdland/bav335x/u-boot.lds
+F:	configs/birdland_bav335a_defconfig
+F:	configs/birdland_bav335b_defconfig
diff -uNr uboot-custom-orig/board/silicom/ubmc_eval/Makefile uboot-custom-silicom/board/silicom/ubmc_eval/Makefile
--- uboot-custom-orig/board/silicom/ubmc_eval/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ uboot-custom-silicom/board/silicom/ubmc_eval/Makefile	2018-08-04 21:16:32.310348228 +0800
@@ -0,0 +1,13 @@
+#
+# Makefile
+#
+# Copyright (C) 2012-2014, Birdland Audio - http://birdland.com/oem
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+ifeq ($(CONFIG_SKIP_LOWLEVEL_INIT),)
+obj-y	:= mux.o
+endif
+
+obj-y	+= board.o
diff -uNr uboot-custom-orig/board/silicom/ubmc_eval/mux.c uboot-custom-silicom/board/silicom/ubmc_eval/mux.c
--- uboot-custom-orig/board/silicom/ubmc_eval/mux.c	1970-01-01 08:00:00.000000000 +0800
+++ uboot-custom-silicom/board/silicom/ubmc_eval/mux.c	2018-08-04 21:16:32.310348228 +0800
@@ -0,0 +1,627 @@
+/*
+ * mux.c
+ *
+ * Copyright (C) 2011 Texas Instruments Incorporated - http://www.ti.com/
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation version 2.
+ *
+ * This program is distributed "as is" WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ */
+
+#include <common.h>
+#include <asm/arch/sys_proto.h>
+#include <asm/arch/hardware.h>
+#include <asm/arch/mux.h>
+#include <asm/io.h>
+#include <i2c.h>
+#include "board_detect.h"
+#include "board.h"
+#ifndef NO_SILC_UBMC
+//#include "vecpe_bmc_pinmux.h"
+#define RXDISABLE	(0x0 << 5)
+#define MUX_CFG_SILC(a,b)	MUX_CFG((b), (a))
+#endif
+#if 0
+static struct module_pin_mux uart0_pin_mux[] = {
+	{OFFSET(uart0_rxd), (MODE(0) | PULLUP_EN | RXACTIVE)},	/* UART0_RXD */
+	{OFFSET(uart0_txd), (MODE(0) | PULLUDEN)},		/* UART0_TXD */
+	{-1},
+};
+
+static struct module_pin_mux uart1_pin_mux[] = {
+	{OFFSET(uart1_rxd), (MODE(0) | PULLUP_EN | RXACTIVE)},	/* UART1_RXD */
+	{OFFSET(uart1_txd), (MODE(0) | PULLUDEN)},		/* UART1_TXD */
+	{-1},
+};
+
+static struct module_pin_mux uart2_pin_mux[] = {
+	{OFFSET(spi0_sclk), (MODE(1) | PULLUP_EN | RXACTIVE)},	/* UART2_RXD */
+	{OFFSET(spi0_d0), (MODE(1) | PULLUDEN)},		/* UART2_TXD */
+	{-1},
+};
+
+static struct module_pin_mux uart3_pin_mux[] = {
+	{OFFSET(spi0_cs1), (MODE(1) | PULLUP_EN | RXACTIVE)},	/* UART3_RXD */
+	{OFFSET(ecap0_in_pwm0_out), (MODE(1) | PULLUDEN)},	/* UART3_TXD */
+	{-1},
+};
+
+static struct module_pin_mux uart4_pin_mux[] = {
+	{OFFSET(gpmc_wait0), (MODE(6) | PULLUP_EN | RXACTIVE)},	/* UART4_RXD */
+	{OFFSET(gpmc_wpn), (MODE(6) | PULLUDEN)},		/* UART4_TXD */
+	{-1},
+};
+
+static struct module_pin_mux uart5_pin_mux[] = {
+	{OFFSET(lcd_data9), (MODE(4) | PULLUP_EN | RXACTIVE)},	/* UART5_RXD */
+	{OFFSET(lcd_data8), (MODE(4) | PULLUDEN)},		/* UART5_TXD */
+	{-1},
+};
+
+static struct module_pin_mux mmc0_pin_mux[] = {
+	{OFFSET(mmc0_dat3), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_DAT3 */
+	{OFFSET(mmc0_dat2), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_DAT2 */
+	{OFFSET(mmc0_dat1), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_DAT1 */
+	{OFFSET(mmc0_dat0), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_DAT0 */
+	{OFFSET(mmc0_clk), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_CLK */
+	{OFFSET(mmc0_cmd), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_CMD */
+	{OFFSET(mcasp0_aclkr), (MODE(4) | RXACTIVE)},		/* MMC0_WP */
+	{OFFSET(spi0_cs1), (MODE(7) | RXACTIVE | PULLUP_EN)},	/* GPIO0_6 */
+	{-1},
+};
+
+static struct module_pin_mux mmc0_no_cd_pin_mux[] = {
+	{OFFSET(mmc0_dat3), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_DAT3 */
+	{OFFSET(mmc0_dat2), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_DAT2 */
+	{OFFSET(mmc0_dat1), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_DAT1 */
+	{OFFSET(mmc0_dat0), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_DAT0 */
+	{OFFSET(mmc0_clk), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_CLK */
+	{OFFSET(mmc0_cmd), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_CMD */
+	{OFFSET(mcasp0_aclkr), (MODE(4) | RXACTIVE)},		/* MMC0_WP */
+	{-1},
+};
+
+static struct module_pin_mux mmc0_pin_mux_sk_evm[] = {
+	{OFFSET(mmc0_dat3), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_DAT3 */
+	{OFFSET(mmc0_dat2), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_DAT2 */
+	{OFFSET(mmc0_dat1), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_DAT1 */
+	{OFFSET(mmc0_dat0), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_DAT0 */
+	{OFFSET(mmc0_clk), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_CLK */
+	{OFFSET(mmc0_cmd), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_CMD */
+	{OFFSET(spi0_cs1), (MODE(5) | RXACTIVE | PULLUP_EN)},	/* MMC0_CD */
+	{-1},
+};
+
+static struct module_pin_mux mmc1_pin_mux[] = {
+	{OFFSET(gpmc_ad3), (MODE(1) | RXACTIVE | PULLUP_EN)},	/* MMC1_DAT3 */
+	{OFFSET(gpmc_ad2), (MODE(1) | RXACTIVE | PULLUP_EN)},	/* MMC1_DAT2 */
+	{OFFSET(gpmc_ad1), (MODE(1) | RXACTIVE | PULLUP_EN)},	/* MMC1_DAT1 */
+	{OFFSET(gpmc_ad0), (MODE(1) | RXACTIVE | PULLUP_EN)},	/* MMC1_DAT0 */
+	{OFFSET(gpmc_csn1), (MODE(2) | RXACTIVE | PULLUP_EN)},	/* MMC1_CLK */
+	{OFFSET(gpmc_csn2), (MODE(2) | RXACTIVE | PULLUP_EN)},	/* MMC1_CMD */
+	{OFFSET(gpmc_csn0), (MODE(7) | RXACTIVE | PULLUP_EN)},	/* MMC1_WP */
+	{OFFSET(gpmc_advn_ale), (MODE(7) | RXACTIVE | PULLUP_EN)},	/* MMC1_CD */
+	{-1},
+};
+
+static struct module_pin_mux i2c0_pin_mux[] = {
+	{OFFSET(i2c0_sda), (MODE(0) | RXACTIVE |
+			PULLUDEN | SLEWCTRL)}, /* I2C_DATA */
+	{OFFSET(i2c0_scl), (MODE(0) | RXACTIVE |
+			PULLUDEN | SLEWCTRL)}, /* I2C_SCLK */
+	{-1},
+};
+
+static struct module_pin_mux i2c1_pin_mux[] = {
+	{OFFSET(spi0_d1), (MODE(2) | RXACTIVE |
+			PULLUDEN | SLEWCTRL)},	/* I2C_DATA */
+	{OFFSET(spi0_cs0), (MODE(2) | RXACTIVE |
+			PULLUDEN | SLEWCTRL)},	/* I2C_SCLK */
+	{-1},
+};
+
+static struct module_pin_mux spi0_pin_mux[] = {
+	{OFFSET(spi0_sclk), (MODE(0) | RXACTIVE | PULLUDEN)},	/* SPI0_SCLK */
+	{OFFSET(spi0_d0), (MODE(0) | RXACTIVE |
+			PULLUDEN | PULLUP_EN)},			/* SPI0_D0 */
+	{OFFSET(spi0_d1), (MODE(0) | RXACTIVE | PULLUDEN)},	/* SPI0_D1 */
+	{OFFSET(spi0_cs0), (MODE(0) | RXACTIVE |
+			PULLUDEN | PULLUP_EN)},			/* SPI0_CS0 */
+	{-1},
+};
+
+static struct module_pin_mux gpio0_7_pin_mux[] = {
+	{OFFSET(ecap0_in_pwm0_out), (MODE(7) | PULLUDEN)},	/* GPIO0_7 */
+	{-1},
+};
+
+static struct module_pin_mux gpio0_18_pin_mux[] = {
+	{OFFSET(usb0_drvvbus), (MODE(7) | PULLUDEN)},	/* GPIO0_18 */
+	{-1},
+};
+
+static struct module_pin_mux rgmii1_pin_mux[] = {
+	{OFFSET(mii1_txen), MODE(2)},			/* RGMII1_TCTL */
+	{OFFSET(mii1_rxdv), MODE(2) | RXACTIVE},	/* RGMII1_RCTL */
+	{OFFSET(mii1_txd3), MODE(2)},			/* RGMII1_TD3 */
+	{OFFSET(mii1_txd2), MODE(2)},			/* RGMII1_TD2 */
+	{OFFSET(mii1_txd1), MODE(2)},			/* RGMII1_TD1 */
+	{OFFSET(mii1_txd0), MODE(2)},			/* RGMII1_TD0 */
+	{OFFSET(mii1_txclk), MODE(2)},			/* RGMII1_TCLK */
+	{OFFSET(mii1_rxclk), MODE(2) | RXACTIVE},	/* RGMII1_RCLK */
+	{OFFSET(mii1_rxd3), MODE(2) | RXACTIVE},	/* RGMII1_RD3 */
+	{OFFSET(mii1_rxd2), MODE(2) | RXACTIVE},	/* RGMII1_RD2 */
+	{OFFSET(mii1_rxd1), MODE(2) | RXACTIVE},	/* RGMII1_RD1 */
+	{OFFSET(mii1_rxd0), MODE(2) | RXACTIVE},	/* RGMII1_RD0 */
+	{OFFSET(mdio_data), MODE(0) | RXACTIVE | PULLUP_EN},/* MDIO_DATA */
+	{OFFSET(mdio_clk), MODE(0) | PULLUP_EN},	/* MDIO_CLK */
+	{-1},
+};
+
+static struct module_pin_mux mii1_pin_mux[] = {
+	{OFFSET(mii1_rxerr), MODE(0) | RXACTIVE},	/* MII1_RXERR */
+	{OFFSET(mii1_txen), MODE(0)},			/* MII1_TXEN */
+	{OFFSET(mii1_rxdv), MODE(0) | RXACTIVE},	/* MII1_RXDV */
+	{OFFSET(mii1_txd3), MODE(0)},			/* MII1_TXD3 */
+	{OFFSET(mii1_txd2), MODE(0)},			/* MII1_TXD2 */
+	{OFFSET(mii1_txd1), MODE(0)},			/* MII1_TXD1 */
+	{OFFSET(mii1_txd0), MODE(0)},			/* MII1_TXD0 */
+	{OFFSET(mii1_txclk), MODE(0) | RXACTIVE},	/* MII1_TXCLK */
+	{OFFSET(mii1_rxclk), MODE(0) | RXACTIVE},	/* MII1_RXCLK */
+	{OFFSET(mii1_rxd3), MODE(0) | RXACTIVE},	/* MII1_RXD3 */
+	{OFFSET(mii1_rxd2), MODE(0) | RXACTIVE},	/* MII1_RXD2 */
+	{OFFSET(mii1_rxd1), MODE(0) | RXACTIVE},	/* MII1_RXD1 */
+	{OFFSET(mii1_rxd0), MODE(0) | RXACTIVE},	/* MII1_RXD0 */
+	{OFFSET(mdio_data), MODE(0) | RXACTIVE | PULLUP_EN}, /* MDIO_DATA */
+	{OFFSET(mdio_clk), MODE(0) | PULLUP_EN},	/* MDIO_CLK */
+	{-1},
+};
+
+static struct module_pin_mux rmii1_pin_mux[] = {
+	{OFFSET(mdio_clk), MODE(0) | PULLUP_EN},	/* MDIO_CLK */
+	{OFFSET(mdio_data), MODE(0) | RXACTIVE | PULLUP_EN}, /* MDIO_DATA */
+	{OFFSET(mii1_crs), MODE(1) | RXACTIVE},		/* MII1_CRS */
+	{OFFSET(mii1_rxerr), MODE(1) | RXACTIVE},	/* MII1_RXERR */
+	{OFFSET(mii1_txen), MODE(1)},			/* MII1_TXEN */
+	{OFFSET(mii1_txd1), MODE(1)},			/* MII1_TXD1 */
+	{OFFSET(mii1_txd0), MODE(1)},			/* MII1_TXD0 */
+	{OFFSET(mii1_rxd1), MODE(1) | RXACTIVE},	/* MII1_RXD1 */
+	{OFFSET(mii1_rxd0), MODE(1) | RXACTIVE},	/* MII1_RXD0 */
+	{OFFSET(rmii1_refclk), MODE(0) | RXACTIVE},	/* RMII1_REFCLK */
+	{-1},
+};
+
+#ifdef CONFIG_NAND
+static struct module_pin_mux nand_pin_mux[] = {
+	{OFFSET(gpmc_ad0),	(MODE(0) | PULLUDDIS | RXACTIVE)}, /* AD0  */
+	{OFFSET(gpmc_ad1),	(MODE(0) | PULLUDDIS | RXACTIVE)}, /* AD1  */
+	{OFFSET(gpmc_ad2),	(MODE(0) | PULLUDDIS | RXACTIVE)}, /* AD2  */
+	{OFFSET(gpmc_ad3),	(MODE(0) | PULLUDDIS | RXACTIVE)}, /* AD3  */
+	{OFFSET(gpmc_ad4),	(MODE(0) | PULLUDDIS | RXACTIVE)}, /* AD4  */
+	{OFFSET(gpmc_ad5),	(MODE(0) | PULLUDDIS | RXACTIVE)}, /* AD5  */
+	{OFFSET(gpmc_ad6),	(MODE(0) | PULLUDDIS | RXACTIVE)}, /* AD6  */
+	{OFFSET(gpmc_ad7),	(MODE(0) | PULLUDDIS | RXACTIVE)}, /* AD7  */
+#ifdef CONFIG_SYS_NAND_BUSWIDTH_16BIT
+	{OFFSET(gpmc_ad8),	(MODE(0) | PULLUDDIS | RXACTIVE)}, /* AD8  */
+	{OFFSET(gpmc_ad9),	(MODE(0) | PULLUDDIS | RXACTIVE)}, /* AD9  */
+	{OFFSET(gpmc_ad10),	(MODE(0) | PULLUDDIS | RXACTIVE)}, /* AD10 */
+	{OFFSET(gpmc_ad11),	(MODE(0) | PULLUDDIS | RXACTIVE)}, /* AD11 */
+	{OFFSET(gpmc_ad12),	(MODE(0) | PULLUDDIS | RXACTIVE)}, /* AD12 */
+	{OFFSET(gpmc_ad13),	(MODE(0) | PULLUDDIS | RXACTIVE)}, /* AD13 */
+	{OFFSET(gpmc_ad14),	(MODE(0) | PULLUDDIS | RXACTIVE)}, /* AD14 */
+	{OFFSET(gpmc_ad15),	(MODE(0) | PULLUDDIS | RXACTIVE)}, /* AD15 */
+#endif
+	{OFFSET(gpmc_wait0),	(MODE(0) | PULLUP_EN | RXACTIVE)}, /* nWAIT */
+	{OFFSET(gpmc_wpn),	(MODE(7) | PULLUP_EN)},		   /* nWP */
+	{OFFSET(gpmc_csn0),	(MODE(0) | PULLUP_EN)},		   /* nCS */
+	{OFFSET(gpmc_wen),	(MODE(0) | PULLDOWN_EN)},	   /* WEN */
+	{OFFSET(gpmc_oen_ren),	(MODE(0) | PULLDOWN_EN)},	   /* OE */
+	{OFFSET(gpmc_advn_ale),	(MODE(0) | PULLDOWN_EN)},	   /* ADV_ALE */
+	{OFFSET(gpmc_be0n_cle),	(MODE(0) | PULLDOWN_EN)},	   /* BE_CLE */
+	{-1},
+};
+#elif defined(CONFIG_NOR)
+static struct module_pin_mux bone_norcape_pin_mux[] = {
+	{OFFSET(gpmc_a0), MODE(0) | PULLUDDIS},			/* NOR_A0 */
+	{OFFSET(gpmc_a1), MODE(0) | PULLUDDIS},			/* NOR_A1 */
+	{OFFSET(gpmc_a2), MODE(0) | PULLUDDIS},			/* NOR_A2 */
+	{OFFSET(gpmc_a3), MODE(0) | PULLUDDIS},			/* NOR_A3 */
+	{OFFSET(gpmc_a4), MODE(0) | PULLUDDIS},			/* NOR_A4 */
+	{OFFSET(gpmc_a5), MODE(0) | PULLUDDIS},			/* NOR_A5 */
+	{OFFSET(gpmc_a6), MODE(0) | PULLUDDIS},			/* NOR_A6 */
+	{OFFSET(gpmc_a7), MODE(0) | PULLUDDIS},			/* NOR_A7 */
+	{OFFSET(gpmc_ad0), MODE(0) | PULLUDDIS | RXACTIVE},	/* NOR_AD0 */
+	{OFFSET(gpmc_ad1), MODE(0) | PULLUDDIS | RXACTIVE},	/* NOR_AD1 */
+	{OFFSET(gpmc_ad2), MODE(0) | PULLUDDIS | RXACTIVE},	/* NOR_AD2 */
+	{OFFSET(gpmc_ad3), MODE(0) | PULLUDDIS | RXACTIVE},	/* NOR_AD3 */
+	{OFFSET(gpmc_ad4), MODE(0) | PULLUDDIS | RXACTIVE},	/* NOR_AD4 */
+	{OFFSET(gpmc_ad5), MODE(0) | PULLUDDIS | RXACTIVE},	/* NOR_AD5 */
+	{OFFSET(gpmc_ad6), MODE(0) | PULLUDDIS | RXACTIVE},	/* NOR_AD6 */
+	{OFFSET(gpmc_ad7), MODE(0) | PULLUDDIS | RXACTIVE},	/* NOR_AD7 */
+	{OFFSET(gpmc_ad8), MODE(0) | PULLUDDIS | RXACTIVE},	/* NOR_AD8 */
+	{OFFSET(gpmc_ad9), MODE(0) | PULLUDDIS | RXACTIVE},	/* NOR_AD9 */
+	{OFFSET(gpmc_ad10), MODE(0) | PULLUDDIS | RXACTIVE},	/* NOR_AD10 */
+	{OFFSET(gpmc_ad11), MODE(0) | PULLUDDIS | RXACTIVE},	/* NOR_AD11 */
+	{OFFSET(gpmc_ad12), MODE(0) | PULLUDDIS | RXACTIVE},	/* NOR_AD12 */
+	{OFFSET(gpmc_ad13), MODE(0) | PULLUDDIS | RXACTIVE},	/* NOR_AD13 */
+	{OFFSET(gpmc_ad14), MODE(0) | PULLUDDIS | RXACTIVE},	/* NOR_AD14 */
+	{OFFSET(gpmc_ad15), MODE(0) | PULLUDDIS | RXACTIVE},	/* NOR_AD15 */
+	{OFFSET(gpmc_csn0), MODE(0) | PULLUDEN | PULLUP_EN},     /* CE */
+	{OFFSET(gpmc_advn_ale), MODE(0) | PULLUDEN | PULLDOWN_EN}, /* ALE */
+	{OFFSET(gpmc_oen_ren), MODE(0) | PULLUDEN | PULLDOWN_EN},/* OEn_REN */
+	{OFFSET(gpmc_be0n_cle), MODE(0) | PULLUDEN | PULLDOWN_EN},/* unused */
+	{OFFSET(gpmc_wen), MODE(0) | PULLUDEN | PULLDOWN_EN},    /* WEN */
+	{OFFSET(gpmc_wait0), MODE(0) | PULLUDEN | PULLUP_EN | RXACTIVE},/*WAIT*/
+	{-1},
+};
+#endif
+
+static struct module_pin_mux uart3_icev2_pin_mux[] = {
+	{OFFSET(mii1_rxd3), (MODE(1) | PULLUP_EN | RXACTIVE)},	/* UART3_RXD */
+	{OFFSET(mii1_rxd2), MODE(1) | PULLUDEN},		/* UART3_TXD */
+	{-1},
+};
+#endif
+
+#if defined(CONFIG_NOR_BOOT)
+void enable_norboot_pin_mux(void)
+{
+	configure_module_pin_mux(bone_norcape_pin_mux);
+}
+#endif
+
+void enable_uart0_pin_mux(void)
+{
+#ifdef NO_SILC_UBMC
+	configure_module_pin_mux(uart0_pin_mux);
+#else
+	MUX_CFG_SILC(OFFSET(uart0_txd),			(RXDISABLE | PULLUDDIS | MODE(0) )); /* e16	uart0_txd			uart_cli_txd */
+	MUX_CFG_SILC(OFFSET(uart0_rxd),			(RXACTIVE  | PULLUDDIS | MODE(0) )); /* e15	uart0_rxd			uart_cli_rxd */
+	MUX_CFG_SILC(OFFSET(uart0_rtsn),		(RXDISABLE | PULLUDDIS | MODE(3) )); /* e17	i2c1_scl			i2c_peci_scl */
+	MUX_CFG_SILC(OFFSET(uart0_ctsn),		(RXACTIVE  | PULLUDDIS | MODE(3) )); /* e18	i2c1_sda			i2c_peci_sda */
+#endif
+}
+
+void enable_uart1_pin_mux(void)
+{
+#ifdef NO_SILC_UBMC
+	configure_module_pin_mux(uart1_pin_mux);
+#else
+	//uart2
+	MUX_CFG_SILC(OFFSET(mmc0_clk),			(RXACTIVE  | PULLUP_EN | MODE(3) )); /* g17	uart2_rxd			uart_sol_rxd */
+	MUX_CFG_SILC(OFFSET(mmc0_cmd),			(RXDISABLE | PULLUDDIS | MODE(3) )); /* g18	uart2_txd			uart_sol_txd */
+#endif
+}
+
+void enable_uart2_pin_mux(void)
+{
+#ifdef NO_SILC_UBMC
+	configure_module_pin_mux(uart2_pin_mux);
+#endif
+}
+
+void enable_uart3_pin_mux(void)
+{
+#ifdef NO_SILC_UBMC
+	configure_module_pin_mux(uart3_pin_mux);
+#endif
+}
+
+void enable_uart4_pin_mux(void)
+{
+#ifdef NO_SILC_UBMC
+	configure_module_pin_mux(uart4_pin_mux);
+#endif
+}
+
+void enable_uart5_pin_mux(void)
+{
+#ifdef NO_SILC_UBMC
+	configure_module_pin_mux(uart5_pin_mux);
+#endif
+}
+
+void enable_i2c0_pin_mux(void)
+{
+#ifdef NO_SILC_UBMC
+	configure_module_pin_mux(i2c0_pin_mux);
+#endif
+}
+#if 0
+/*
+ * The AM335x GP EVM, if daughter card(s) are connected, can have 8
+ * different profiles.  These profiles determine what peripherals are
+ * valid and need pinmux to be configured.
+ */
+#define PROFILE_NONE	0x0
+#define PROFILE_0	(1 << 0)
+#define PROFILE_1	(1 << 1)
+#define PROFILE_2	(1 << 2)
+#define PROFILE_3	(1 << 3)
+#define PROFILE_4	(1 << 4)
+#define PROFILE_5	(1 << 5)
+#define PROFILE_6	(1 << 6)
+#define PROFILE_7	(1 << 7)
+#define PROFILE_MASK	0x7
+#define PROFILE_ALL	0xFF
+
+/* CPLD registers */
+#define I2C_CPLD_ADDR	0x35
+#define CFG_REG		0x10
+
+static unsigned short detect_daughter_board_profile(void)
+{
+	unsigned short val;
+
+	if (i2c_probe(I2C_CPLD_ADDR))
+		return PROFILE_NONE;
+
+	if (i2c_read(I2C_CPLD_ADDR, CFG_REG, 1, (unsigned char *)(&val), 2))
+		return PROFILE_NONE;
+
+	return (1 << (val & PROFILE_MASK));
+}
+#endif
+void enable_board_pin_mux(void)
+{
+#if 0
+	/* Do board-specific muxes. */
+	if (board_is_bone()) {
+		/* Beaglebone pinmux */
+		configure_module_pin_mux(mii1_pin_mux);
+		configure_module_pin_mux(mmc0_pin_mux);
+#if defined(CONFIG_NAND)
+		configure_module_pin_mux(nand_pin_mux);
+#elif defined(CONFIG_NOR)
+		configure_module_pin_mux(bone_norcape_pin_mux);
+#else
+		configure_module_pin_mux(mmc1_pin_mux);
+#endif
+	} else if (board_is_gp_evm()) {
+		/* General Purpose EVM */
+		unsigned short profile = detect_daughter_board_profile();
+		configure_module_pin_mux(rgmii1_pin_mux);
+		configure_module_pin_mux(mmc0_pin_mux);
+		/* In profile #2 i2c1 and spi0 conflict. */
+		if (profile & ~PROFILE_2)
+			configure_module_pin_mux(i2c1_pin_mux);
+		/* Profiles 2 & 3 don't have NAND */
+#ifdef CONFIG_NAND
+		if (profile & ~(PROFILE_2 | PROFILE_3))
+			configure_module_pin_mux(nand_pin_mux);
+#endif
+		else if (profile == PROFILE_2) {
+			configure_module_pin_mux(mmc1_pin_mux);
+			configure_module_pin_mux(spi0_pin_mux);
+		}
+	} else if (board_is_idk()) {
+		/* Industrial Motor Control (IDK) */
+		configure_module_pin_mux(mii1_pin_mux);
+		configure_module_pin_mux(mmc0_no_cd_pin_mux);
+	} else if (board_is_evm_sk()) {
+		/* Starter Kit EVM */
+		configure_module_pin_mux(i2c1_pin_mux);
+		configure_module_pin_mux(gpio0_7_pin_mux);
+		configure_module_pin_mux(rgmii1_pin_mux);
+		configure_module_pin_mux(mmc0_pin_mux_sk_evm);
+	} else if (board_is_bone_lt()) {
+		/* Beaglebone LT pinmux */
+		configure_module_pin_mux(mii1_pin_mux);
+		configure_module_pin_mux(mmc0_pin_mux);
+#if defined(CONFIG_NAND) && defined(CONFIG_EMMC_BOOT)
+		configure_module_pin_mux(nand_pin_mux);
+#elif defined(CONFIG_NOR) && defined(CONFIG_EMMC_BOOT)
+		configure_module_pin_mux(bone_norcape_pin_mux);
+#else
+		configure_module_pin_mux(mmc1_pin_mux);
+#endif
+	} else if (board_is_icev2()) {
+		configure_module_pin_mux(mmc0_pin_mux);
+		configure_module_pin_mux(gpio0_18_pin_mux);
+		configure_module_pin_mux(uart3_icev2_pin_mux);
+		configure_module_pin_mux(rmii1_pin_mux);
+		configure_module_pin_mux(spi0_pin_mux);
+	} else {
+		/* Unknown board. We might still be able to boot. */
+		puts("Bad EEPROM or unknown board, cannot configure pinmux.");
+	}
+#else
+/*
+ * MODE(0) - Mux Mode 0
+ * MODE(1) - Mux Mode 1
+ * MODE(2) - Mux Mode 2
+ * MODE(3) - Mux Mode 3
+ * MODE(4) - Mux Mode 4
+ * MODE(5) - Mux Mode 5
+ * MODE(6) - Mux Mode 6
+ * MODE(7) - Mux Mode 7
+ * RXDISABLE - Receiver disabled
+ * RXACTIVE - Receiver enabled
+ * PULLUDEN - Internal pull-down
+ * PULLUP_EN - Internal pull-up
+ * PULLUDDIS - Internal pull disabled
+ */
+//	printf("Setting board_pin_mux ubmc_eval\n");
+	//uart0
+	MUX_CFG_SILC(OFFSET(uart0_txd),			(RXDISABLE | PULLUDDIS | MODE(0) )); /* e16	uart0_txd			uart_cli_txd */
+	MUX_CFG_SILC(OFFSET(uart0_rxd),			(RXACTIVE  | PULLUDDIS | MODE(0) )); /* e15	uart0_rxd			uart_cli_rxd */
+
+	//uart2
+	MUX_CFG_SILC(OFFSET(mmc0_clk),			(RXACTIVE  | PULLUP_EN | MODE(3) )); /* g17	uart2_rxd			uart_sol_rxd */
+	MUX_CFG_SILC(OFFSET(mmc0_cmd),			(RXDISABLE | PULLUDDIS | MODE(3) )); /* g18	uart2_txd			uart_sol_txd */
+
+	//i2c0
+	MUX_CFG_SILC(OFFSET(i2c0_scl),			(RXDISABLE | PULLUP_EN | MODE(0) )); /* c16	i2c0_scl			i2c_sensors_scl */
+	MUX_CFG_SILC(OFFSET(i2c0_sda),			(RXACTIVE  | PULLUP_EN | MODE(0) )); /* c17	i2c0_sda			i2c_sensors_sda */
+
+	//i2c1
+	MUX_CFG_SILC(OFFSET(uart0_rtsn),		(RXDISABLE | PULLUDDIS | MODE(3) )); /* e17	i2c1_scl			i2c_peci_scl */
+	MUX_CFG_SILC(OFFSET(uart0_ctsn),		(RXACTIVE  | PULLUDDIS | MODE(3) )); /* e18	i2c1_sda			i2c_peci_sda */
+
+	MUX_CFG_SILC(OFFSET(gpmc_ad0),			(RXACTIVE  | PULLUDDIS | MODE(1) )); /* u7	mmc1_dat0			emmc_d0 */
+	MUX_CFG_SILC(OFFSET(gpmc_ad1),			(RXACTIVE  | PULLUDDIS | MODE(1) )); /* v7	mmc1_dat1			emmc_d1 */
+	MUX_CFG_SILC(OFFSET(gpmc_ad2),			(RXACTIVE  | PULLUDDIS | MODE(1) )); /* r8	mmc1_dat2			emmc_d2 */
+	MUX_CFG_SILC(OFFSET(gpmc_ad3),			(RXACTIVE  | PULLUDDIS | MODE(1) )); /* t8	mmc1_dat3			emmc_d3 */
+	MUX_CFG_SILC(OFFSET(gpmc_ad4),			(RXACTIVE  | PULLUDDIS | MODE(1) )); /* u8	mmc1_dat4			emmc_d4 */
+	MUX_CFG_SILC(OFFSET(gpmc_ad5),			(RXACTIVE  | PULLUDDIS | MODE(1) )); /* v8	mmc1_dat5			emmc_d5 */
+	MUX_CFG_SILC(OFFSET(gpmc_ad6),			(RXACTIVE  | PULLUDDIS | MODE(1) )); /* r9	mmc1_dat6			emmc_d6 */
+	MUX_CFG_SILC(OFFSET(gpmc_ad7),			(RXACTIVE  | PULLUDDIS | MODE(1) )); /* t9	mmc1_dat7			emmc_d7 */
+
+	MUX_CFG_SILC(OFFSET(gpmc_csn1),			(RXACTIVE | PULLUDDIS | MODE(2) )); /* u9	mmc1_clk			emmc_clk */
+	MUX_CFG_SILC(OFFSET(gpmc_csn2),			(RXACTIVE  | PULLUDDIS | MODE(2) )); /* v9	mmc1_cmd			emmc_cmd */
+	MUX_CFG_SILC(OFFSET(uart1_rxd),			(RXACTIVE  | PULLDOWN_EN  | MODE(1) )); /* d16	mmc1_sdwp			emmc_wp */
+	MUX_CFG_SILC(OFFSET(mcasp0_fsx),		(RXACTIVE  | PULLUP_EN | MODE(4) )); /* b13	mmc1_sdcd			emmc_cd */
+
+	MUX_CFG_SILC(OFFSET(spi0_sclk),			(RXACTIVE | PULLUDDIS | MODE(0) )); /* a17	spi0_sclk			spi_boot_clk */
+	MUX_CFG_SILC(OFFSET(spi0_cs0),			(RXDISABLE | PULLUDDIS | MODE(0) )); /* a16	spi0_cs0			spi_boot_cs_n */
+	MUX_CFG_SILC(OFFSET(spi0_d0),			(RXACTIVE  | PULLUDDIS | MODE(0) )); /* b17	spi0_d0				spi_boot_miso */
+	MUX_CFG_SILC(OFFSET(spi0_d1),			(RXDISABLE | PULLUDDIS | MODE(0) )); /* b16	spi0_d1				spi_boot_mosi */
+
+	MUX_CFG_SILC(OFFSET(mii1_col),			(RXDISABLE | PULLUDDIS | MODE(2) )); /* h16	spi1_sclk			spi_cpu_sck */
+	MUX_CFG_SILC(OFFSET(rmii1_refclk),		(RXDISABLE | PULLUDDIS | MODE(2) )); /* h18	spi1_cs0			spi_cpu_cs_n */
+	MUX_CFG_SILC(OFFSET(mii1_crs),			(RXACTIVE  | PULLUDDIS | MODE(2) )); /* h17	spi1_d0				spi_cpu_miso */
+	MUX_CFG_SILC(OFFSET(mii1_rxerr),		(RXDISABLE | PULLUDDIS | MODE(2) )); /* j15	spi1_d1				spi_cpu_mosi */
+
+	//rgmii_i1
+	MUX_CFG_SILC(OFFSET(mii1_txd0),			(RXDISABLE | PULLUDEN  | MODE(2) )); /* k17	rgmii1_td0			rgmii_1_txd0_r */
+	MUX_CFG_SILC(OFFSET(mii1_txd1),			(RXDISABLE | PULLUDEN  | MODE(2) )); /* k16	rgmii1_td1			rgmii_1_txd1_r */
+	MUX_CFG_SILC(OFFSET(mii1_txd2),			(RXDISABLE | PULLUDEN  | MODE(2) )); /* k15	rgmii1_td2			rgmii_1_txd2_r */
+	MUX_CFG_SILC(OFFSET(mii1_txd3),			(RXDISABLE | PULLUDEN  | MODE(2) )); /* j18	rgmii1_td3			rgmii_1_txd3_r */
+
+	MUX_CFG_SILC(OFFSET(mii1_txclk),		(RXDISABLE | PULLUDEN  | MODE(2) )); /* k18	rgmii1_tclk			rgmii_1_tx_clk_r*/
+	MUX_CFG_SILC(OFFSET(mii1_txen),			(RXDISABLE | PULLUDEN  | MODE(2) )); /* j16	rgmii1_tctl			rgmii_1_tx_en_r */
+
+	MUX_CFG_SILC(OFFSET(mii1_rxd0),			(RXACTIVE  | PULLUDDIS | MODE(2) )); /* m16	rgmii1_rd0			rgmii_1_rxd0 */
+	MUX_CFG_SILC(OFFSET(mii1_rxd1),			(RXACTIVE  | PULLUDDIS | MODE(2) )); /* l15	rgmii1_rd1			rgmii_1_rxd1 */
+	MUX_CFG_SILC(OFFSET(mii1_rxd2),			(RXACTIVE  | PULLUDDIS | MODE(2) )); /* l16	rgmii1_rd2			rgmii_1_rxd2 */
+	MUX_CFG_SILC(OFFSET(mii1_rxd3),			(RXACTIVE  | PULLUDDIS | MODE(2) )); /* l17	rgmii1_rd3			rgmii_1_rxd3 */
+
+	MUX_CFG_SILC(OFFSET(mii1_rxclk),		(RXACTIVE  | PULLUDDIS | MODE(2) )); /* l18	rgmii1_rclk			rgmii_1_rx_clk */
+	MUX_CFG_SILC(OFFSET(mii1_rxdv),			(RXACTIVE  | PULLUDDIS | MODE(2) )); /* j17	rgmii1_rctl			rgmii_1_rx_dv */
+
+	//rgmii2
+	MUX_CFG_SILC(OFFSET(gpmc_a0),			(RXDISABLE | PULLUDEN  | MODE(2) )); /* r13	rgmii2_tctl			rgmii_2_tx_en_r */
+	MUX_CFG_SILC(OFFSET(gpmc_a1),			(RXACTIVE  | PULLUDDIS | MODE(2) )); /* v14	rgmii2_rctl			rgmii_2_rx_dv */
+	MUX_CFG_SILC(OFFSET(gpmc_a2),			(RXDISABLE | PULLUDEN  | MODE(2) )); /* u14	rgmii2_td3			rgmii_2_txd3_r */
+	MUX_CFG_SILC(OFFSET(gpmc_a3),			(RXDISABLE | PULLUDEN  | MODE(2) )); /* t14	rgmii2_td2			rgmii_2_txd2_r */
+	MUX_CFG_SILC(OFFSET(gpmc_a4),			(RXDISABLE | PULLUDEN  | MODE(2) )); /* r14	rgmii2_td1			rgmii_2_txd1_r */
+	MUX_CFG_SILC(OFFSET(gpmc_a5),			(RXDISABLE | PULLUDEN  | MODE(2) )); /* v15	rgmii2_td0			rgmii_2_txd0_r */
+	MUX_CFG_SILC(OFFSET(gpmc_a6),			(RXDISABLE | PULLUDEN  | MODE(2) )); /* u15	rgmii2_tclk			rgmii_2_tx_clk_r*/
+	MUX_CFG_SILC(OFFSET(gpmc_a7),			(RXACTIVE  | PULLUDDIS | MODE(2) )); /* t15	rgmii2_rclk			rgmii_2_rx_clk */
+	MUX_CFG_SILC(OFFSET(gpmc_a8),			(RXACTIVE  | PULLUDDIS | MODE(2) )); /* v16	rgmii2_rd3			rgmii_2_rxd3 */
+	MUX_CFG_SILC(OFFSET(gpmc_a9),			(RXACTIVE  | PULLUDDIS | MODE(2) )); /* u16	rgmii2_rd2			rgmii_2_rxd2 */
+	MUX_CFG_SILC(OFFSET(gpmc_a10),			(RXACTIVE  | PULLUDDIS | MODE(2) )); /* t16	rgmii2_rd1			rgmii_2_rxd1 */
+	MUX_CFG_SILC(OFFSET(gpmc_a11),			(RXACTIVE  | PULLUDDIS | MODE(2) )); /* v17	rgmii2_rd0			rgmii_2_rxd0 */
+
+	//mdio
+	MUX_CFG_SILC(OFFSET(mdio_data),			(RXACTIVE  | PULLUDDIS | MODE(0) )); /* m17	mdio_data			mdio */
+	MUX_CFG_SILC(OFFSET(mdio_clk),			(RXDISABLE | PULLUP_EN | MODE(0) )); /* m18	mdio_clk			mdc */
+
+
+	//usb0
+	MUX_CFG_SILC(OFFSET(usb0_drvvbus),		(RXDISABLE | PULLUDEN  | MODE(0) )); /* f16	usb0_drvvbus		usb_vbus_en */
+	MUX_CFG_SILC(OFFSET(gpmc_csn0),			(RXACTIVE  | PULLUDDIS | MODE(7) )); /* v6	gpio1_29			usb_oc_n */
+
+	MUX_CFG_SILC(OFFSET(usb1_drvvbus),		(RXDISABLE | PULLUDEN  | MODE(0) )); /* f15	usb1_drvvbus		n/c */
+
+	MUX_CFG_SILC(OFFSET(lcd_data12),		(RXACTIVE  | PULLUDDIS | MODE(7) )); /* v2	gpio0_8				noname */
+	MUX_CFG_SILC(OFFSET(lcd_data13),		(RXACTIVE  | PULLUDDIS | MODE(7) )); /* v3	gpio0_9				noname */
+	MUX_CFG_SILC(OFFSET(lcd_data14),		(RXACTIVE  | PULLUDDIS | MODE(7) )); /* v4	gpio0_10			noname */
+	MUX_CFG_SILC(OFFSET(lcd_data15),		(RXACTIVE  | PULLUDDIS | MODE(7) )); /* t5	gpio0_11			noname */
+	MUX_CFG_SILC(OFFSET(uart1_ctsn),		(RXDISABLE | PULLUDDIS | MODE(7) )); /* d18	gpio0_12			n/c */
+	MUX_CFG_SILC(OFFSET(uart1_rtsn),		(RXDISABLE | PULLUDDIS | MODE(7) )); /* d17	gpio0_13			n/c */
+	MUX_CFG_SILC(OFFSET(uart1_txd),			(RXACTIVE  | PULLUDDIS | MODE(7) )); /* d15	gpio0_15			cpu_rstbtn_n */
+	MUX_CFG_SILC(OFFSET(xdma_event_intr0),	(RXACTIVE  | PULLUDDIS | MODE(7) )); /* a15	gpio0_19			psu_pwrgd3 */
+	MUX_CFG_SILC(OFFSET(xdma_event_intr1),	(RXACTIVE  | PULLUDDIS | MODE(7) )); /* d14	gpio0_20			gpio7 */
+	MUX_CFG_SILC(OFFSET(gpmc_ad8),			(RXDISABLE | PULLUDDIS | MODE(7) )); /* u10	gpio0_22			n/c */
+	MUX_CFG_SILC(OFFSET(gpmc_ad9),			(RXDISABLE | PULLUDDIS | MODE(7) )); /* t10	gpio0_23			n/c */
+	MUX_CFG_SILC(OFFSET(gpmc_ad10),			(RXDISABLE | PULLUDDIS | MODE(7) )); /* t11	gpio0_26			n/c */
+	MUX_CFG_SILC(OFFSET(gpmc_ad11),			(RXDISABLE | PULLUDDIS | MODE(7) )); /* u12	gpio0_27			n/c */
+	MUX_CFG_SILC(OFFSET(gpmc_be1n),			(RXACTIVE  | PULLUDDIS | MODE(7) )); /* u18	gpio1_28			gpio5 */
+	MUX_CFG_SILC(OFFSET(gpmc_wait0),		(RXACTIVE  | PULLUDDIS | MODE(7) )); /* t17	gpio0_30			cpu_thermtrip_n */
+	MUX_CFG_SILC(OFFSET(gpmc_wpn),			(RXACTIVE  | PULLUDDIS | MODE(7) )); /* u17	gpio0_31			gpio2 */
+
+	MUX_CFG_SILC(OFFSET(gpmc_ad12),			(RXACTIVE  | PULLUDDIS | MODE(7) )); /* t12	gpio1_12			gpio3 */
+	MUX_CFG_SILC(OFFSET(gpmc_ad13),			(RXDISABLE | PULLUDDIS | MODE(7) )); /* r12	gpio1_13			n/c */
+	MUX_CFG_SILC(OFFSET(gpmc_ad14),			(RXDISABLE | PULLUDDIS | MODE(7) )); /* v13	gpio1_14			n/c */
+	MUX_CFG_SILC(OFFSET(gpmc_ad15),			(RXDISABLE | PULLUDDIS | MODE(7) )); /* u13	gpio1_15			n/c */
+
+
+	MUX_CFG_SILC(OFFSET(gpmc_csn3),			(RXDISABLE | PULLUDDIS | MODE(7) )); /* t13	gpio2_0				n/c */
+	MUX_CFG_SILC(OFFSET(gpmc_clk),			(RXDISABLE | PULLUDDIS | MODE(7) )); /* v12	gpio2_1				n/c */
+	MUX_CFG_SILC(OFFSET(gpmc_advn_ale),		(RXACTIVE  | PULLUDDIS | MODE(7) )); /* r7	gpio2_2				cpu_slp_s3_n */
+	MUX_CFG_SILC(OFFSET(gpmc_oen_ren),		(RXACTIVE  | PULLUDDIS | MODE(7) )); /* t7	gpio2_3				cpu_error_n */
+	MUX_CFG_SILC(OFFSET(gpmc_wen),			(RXACTIVE  | PULLUDDIS | MODE(7) )); /* u6	gpio2_4				gpio0 */
+	MUX_CFG_SILC(OFFSET(gpmc_be0n_cle),		(RXACTIVE  | PULLUDDIS | MODE(7) )); /* t6	gpio2_5				cpu_slp_s5_n */
+
+
+
+
+
+
+	MUX_CFG_SILC(OFFSET(lcd_data1),			(RXACTIVE  | PULLUDDIS | MODE(7) )); /* r2	gpio2_7				noname */
+	MUX_CFG_SILC(OFFSET(lcd_data2),			(RXACTIVE  | PULLUDDIS | MODE(7) )); /* r3	gpio2_8				noname */
+	MUX_CFG_SILC(OFFSET(lcd_data3),			(RXACTIVE  | PULLUDDIS | MODE(7) )); /* r4	gpio2_9				noname */
+	MUX_CFG_SILC(OFFSET(lcd_data4),			(RXACTIVE  | PULLUDDIS | MODE(7) )); /* t1	gpio2_10			noname */
+	MUX_CFG_SILC(OFFSET(lcd_data5),			(RXACTIVE  | PULLUDDIS | MODE(7) )); /* t2	gpio2_11			noname */
+	MUX_CFG_SILC(OFFSET(lcd_data6),			(RXACTIVE  | PULLUDDIS | MODE(7) )); /* t3	gpio2_12			noname */
+	MUX_CFG_SILC(OFFSET(lcd_data7),			(RXACTIVE  | PULLUDDIS | MODE(7) )); /* t4	gpio2_13			noname */
+	MUX_CFG_SILC(OFFSET(lcd_data8),			(RXACTIVE  | PULLUDDIS | MODE(7) )); /* u1	gpio2_14			noname */
+	MUX_CFG_SILC(OFFSET(lcd_data9),			(RXACTIVE  | PULLUDDIS | MODE(7) )); /* u2	gpio2_15			noname */
+	MUX_CFG_SILC(OFFSET(lcd_data11),		(RXACTIVE  | PULLUDDIS | MODE(7) )); /* u4	gpio2_17			noname */
+
+	MUX_CFG_SILC(OFFSET(lcd_vsync),			(RXACTIVE  | PULLUDDIS | MODE(7) )); /* u5	gpio2_22			cpu_pltrst_n */
+	MUX_CFG_SILC(OFFSET(lcd_hsync),			(RXACTIVE  | PULLUDDIS | MODE(7) )); /* r5	gpio2_23			cpu_slp_s4_n */
+	MUX_CFG_SILC(OFFSET(lcd_pclk),			(RXDISABLE | PULLUDDIS | MODE(7) )); /* v5	gpio2_24			testpoint_spare */
+
+	MUX_CFG_SILC(OFFSET(lcd_ac_bias_en),	(RXACTIVE  | PULLUDDIS | MODE(7) )); /* r6	gpio2_25			gpio1 */
+	MUX_CFG_SILC(OFFSET(mmc0_dat3),			(RXACTIVE  | PULLUDDIS | MODE(7) )); /* f17	gpio2_26			gpio4 */
+	MUX_CFG_SILC(OFFSET(mmc0_dat2),			(RXACTIVE  | PULLUDDIS | MODE(7) )); /* f18	gpio2_27			cpu_pwrbtn_n */
+	MUX_CFG_SILC(OFFSET(mmc0_dat1),			(RXACTIVE  | PULLUDDIS | MODE(7) )); /* g15	gpio2_28			cpu_prochot_n */
+	MUX_CFG_SILC(OFFSET(mmc0_dat0),			(RXDISABLE | PULLUDDIS | MODE(7) )); /* g16	gpio2_29			n/c */
+
+
+	MUX_CFG_SILC(OFFSET(mcasp0_aclkx),		(RXACTIVE  | PULLUDDIS | MODE(7) )); /* a13	gpio3_14			psu_pwrgd1 */
+	MUX_CFG_SILC(OFFSET(mcasp0_axr0),		(RXDISABLE | PULLUDDIS | MODE(7) )); /* d12	gpio3_16			spi_cpu_mux_en	o ? */
+	MUX_CFG_SILC(OFFSET(mcasp0_aclkr),		(RXACTIVE  | PULLUDDIS | MODE(7) )); /* b12	gpio3_18			psu_pwrgd0 */
+	MUX_CFG_SILC(OFFSET(mcasp0_fsr),		(RXACTIVE  | PULLUDDIS | MODE(7) )); /* c13	gpio3_19			gpio6 */
+	MUX_CFG_SILC(OFFSET(mcasp0_axr1),		(RXDISABLE | PULLUDDIS | MODE(7) )); /* d13	gpio3_20			n/c */
+	MUX_CFG_SILC(OFFSET(mcasp0_ahclkx),		(RXACTIVE  | PULLUDDIS | MODE(7) )); /* a14	gpio3_21			psu_pwrgd2 */
+
+
+#if 0
+	MUX_CFG_SILC(OFFSET(tck),				(RXACTIVE  | PULLUP_EN | MODE(0) )); /* a12	tck					jtag_tck */
+	MUX_CFG_SILC(OFFSET(tdi),				(RXACTIVE  | PULLUP_EN | MODE(0) )); /* b11	tdi					jtag_tdi */
+	MUX_CFG_SILC(OFFSET(tdo),				(RXDISABLE | PULLUP_EN | MODE(0) )); /* a11	tdo					jtag_tdo */
+	MUX_CFG_SILC(OFFSET(tms),				(RXACTIVE  | PULLUP_EN | MODE(0) )); /* c11	tms					jtag_tms */
+	MUX_CFG_SILC(OFFSET(ntrst),				(RXACTIVE  | PULLUDEN  | MODE(0) )); /* b10	ntrst				jtag_trst_n */
+
+	MUX_CFG_SILC(OFFSET(emu0),				(RXACTIVE  | PULLUP_EN | MODE(0) )); /* c14	emu0				emu0 */
+	MUX_CFG_SILC(OFFSET(emu1),				(RXACTIVE  | PULLUP_EN | MODE(0) )); /* b14	emu1				emu1 */
+
+
+	MUX_CFG_SILC(OFFSET(spi0_cs1),			(RXACTIVE  | PULLUDDIS | MODE(2) )); /* c15	ecap1_in_pwm1_out	fan_tach0 */
+	MUX_CFG_SILC(OFFSET(ecap0_in_pwm0_out),	(RXACTIVE  | PULLUDDIS | MODE(0) )); /* c18	ecap0_in_pwm0_out	cpu_heartbeat_n */
+	MUX_CFG_SILC(OFFSET(lcd_data0),			(RXDISABLE | PULLUDDIS | MODE(3) )); /* r1	ehrpwm2a			fan_pwm1 */
+	MUX_CFG_SILC(OFFSET(lcd_data10),		(RXDISABLE | PULLUDDIS | MODE(2) )); /* u3	gpio2_16 ehrpwm1a	fan_pwm0 */
+	MUX_CFG_SILC(OFFSET(mcasp0_ahclkr),		(RXACTIVE  | PULLUDEN  | MODE(4) )); /* c12	ecap2_in_pwm2_out	fan_tach1 */
+
+
+	MUX_CFG_SILC(OFFSET(rtc_porz),			(RXACTIVE  | PULLUDDIS | MODE(0) )); /* b5	rtc_porz			pm_rtcrst_n */
+	MUX_CFG_SILC(OFFSET(enz_kaldo_1p8v),	(RXACTIVE  | PULLUDDIS | MODE(0) )); /* b4	enz_kaldo_1p8v		pm_rtc_ldo_en_n */
+	MUX_CFG_SILC(OFFSET(pmic_power_en),		(RXDISABLE | PULLUP_EN | MODE(0) )); /* c6	pmic_power_en		n/c */
+	MUX_CFG_SILC(OFFSET(nresetin_out),		(RXACTIVE  | PULLUDDIS | MODE(0) )); /* a10	nresetin_out		pm_warmrst_n */
+	MUX_CFG_SILC(OFFSET(nnmi),				(RXACTIVE  | PULLUDDIS | MODE(0) )); /* b18	nnmi				nmi_n */
+	MUX_CFG_SILC(OFFSET(ext_wakeup),		(RXACTIVE  | PULLUDEN  | MODE(0) )); /* c5	ext_wakeup			wake_n */
+#endif
+
+#endif
+
+//	i2c_init(100000, 1);
+
+}
diff -uNr uboot-custom-orig/board/silicom/ubmc_eval/README uboot-custom-silicom/board/silicom/ubmc_eval/README
--- uboot-custom-orig/board/silicom/ubmc_eval/README	1970-01-01 08:00:00.000000000 +0800
+++ uboot-custom-silicom/board/silicom/ubmc_eval/README	2018-08-04 21:16:32.310348228 +0800
@@ -0,0 +1,15 @@
+Summary
+=======
+
+This document covers various features of the 'ubmc_eval' board build.
+For more information about this board, visit http://birdland.com/oem
+
+
+Hardware
+========
+
+Silicom ubmc eval hardware
+
+Customization
+=============
+
diff -uNr uboot-custom-orig/board/silicom/ubmc_eval/u-boot.lds uboot-custom-silicom/board/silicom/ubmc_eval/u-boot.lds
--- uboot-custom-orig/board/silicom/ubmc_eval/u-boot.lds	1970-01-01 08:00:00.000000000 +0800
+++ uboot-custom-silicom/board/silicom/ubmc_eval/u-boot.lds	2018-08-04 21:16:32.310348228 +0800
@@ -0,0 +1,116 @@
+/*
+ * Copyright (c) 2012-2014 Birdland Audio - http://birdland.com/oem
+ * Copyright (c) 2004-2008 Texas Instruments
+ *
+ * (C) Copyright 2002
+ * Gary Jennejohn, DENX Software Engineering, <garyj@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+OUTPUT_FORMAT("elf32-littlearm", "elf32-littlearm", "elf32-littlearm")
+OUTPUT_ARCH(arm)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text :
+	{
+		*(.__image_copy_start)
+		*(.vectors)
+		CPUDIR/start.o (.text*)
+		board/silicom/ubmc_eval/built-in.o (.text*)
+		*(.text*)
+	}
+
+	. = ALIGN(4);
+	.rodata : { *(SORT_BY_ALIGNMENT(SORT_BY_NAME(.rodata*))) }
+
+	. = ALIGN(4);
+	.data : {
+		*(.data*)
+	}
+
+	. = ALIGN(4);
+
+	. = .;
+
+	. = ALIGN(4);
+	.u_boot_list : {
+		KEEP(*(SORT(.u_boot_list*)));
+	}
+
+	. = ALIGN(4);
+
+	.image_copy_end :
+	{
+		*(.__image_copy_end)
+	}
+
+	.rel_dyn_start :
+	{
+		*(.__rel_dyn_start)
+	}
+
+	.rel.dyn : {
+		*(.rel*)
+	}
+
+	.rel_dyn_end :
+	{
+		*(.__rel_dyn_end)
+	}
+
+	.hash : { *(.hash*) }
+
+	.end :
+	{
+		*(.__end)
+	}
+
+	_image_binary_end = .;
+
+	/*
+	 * Deprecated: this MMU section is used by pxa at present but
+	 * should not be used by new boards/CPUs.
+	 */
+	. = ALIGN(4096);
+	.mmutable : {
+		*(.mmutable)
+	}
+
+/*
+ * Compiler-generated __bss_start and __bss_end, see arch/arm/lib/bss.c
+ * __bss_base and __bss_limit are for linker only (overlay ordering)
+ */
+
+	.bss_start __rel_dyn_start (OVERLAY) : {
+		KEEP(*(.__bss_start));
+		__bss_base = .;
+	}
+
+	.bss __bss_base (OVERLAY) : {
+		*(.bss*)
+		 . = ALIGN(4);
+		 __bss_limit = .;
+	}
+
+	.bss_end __bss_limit (OVERLAY) : {
+		KEEP(*(.__bss_end));
+	}
+
+	.dynsym _image_binary_end : { *(.dynsym) }
+	.dynbss : { *(.dynbss) }
+	.dynstr : { *(.dynstr*) }
+	.dynamic : { *(.dynamic*) }
+	.gnu.hash : { *(.gnu.hash) }
+	.plt : { *(.plt*) }
+	.interp : { *(.interp*) }
+	.gnu : { *(.gnu*) }
+	.ARM.exidx : { *(.ARM.exidx*) }
+}
diff -uNr uboot-custom-orig/board/silicom/ubmc_eval/vecpe_bmc_pinmux.h uboot-custom-silicom/board/silicom/ubmc_eval/vecpe_bmc_pinmux.h
--- uboot-custom-orig/board/silicom/ubmc_eval/vecpe_bmc_pinmux.h	1970-01-01 08:00:00.000000000 +0800
+++ uboot-custom-silicom/board/silicom/ubmc_eval/vecpe_bmc_pinmux.h	2018-08-04 21:16:32.310348228 +0800
@@ -0,0 +1,187 @@
+#ifndef _VECPE_BMC_PINMUX_H_
+#define _VECPE_BMC_PINMUX_H_
+
+/*
+	Use 4 space tabs and things will look much better.
+*/
+
+/*
+ * MODE(0) - Mux Mode 0
+ * MODE(1) - Mux Mode 1
+ * MODE(2) - Mux Mode 2
+ * MODE(3) - Mux Mode 3
+ * MODE(4) - Mux Mode 4
+ * MODE(5) - Mux Mode 5
+ * MODE(6) - Mux Mode 6
+ * MODE(7) - Mux Mode 7
+ * RXDISABLE - Receiver disabled
+ * RXACTIVE - Receiver enabled
+ * PULLUDEN - Internal pull-down
+ * PULLUP_EN - Internal pull-up
+ * PULLUDDIS - Internal pull disabled
+ */
+#define RXDISABLE	(0x0 << 5)
+
+#define MUX_UBMC() \
+MUX_CFG(gpmc_a0,			 (RXDISABLE | PULLUDDIS | MODE(3) )) /* rmii2_txen */\
+MUX_CFG(gpmc_a1,			 (RXACTIVE  | PULLUDEN  | MODE(7) )) /* gpio1[17] */\
+MUX_CFG(gpmc_a2,			 (RXACTIVE  | PULLUDEN  | MODE(7) )) /* gpio1[18] */\
+MUX_CFG(gpmc_a3,			 (RXACTIVE  | PULLUDEN  | MODE(7) )) /* gpio1[19] */\
+MUX_CFG(gpmc_a4,			 (RXDISABLE | PULLUDDIS | MODE(3) )) /* rmii2_txd1 */\
+MUX_CFG(gpmc_a5,			 (RXDISABLE | PULLUDDIS | MODE(3) )) /* rmii2_txd0 */\
+MUX_CFG(gpmc_a6,			 (RXDISABLE | PULLUDDIS | MODE(7) )) /* gpio1[22] */\
+MUX_CFG(gpmc_a7,			 (RXACTIVE  | PULLUDDIS | MODE(7) )) /* gpio1[23] */\
+MUX_CFG(gpmc_a8,			 (RXACTIVE  | PULLUDDIS | MODE(7) )) /* gpio1[24] */\
+MUX_CFG(gpmc_a9,			 (RXACTIVE  | PULLUDDIS | MODE(7) )) /* gpio1[25] */\
+MUX_CFG(gpmc_a10,			 (RXACTIVE  | PULLUDDIS | MODE(3) )) /* rmii2_rxd1 */\
+MUX_CFG(gpmc_a11,			 (RXACTIVE  | PULLUDDIS | MODE(3) )) /* rmii2_rxd0 */\
+\
+MUX_CFG(gpmc_ad0,			 (RXACTIVE  | PULLUDDIS | MODE(1) )) /* mmc1_dat0_mux2 */\
+MUX_CFG(gpmc_ad1,			 (RXACTIVE  | PULLUDDIS | MODE(1) )) /* mmc1_dat1_mux2 */\
+MUX_CFG(gpmc_ad2,			 (RXACTIVE  | PULLUDDIS | MODE(1) )) /* mmc1_dat2_mux2 */\
+MUX_CFG(gpmc_ad3,			 (RXACTIVE  | PULLUDDIS | MODE(1) )) /* mmc1_dat3_mux2 */\
+MUX_CFG(gpmc_ad4,			 (RXACTIVE  | PULLUDDIS | MODE(1) )) /* mmc1_dat4_mux2 */\
+MUX_CFG(gpmc_ad5,			 (RXACTIVE  | PULLUDDIS | MODE(1) )) /* mmc1_dat5_mux2 */\
+MUX_CFG(gpmc_ad6,			 (RXACTIVE  | PULLUDDIS | MODE(1) )) /* mmc1_dat6_mux2 */\
+MUX_CFG(gpmc_ad7,			 (RXACTIVE  | PULLUDDIS | MODE(1) )) /* mmc1_dat7_mux2 */\
+MUX_CFG(gpmc_ad8,			 (RXDISABLE | PULLUDEN  | MODE(7) )) /* gpio0[22] */\
+MUX_CFG(gpmc_ad9,			 (RXACTIVE  | PULLUDDIS | MODE(7) )) /* gpio0[23] */\
+MUX_CFG(gpmc_ad10,			 (RXACTIVE  | PULLUDDIS | MODE(7) )) /* gpio0[26] */\
+MUX_CFG(gpmc_ad11,			 (RXDISABLE | PULLUDDIS | MODE(7) )) /* gpio0[27] */\
+MUX_CFG(gpmc_ad12,			 (RXACTIVE  | PULLUDDIS | MODE(7) )) /* gpio1[12] */\
+MUX_CFG(gpmc_ad13,			 (RXACTIVE  | PULLUDDIS | MODE(7) )) /* gpio1[13] */\
+MUX_CFG(gpmc_ad14,			 (RXACTIVE  | PULLUDDIS | MODE(7) )) /* gpio1[14] */\
+MUX_CFG(gpmc_ad15,			 (RXACTIVE  | PULLUDDIS | MODE(7) )) /* gpio1[15] */\
+\
+MUX_CFG(gpmc_csn0,			 (RXACTIVE  | PULLUDDIS | MODE(7) )) /* gpio1[29] */\
+MUX_CFG(gpmc_csn1,			 (RXACTIVE  | PULLUDDIS | MODE(2) )) /* mmc1_clk_mux0 */\
+MUX_CFG(gpmc_csn2,			 (RXACTIVE  | PULLUDDIS | MODE(2) )) /* mmc1_cmd_mux0 */\
+MUX_CFG(gpmc_csn3,			 (RXACTIVE  | PULLUDDIS | MODE(7) )) /* gpio2[0] */\
+\
+MUX_CFG(gpmc_advn_ale,		 (RXACTIVE  | PULLUDDIS | MODE(7) )) /* gpio2[2] */\
+MUX_CFG(gpmc_oen_ren,		 (RXDISABLE | PULLUDDIS | MODE(7) )) /* gpio2[3] */\
+MUX_CFG(gpmc_wen,			 (RXACTIVE  | PULLUDDIS | MODE(7) )) /* gpio2[4] */\
+MUX_CFG(gpmc_wpn,			 (RXDISABLE | PULLUDDIS | MODE(7) )) /* gpio0[31] */\
+MUX_CFG(gpmc_clk,			 (RXACTIVE  | PULLUDDIS | MODE(7) )) /* gpio2[1] */\
+MUX_CFG(gpmc_ben0_cle,		 (RXDISABLE | PULLUDDIS | MODE(7) )) /* gpio2[5] */\
+MUX_CFG(gpmc_ben1,			 (RXDISABLE | PULLUDDIS | MODE(7) )) /* gpio1[28] */\
+MUX_CFG(gpmc_wait0,			 (RXACTIVE  | PULLUDDIS | MODE(3) )) /* rmii2_crs_dv_mux0 */\
+\
+MUX_CFG(mmc0_dat0,			 (RXACTIVE  | PULLUDDIS | MODE(0) )) /* mmc0_dat0 */\
+MUX_CFG(mmc0_dat1,			 (RXACTIVE  | PULLUDDIS | MODE(0) )) /* mmc0_dat1 */\
+MUX_CFG(mmc0_dat2,			 (RXACTIVE  | PULLUDDIS | MODE(0) )) /* mmc0_dat2 */\
+MUX_CFG(mmc0_dat3,			 (RXACTIVE  | PULLUDDIS | MODE(0) )) /* mmc0_dat3 */\
+\
+MUX_CFG(mmc0_clk,			 (RXACTIVE  | PULLUDDIS | MODE(0) )) /* mmc0_clk */\
+MUX_CFG(mmc0_cmd,			 (RXACTIVE  | PULLUDDIS | MODE(0) )) /* mmc0_cmd */\
+\
+MUX_CFG(usb0_drvvbus,		 (RXDISABLE | PULLUDEN  | MODE(0) )) /* USB0_DRVVBUS */\
+MUX_CFG(usb1_drvvbus,		 (RXDISABLE | PULLUDEN  | MODE(0) )) /* USB1_DRVVBUS */\
+\
+MUX_CFG(uart0_txd,			 (RXDISABLE | PULLUDDIS | MODE(0) )) /* uart0_txd */\
+MUX_CFG(uart0_rxd,			 (RXACTIVE  | PULLUDDIS | MODE(0) )) /* uart0_rxd */\
+MUX_CFG(uart0_rtsn,			 (RXDISABLE | PULLUDDIS | MODE(0) )) /* uart0_rtsn */\
+MUX_CFG(uart0_ctsn,			 (RXACTIVE  | PULLUDDIS | MODE(0) )) /* uart0_ctsn */\
+\
+MUX_CFG(uart1_txd,			 (RXDISABLE | PULLUDDIS | MODE(0) )) /* uart1_txd */\
+MUX_CFG(uart1_rxd,			 (RXACTIVE  | PULLUDDIS | MODE(0) )) /* uart1_rxd */\
+MUX_CFG(uart1_rtsn,			 (RXACTIVE  | PULLUDDIS | MODE(3) )) /* I2C2_SCL_mux0 */\
+MUX_CFG(uart1_ctsn,			 (RXACTIVE  | PULLUDDIS | MODE(3) )) /* I2C2_SDA_mux0 */\
+\
+MUX_CFG(i2c0_sda,			 (RXACTIVE  | PULLUDDIS  | MODE(0) )) /* I2C0_SDA */\
+MUX_CFG(i2c0_scl,			 (RXACTIVE  | PULLUDDIS  | MODE(0) )) /* I2C0_SCL */\
+\
+MUX_CFG(spi0_sclk,			 (RXDISABLE | PULLUDDIS | MODE(0) )) /* spi0_sclk */\
+MUX_CFG(spi0_cs0,			 (RXDISABLE | PULLUDDIS | MODE(0) )) /* spi0_cs0 */\
+MUX_CFG(spi0_cs1,			 (RXDISABLE | PULLUDEN  | MODE(7) )) /* gpio0[6] */\
+MUX_CFG(spi0_d0,			 (RXACTIVE  | PULLUDDIS | MODE(0) )) /* spi0_d0 */\
+MUX_CFG(spi0_d1,			 (RXDISABLE | PULLUDDIS | MODE(0) )) /* spi0_d1 */\
+\
+MUX_CFG(lcd_data15,			 (RXACTIVE  | PULLUDDIS | MODE(7) )) /* gpio0[11] */\
+MUX_CFG(lcd_data14,			 (RXACTIVE  | PULLUDDIS | MODE(7) )) /* gpio0[10] */\
+MUX_CFG(lcd_data13,			 (RXACTIVE  | PULLUDDIS | MODE(7) )) /* gpio0[9] */\
+MUX_CFG(lcd_data12,			 (RXACTIVE  | PULLUDDIS | MODE(7) )) /* gpio0[8] */\
+MUX_CFG(lcd_data11,			 (RXACTIVE  | PULLUDDIS | MODE(7) )) /* gpio2[17] */\
+MUX_CFG(lcd_data10,			 (RXACTIVE  | PULLUDDIS | MODE(7) )) /* gpio2[16] */\
+MUX_CFG(lcd_data9,			 (RXACTIVE  | PULLUDDIS | MODE(7) )) /* gpio2[15] */\
+MUX_CFG(lcd_data8,			 (RXACTIVE  | PULLUDDIS | MODE(7) )) /* gpio2[14] */\
+MUX_CFG(lcd_data7,			 (RXACTIVE  | PULLUDDIS | MODE(7) )) /* gpio2[13] */\
+MUX_CFG(lcd_data6,			 (RXACTIVE  | PULLUDDIS | MODE(7) )) /* gpio2[12] */\
+MUX_CFG(lcd_data5,			 (RXACTIVE  | PULLUDDIS | MODE(7) )) /* gpio2[11] */\
+MUX_CFG(lcd_data4,			 (RXACTIVE  | PULLUDDIS | MODE(7) )) /* gpio2[10] */\
+MUX_CFG(lcd_data3,			 (RXACTIVE  | PULLUDDIS | MODE(7) )) /* gpio2[9] */\
+MUX_CFG(lcd_data2,			 (RXACTIVE  | PULLUDDIS | MODE(7) )) /* gpio2[8] */\
+MUX_CFG(lcd_data1,			 (RXACTIVE  | PULLUDDIS | MODE(7) )) /* gpio2[7] */\
+MUX_CFG(lcd_data0,			 (RXACTIVE  | PULLUDDIS | MODE(7) )) /* gpio2[6] */\
+\
+MUX_CFG(lcd_pclk,			 (RXACTIVE  | PULLUDEN  | MODE(7) )) /* gpio2[24] */\
+\
+MUX_CFG(lcd_vsync,			 (RXDISABLE | PULLUDDIS | MODE(7) )) /* gpio2[22] */\
+MUX_CFG(lcd_hsync,			 (RXDISABLE | PULLUDDIS | MODE(7) )) /* gpio2[23] */\
+\
+MUX_CFG(lcd_ac_bias_en,		 (RXDISABLE | PULLUDDIS | MODE(7) )) /* gpio2[25] */\
+\
+MUX_CFG(mii1_txd0,			 (RXDISABLE | PULLUDDIS | MODE(2) )) /* rgmii1_td0 */\
+MUX_CFG(mii1_txd1,			 (RXDISABLE | PULLUDDIS | MODE(2) )) /* rgmii1_td1 */\
+MUX_CFG(mii1_txd2,			 (RXDISABLE | PULLUDDIS | MODE(2) )) /* rgmii1_td2 */\
+MUX_CFG(mii1_txd3,			 (RXDISABLE | PULLUDDIS | MODE(2) )) /* rgmii1_td3 */\
+\
+MUX_CFG(mii1_tx_clk,		 (RXDISABLE | PULLUDDIS | MODE(2) )) /* rgmii1_tclk */\
+MUX_CFG(mii1_tx_en,			 (RXDISABLE | PULLUDDIS | MODE(2) )) /* rgmii1_tctl */\
+MUX_CFG(mii1_crs,			 (RXDISABLE | PULLUDEN  | MODE(7) )) /* gpio3[1] */\
+MUX_CFG(mii1_col,			 (RXACTIVE  | PULLUDDIS | MODE(1) )) /* rmii2_refclk */\
+\
+MUX_CFG(mii1_rxd0,			 (RXACTIVE  | PULLUDDIS | MODE(2) )) /* rgmii1_rd0 */\
+MUX_CFG(mii1_rxd1,			 (RXACTIVE  | PULLUDDIS | MODE(2) )) /* rgmii1_rd1 */\
+MUX_CFG(mii1_rxd2,			 (RXACTIVE  | PULLUDDIS | MODE(2) )) /* rgmii1_rd2 */\
+MUX_CFG(mii1_rxd3,			 (RXACTIVE  | PULLUDDIS | MODE(2) )) /* rgmii1_rd3 */\
+\
+MUX_CFG(mii1_rx_clk,		 (RXACTIVE  | PULLUDDIS | MODE(2) )) /* rgmii1_rclk */\
+MUX_CFG(mii1_rx_dv,			 (RXACTIVE  | PULLUDDIS | MODE(2) )) /* rgmii1_rctl */\
+MUX_CFG(mii1_rx_er,			 (RXDISABLE | PULLUDEN  | MODE(7) )) /* gpio3[2] */\
+\
+MUX_CFG(rmii1_ref_clk,		 (RXDISABLE | PULLUDDIS | MODE(7) )) /* gpio0[29] */\
+\
+MUX_CFG(mdio,				 (RXDISABLE | PULLUDDIS | MODE(7) )) /* gpio0[0] */\
+MUX_CFG(mdc,				 (RXDISABLE | PULLUDEN  | MODE(7) )) /* gpio0[1] */\
+\
+MUX_CFG(rtc_pwronrstn,		 (RXACTIVE  | PULLUDDIS | MODE(0) )) /* RTC_porz */\
+\
+MUX_CFG(rtc_kaldo_enn,		 (RXACTIVE  | PULLUDDIS | MODE(0) )) /* ENZ_KALDO_1P8V */\
+\
+MUX_CFG(pmic_power_en,		 (RXDISABLE | PULLUP_EN  | MODE(0) )) /* PMIC_POWER_EN */\
+\
+\
+MUX_CFG(warmrstn,			 (RXACTIVE  | PULLUDDIS | MODE(0) )) /* nRESETIN_OUT */\
+\
+MUX_CFG(extintn,			 (RXACTIVE  | PULLUDDIS | MODE(0) )) /* nNMI */\
+\
+MUX_CFG(ext_wakeup,			 (RXACTIVE  | PULLUDEN  | MODE(0) )) /* EXT_WAKEUP */\
+\
+MUX_CFG(tck,				 (RXACTIVE  | PULLUDDIS | MODE(0) )) /* TCK */\
+MUX_CFG(tdi,				 (RXACTIVE  | PULLUDDIS | MODE(0) )) /* TDI */\
+MUX_CFG(tdo,				 (RXDISABLE | PULLUDDIS | MODE(0) )) /* TDO */\
+MUX_CFG(tms,				 (RXACTIVE  | PULLUDDIS | MODE(0) )) /* TMS */\
+MUX_CFG(trstn,				 (RXACTIVE  | PULLUP_EN  | MODE(0) )) /* nTRST */\
+\
+MUX_CFG(emu0,				 (RXACTIVE  | PULLUP_EN  | MODE(0) )) /* EMU0 */\
+MUX_CFG(emu1,				 (RXACTIVE  | PULLUP_EN  | MODE(0) )) /* EMU1 */\
+\
+MUX_CFG(mcasp0_aclkr,		 (RXDISABLE | PULLUDEN  | MODE(7) )) /* gpio3[18] */\
+MUX_CFG(mcasp0_aclkx,		 (RXDISABLE | PULLUDEN  | MODE(7) )) /* gpio3[14] */\
+\
+MUX_CFG(mcasp0_ahclkr,		 (RXDISABLE | PULLUDEN  | MODE(7) )) /* gpio3[17] */\
+MUX_CFG(mcasp0_ahclkx,		 (RXDISABLE | PULLUDDIS | MODE(7) )) /* gpio3[21] */\
+\
+MUX_CFG(mcasp0_axr0,		 (RXDISABLE | PULLUDEN  | MODE(7) )) /* gpio3[16] */\
+MUX_CFG(mcasp0_axr1,		 (RXDISABLE | PULLUDEN  | MODE(7) )) /* gpio3[20] */\
+\
+MUX_CFG(mcasp0_fsr,			 (RXDISABLE | PULLUDEN  | MODE(7) )) /* gpio3[19] */\
+MUX_CFG(mcasp0_fsx,			 (RXACTIVE  | PULLUP_EN  | MODE(4) )) /* mmc1_sdcd_mux1 */\
+\
+MUX_CFG(ecap0_in_pwm0_out,	 (RXDISABLE | PULLUDEN  | MODE(7) )) /* gpio0[7] */\
+\
+MUX_CFG(xdma_event_intr0,	 (RXACTIVE  | PULLUDDIS | MODE(7) )) /* gpio0[19] */\
+MUX_CFG(xdma_event_intr1,	 (RXDISABLE | PULLUDEN  | MODE(7) )) /* gpio0[20] */\
+
+#endif
--- uboot-custom-orig/arch/arm/dts/ubmc_eval.dts	1970-01-01 08:00:00.000000000 +0800
+++ uboot-custom-silicom/arch/arm/dts/ubmc_eval.dts	2018-08-06 00:43:46.551380397 +0800
@@ -0,0 +1,856 @@
+/*
+ * Copyright (C) 2012 Texas Instruments Incorporated - http://www.ti.com/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+/dts-v1/;
+
+#include "am33xx.dtsi"
+#include <dt-bindings/interrupt-controller/irq.h>
+#include <dt-bindings/pinctrl/am33xx.h>
+
+/ {
+	model = "Silicom ubmc eval";
+	compatible = "silicom ubmc eval", "ti,am33xx";
+
+	chosen {
+		stdout-path = &uart0;
+		tick-timer = &timer2;
+	};
+
+	cpus {
+		cpu@0 {
+			cpu0-supply = <&vdd1_reg>;
+		};
+	};
+
+	memory {
+		device_type = "memory";
+		reg = <0x80000000 0x20000000>; /* 512 MB */
+	};
+
+	vdd1_reg: fixedregulator@0 {
+		compatible = "regulator-fixed";
+		regulator-name = "vdd1_reg";
+		regulator-min-microvolt = <1100000>;
+		regulator-max-microvolt = <1100000>;
+		regulator-boot-on;
+	};
+
+    vmmcsd_fixed: fixedregulator@0 {
+            compatible = "regulator-fixed";
+            regulator-name = "vmmcsd_fixed";
+            regulator-min-microvolt = <3300000>;
+            regulator-max-microvolt = <3300000>;
+    };
+
+	peci: peci {
+		compatible = "simple-bus";
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges = <0x0 0x1e78b000 0x60>;
+
+		peci0: peci-bus@0 {
+			compatible = "peci-smbus";
+			reg = <0x0 0x60>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			interrupts = <15>;
+		};
+	};
+
+
+};
+
+&am33xx_pinmux {
+	pinctrl-names = "default";
+
+	user_leds_s0: user_leds_s0 {
+		pinctrl-single,pins = <
+			0x54 (PIN_OUTPUT_PULLDOWN | MUX_MODE7)	/* gpmc_a5.gpio1_21 */
+			0x58 (PIN_OUTPUT_PULLUP | MUX_MODE7)	/* gpmc_a6.gpio1_22 */
+			0x5c (PIN_OUTPUT_PULLDOWN | MUX_MODE7)	/* gpmc_a7.gpio1_23 */
+			0x60 (PIN_OUTPUT_PULLUP | MUX_MODE7)	/* gpmc_a8.gpio1_24 */
+		>;
+	};
+
+	/* BMC's master for sensors/PROMs */
+	i2c0_pins: pinmux_i2c0_pins {
+		pinctrl-single,pins = <
+			0x188 (PIN_OUTPUT_PULLUP | MUX_MODE0)	/* i2c0_sda.i2c0_sda */
+			0x18c (PIN_INPUT_PULLUP | MUX_MODE0)	/* i2c0_scl.i2c0_scl */
+		>;
+	};
+	
+	/* UART connected to Denverton ttyS0 */
+	uart0_pins: pinmux_uart0_pins {
+		pinctrl-single,pins = <
+			0x168 (PIN_INPUT | MUX_MODE0)	/* uart0_ctsn.uart0_ctsn */
+			0x16C (PIN_OUTPUT | MUX_MODE0)	/* uart0_rtsn.uart0_rtsn */
+		>;
+	};
+
+	/* UART for sol */
+	uart2_pins: pinmux_uart2_pins {
+		pinctrl-single,pins = <
+			0x100 (PIN_INPUT_PULLUP | MUX_MODE3)	/* mmc0_clk.uart2_rxd*/
+			0x104 (PIN_OUTPUT | MUX_MODE3)	/* mmc0_cmd.uart2_txd */
+		>;
+	};
+
+
+	/* I2C1 peci*/
+	i2c1_pins: pinmux_i2c1_pins {
+		pinctrl-single,pins = <
+			0x170 (PIN_INPUT | MUX_MODE3)	/* uart0_rxd.i2c1_scl*/
+			0x174 (PIN_OUTPUT | MUX_MODE3)	/* uart0_txd.i2c1_sda*/
+		>;
+	};
+
+	clkout2_pin: pinmux_clkout2_pin {
+		pinctrl-single,pins = <
+			0x1b4 (PIN_OUTPUT_PULLDOWN | MUX_MODE3)	/* xdma_event_intr1.clkout2 */
+		>;
+	};
+
+	cpsw_default: cpsw_default {
+		pinctrl-single,pins = <
+			/* emac0 using RGMII1 */
+			/* Slave 1 */
+			0x128 (PIN_OUTPUT_PULLDOWN | MUX_MODE2)	   /* mii1_txd0.mii1_txd0	k17  rgmii1_td0 */
+			0x124 (PIN_OUTPUT_PULLDOWN | MUX_MODE2)	   /* mii1_txd1.mii1_txd1	k16  rgmii1_td1 */
+			0x120 (PIN_OUTPUT_PULLDOWN | MUX_MODE2)	   /* mii1_txd2.mii1_txd2	k15  rgmii1_td2 */
+			0x11c (PIN_OUTPUT_PULLDOWN | MUX_MODE2)	   /* mii1_txd3.mii1_txd3	j18  rgmii1_td3 */
+
+			0x12c (PIN_OUTPUT_PULLDOWN | MUX_MODE2)	   /* mii1_txclk.mii1_txclk k18  rgmii1_tclk*/
+			0x114 (PIN_OUTPUT_PULLDOWN | MUX_MODE2)	   /* mii1_txen.mii1_txen	j16  rgmii1_tctl */
+
+			0x140 (PIN_INPUT 		   | MUX_MODE2)    /* mii1_rxd0.mii1_rxd0	m16  rgmii1_rd0 */
+			0x13c (PIN_INPUT 		   | MUX_MODE2)    /* mii1_rxd1.mii1_rxd1	l15  rgmii1_rd1 */
+			0x138 (PIN_INPUT 		   | MUX_MODE2)    /* mii1_rxd2.mii1_rxd2	l16  rgmii1_rd2 */
+			0x134 (PIN_INPUT 		   | MUX_MODE2)    /* mii1_rxd3.mii1_rxd3	l17  rgmii1_rd3 */
+
+			0x130 (PIN_INPUT 		   | MUX_MODE2)    /* mii1_rxclk.mii1_rxclk l18  rgmii1_rclk */
+			0x118 (PIN_INPUT 		   | MUX_MODE2)    /* mii1_rxdv.mii1_rxdv	j17  rgmii1_rctl */
+
+			/* emac1 using RMII2 */
+			0x40 (PIN_OUTPUT_PULLDOWN | MUX_MODE2)	/* gpmc_a0 mii2_txen.rgmii2_tctl */
+			0x44 (PIN_INPUT | MUX_MODE2 )		/* gpmc_a1,		gpio1[17] */
+			0x48 (PIN_OUTPUT_PULLDOWN | MUX_MODE2 )	/* gpmc_a2,		gpio1[18] */
+			0x4c (PIN_OUTPUT_PULLDOWN | MUX_MODE2 )	/* gpmc_a3,		gpio1[19] */
+			0x50 (PIN_OUTPUT_PULLDOWN | MUX_MODE2 )	/* gpmc_a4 mii2_txd1.rgmii2_td1 */
+			0x54 (PIN_OUTPUT_PULLDOWN | MUX_MODE2 )	/* gpmc_a5 mii2_txd0.rgmii2_td0 */
+			0x58 (PIN_OUTPUT_PULLDOWN | MUX_MODE2 )	/* gpmc_a6,		gpio1[22] */
+			0x5c (PIN_INPUT | MUX_MODE2 )		/* gpmc_a7,		gpio1[23] */
+			0x60 (PIN_INPUT | MUX_MODE2 )		/* gpmc_a8,		gpio1[24] */
+			0x64 (PIN_INPUT | MUX_MODE2 )		/* gpmc_a9,		gpio1[25] */
+			0x68 (PIN_INPUT | MUX_MODE2 )		/* gpmc_a10 mii2_rxd1.rgmii2_rd1 */
+			0x6c (PIN_INPUT | MUX_MODE2 )		/* gpmc_a11 mii2_rxd0.rgmii2_rd0 */
+
+		>;
+	};
+
+	cpsw_sleep: cpsw_sleep{
+		pinctrl-single,pins = <
+			/* emac0 using RGMII1 */
+			/* Slave 1 reset value */
+			0x114 (PIN_INPUT_PULLDOWN | MUX_MODE7)
+			0x118 (PIN_INPUT_PULLDOWN | MUX_MODE7)
+			0x11c (PIN_INPUT_PULLDOWN | MUX_MODE7)
+			0x120 (PIN_INPUT_PULLDOWN | MUX_MODE7)
+			0x124 (PIN_INPUT_PULLDOWN | MUX_MODE7)
+			0x128 (PIN_INPUT_PULLDOWN | MUX_MODE7)
+			0x12c (PIN_INPUT_PULLDOWN | MUX_MODE7)
+			0x130 (PIN_INPUT_PULLDOWN | MUX_MODE7)
+			0x134 (PIN_INPUT_PULLDOWN | MUX_MODE7)
+			0x138 (PIN_INPUT_PULLDOWN | MUX_MODE7)
+			0x13c (PIN_INPUT_PULLDOWN | MUX_MODE7)
+			0x140 (PIN_INPUT_PULLDOWN | MUX_MODE7)
+
+			/* emac1 using RMII2 */
+			0x40 (PIN_OUTPUT_PULLDOWN | MUX_MODE7)	/* gpmc_a0 mii2_txen.rgmii2_tctl */
+			0x44 (PIN_INPUT | MUX_MODE7 )		/* gpmc_a1,		gpio1[17] */
+			0x48 (PIN_OUTPUT_PULLDOWN | MUX_MODE7 )	/* gpmc_a2,		gpio1[18] */
+			0x4c (PIN_OUTPUT_PULLDOWN | MUX_MODE7 )	/* gpmc_a3,		gpio1[19] */
+			0x50 (PIN_OUTPUT_PULLDOWN | MUX_MODE7 )	/* gpmc_a4 mii2_txd1.rgmii2_td1 */
+			0x54 (PIN_OUTPUT_PULLDOWN | MUX_MODE7 )	/* gpmc_a5 mii2_txd0.rgmii2_td0 */
+			0x58 (PIN_OUTPUT_PULLDOWN | MUX_MODE7 )	/* gpmc_a6,		gpio1[22] */
+			0x5c (PIN_INPUT | MUX_MODE7 )		/* gpmc_a7,		gpio1[23] */
+			0x60 (PIN_INPUT | MUX_MODE7 )		/* gpmc_a8,		gpio1[24] */
+			0x64 (PIN_INPUT | MUX_MODE7 )		/* gpmc_a9,		gpio1[25] */
+			0x68 (PIN_INPUT | MUX_MODE7 )		/* gpmc_a10 mii2_rxd1.rgmii2_rd1 */
+
+		>;
+	};
+
+	davinci_mdio_default: davinci_mdio_default {
+		pinctrl-single,pins = <
+			/* MDIO */
+			0x148 (PIN_INPUT_PULLUP | SLEWCTRL_FAST | MUX_MODE0)	/* mdio_data.mdio_data */
+			0x14c (PIN_OUTPUT_PULLUP | MUX_MODE0)			/* mdio_clk.mdio_clk */
+		>;
+	};
+
+	davinci_mdio_sleep: davinci_mdio_sleep {
+		pinctrl-single,pins = <
+			/* MDIO reset value */
+			0x148 (PIN_INPUT_PULLDOWN | MUX_MODE7)
+			0x14c (PIN_INPUT_PULLDOWN | MUX_MODE7)
+		>;
+	};
+	/*
+	 * mmc2 is the 8bit eMMC interface, it's 3.3V only, pull ups on board
+	 *
+	 * Note: mmc2 from am33xx.dtsi is mmc1 in all other documentation.  Sigh.
+	 */
+	mmc2_pins: pinmux_mmc2_pins {
+		pinctrl-single,pins = <
+			0x00 (PIN_INPUT | MUX_MODE1) /* gpmc_ad0.mmc1_dat0 */
+			0x04 (PIN_INPUT | MUX_MODE1) /* gpmc_ad1.mmc1_dat1 */
+			0x08 (PIN_INPUT | MUX_MODE1) /* gpmc_ad2.mmc1_dat2 */
+			0x0c (PIN_INPUT | MUX_MODE1) /* gpmc_ad3.mmc1_dat3 */
+			0x10 (PIN_INPUT | MUX_MODE1) /* gpmc_ad4.mmc1_dat4 */
+			0x14 (PIN_INPUT | MUX_MODE1) /* gpmc_ad5.mmc1_dat5 */
+			0x18 (PIN_INPUT | MUX_MODE1) /* gpmc_ad6.mmc1_dat6 */
+			0x1c (PIN_INPUT | MUX_MODE1) /* gpmc_ad7.mmc1_dat7 */
+
+			0x80 (PIN_INPUT | MUX_MODE2) /* gpmc_csn1.mmc1_clk */
+			0x84 (PIN_INPUT  | MUX_MODE2) /* gpmc_csn2.mmc1_cmd */
+
+			0x180 (PIN_INPUT_PULLDOWN  | MUX_MODE1) /* .mmc1_sdwp UART1_RXD */
+			0x194 (PIN_INPUT_PULLUP    | MUX_MODE4) /* .mmc1_sdcd MCASP0_FSX */
+		>;
+	};
+
+	/*boot spi*/
+	spi0_pins: pinmux_spi0_pins {
+		pinctrl-single,pins = <
+			0x150 (PIN_INPUT | MUX_MODE0 )		/* spi0_sclk,		spi0_sclk */
+			0x154 (PIN_INPUT | MUX_MODE0 )		/* spi0_d0,		spi0_d0 */
+			0x158 (PIN_OUTPUT | MUX_MODE0 )		/* spi0_d1,		spi0_d1 */
+			0x15c (PIN_OUTPUT | MUX_MODE0 )		/* spi0_cs0,		spi0_cs0 */
+		>;
+	};
+	/*host spi*/
+	spi1_pins: pinmux_spi1_pins {
+		pinctrl-single,pins = <
+			0x108 (PIN_INPUT | MUX_MODE2)	/* mii1_col spi1_sclk*/
+			0x10c (PIN_INPUT | MUX_MODE2)	/* mii1_crs,		spi1_d0 */
+			0x110 (PIN_OUTPUT | MUX_MODE2)	/* mii1_rxerr,		spi1_d1 */
+			0x144 (PIN_OUTPUT | MUX_MODE2)	/* rmii1_refclk		spi1_cs0 */
+		>;
+	};
+	/* Get a reference clock on xdma_event_intr1 */
+	usb1_pins: usb1_pins {
+		pinctrl-single,pins = <
+			0x2c0 (PIN_OUTPUT_PULLDOWN | MUX_MODE0) /* usb0_drvvbus.usb0_drvvbus */
+		>;
+	};
+	usb2_pins: usb2_pins {
+		pinctrl-single,pins = <
+			0x2c4 (PIN_OUTPUT_PULLDOWN | MUX_MODE0) /* usb0_drvvbus.usb0_drvvbus */
+		>;
+	};
+			/* TODO - Update this once hardware is fixed, right now it's connected to FRU EEPROM mux select */
+	gpio0_pins: gpio0_pins {
+		pinctrl-single,pins = <
+			/* No connect */
+			0xd0  (PIN_INPUT | MUX_MODE7)		/* lcd_data12,		gpio0[8] */
+			0xd4  (PIN_INPUT | MUX_MODE7)		/* lcd_data13,		gpio0[9] */
+			0xd8  (PIN_INPUT | MUX_MODE7)		/* lcd_data14,		gpio0[10] */
+			0xdc  (PIN_INPUT | MUX_MODE7)		/* lcd_data15,		gpio0[11] */
+			0x178 (PIN_INPUT | MUX_MODE3)		/* uart1_ctsn.uart1_ctsn gpio0[12]*/
+			0x17C (PIN_INPUT | MUX_MODE3)		/* uart1_rtsn.uart1_rtsn gpio0[13]*/
+			/* HOST_PLTRST_N */
+			0x184 (PIN_OUTPUT | MUX_MODE7)		/* uart1_txd.uart1_txd gpio0[15]*/
+			0x1b0 (PIN_INPUT | MUX_MODE7)		/* xdma_event_intr0	gpio0[19] */
+			0x1b4 (PIN_INPUT | MUX_MODE7)		/* xdma_event_intr1.clkout2 gpio0[20]*/
+			0x20  (PIN_OUTPUT_PULLDOWN | MUX_MODE7)	/* gpmc_ad8		gpio0[22] */
+			0x24  (PIN_INPUT_PULLUP | MUX_MODE7)	/* gpmc_ad9		gpio0[23] */
+			0x28  (PIN_INPUT_PULLUP | MUX_MODE7)	/* gpmc_ad10		gpio0[26] */
+			0x2c  (PIN_OUTPUT_PULLDOWN | MUX_MODE7)	/* gpmc_ad11		gpio0[27] */
+			0x78 (PIN_INPUT_PULLUP | MUX_MODE7 )	/* gpmc_be1n,		gpio1[28] */
+			0x70 (PIN_INPUT | MUX_MODE2)	/* gpmc_wait0 rgmii2_crs_dv_mux0 gpio0[30]*/
+			0x74  (PIN_OUTPUT | MUX_MODE7)		/* gpmc_wpn		gpio0[31] */
+			/* SYSBOOT_12 */
+			/* SYSBOOT_13 */
+			/* PSU_LEFT_PWRGD */
+			/* PSU_RIGHT_PWRGD */
+			/* SPI_HOST_MUX_EN, leave as PD for Host owns until gpio driver loads */
+			/* BMC_PWRBTN_OUT_N, leave as PU until gpio driver loads */
+/* TODO - Need a new home for HOST_FRU_EEPROM_MUX_SEL since we need to default rmii2_rxer on this pin */
+		>;
+	};
+	gpio1_pins: gpio1_pins {
+		pinctrl-single,pins = <
+			0x30 (PIN_INPUT | MUX_MODE7 ) 		/* gpmc_ad12,		gpio1[12] */
+			0x34 (PIN_INPUT | MUX_MODE7 ) 		/* gpmc_ad13,		gpio1[13] */
+			0x38 (PIN_INPUT_PULLDOWN | MUX_MODE7 ) 	/* gpmc_ad14,		gpio1[14] */
+			0x3c (PIN_INPUT | MUX_MODE7 ) 		/* gpmc_ad15,		gpio1[15] */
+		/* HOST_S45_N */
+		/* GPIO_HOST_1, unused currently */
+		/* HOST_S3_N */
+		/* No connect */
+		/*
+		 * BMC_UART_MUX_SEL, leave as PD for Host owns until gpio driver loads
+		 * 0 = BMC connected to FP, host UART -> BMC SoL UART
+		 * 1 = Host UART -> FP, BMC SoL UART disconnected
+		 */
+		/*
+		 * RS232_CABLE_DETECTED
+		 * 0 = no cable
+		 * 1 = cable attached
+		 */
+		/* FP_RSTBTN_N */
+		/* FP_PWRBTN_N */
+		/* HOST_ERROR_N */
+			0x7c (PIN_INPUT | MUX_MODE7 )		/* gpmc_csn0,		gpio1[29] */
+		>;
+	};
+	gpio2_pins: gpio2_pins {
+		pinctrl-single,pins = <
+			0x88 (PIN_INPUT_PULLDOWN | MUX_MODE7)	/* gpmc_csn3,		gpio2[0] */
+			0x8c (PIN_INPUT | MUX_MODE7)		/* gpmc_clk,		gpio2[1] */
+			0x94 (PIN_OUTPUT | MUX_MODE7 )		/* gpmc_oen_ren,	gpio2[3] */
+			0x90 (PIN_INPUT | MUX_MODE7)		/* gpmc_advn_ale,	gpio2[2] */
+			0x98 (PIN_INPUT | MUX_MODE7)		/* gpmc_wen,		gpio2[4] */
+			0x9c (PIN_INPUT_PULLUP | MUX_MODE7 )	/* gpmc_be0n_cle,	gpio2[5] */
+		/* GPIO_HOST_0 */
+		/* HOST_PROCHOT_N */
+		/* HOST_THERMTRIP_N */
+		/* DYING_GASP_N */
+		/* SYSBOOT[11:0] */
+			0xa4 (PIN_INPUT | MUX_MODE7)		/* lcd_data1,		gpio2[7] */
+			0xa8 (PIN_INPUT | MUX_MODE7)		/* lcd_data2,		gpio2[8] */
+			0xac (PIN_INPUT | MUX_MODE7)		/* lcd_data3,		gpio2[9] */
+			0xb0 (PIN_INPUT | MUX_MODE7)		/* lcd_data4,		gpio2[10] */
+			0xb4 (PIN_INPUT | MUX_MODE7)		/* lcd_data5,		gpio2[11] */
+			0xb8 (PIN_INPUT | MUX_MODE7)		/* lcd_data6,		gpio2[12] */
+			0xbc (PIN_INPUT | MUX_MODE7)		/* lcd_data7,		gpio2[13] */
+			0xc0 (PIN_INPUT | MUX_MODE7)		/* lcd_data8,		gpio2[14] */
+			0xc4 (PIN_INPUT | MUX_MODE7)		/* lcd_data9,		gpio2[15] */
+			0xcc (PIN_INPUT | MUX_MODE7)		/* lcd_data11,		gpio2[17] */
+
+		/*
+		 * BMC_FP_BUTTON_OVERRIDE
+		 * 0 = passthrough button to MB
+		 * 1 = BMC_*BTN_OUTN drives button to MB
+		 */
+			0xe0 (PIN_INPUT_PULLUP | MUX_MODE7 )	/* lcd_vsync,		gpio2[22] */
+			0xe4 (PIN_INPUT_PULLDOWN | MUX_MODE7)	/* lcd_hsync,		gpio2[23] */
+
+		/* TESTPOINT_SPARE */
+			0xe8 (PIN_INPUT_PULLDOWN | MUX_MODE7)	/* lcd_pclk,		gpio2[24] */
+
+		/* BMC_RSTBTN_OUT_N, leave as PU until gpio driver loads */
+			0xec (PIN_INPUT_PULLUP | MUX_MODE7 )	/* lcd_ac_bias_en,	gpio2[25] */
+			0xf0 (PIN_INPUT | MUX_MODE0)	/* mmc0_dat0.mmc0_dat0 gpio2[26]*/
+			0xf4 (PIN_INPUT | MUX_MODE0)	/* mmc0_dat1.mmc0_dat1 gpio2[27]*/
+			0xf8 (PIN_INPUT | MUX_MODE0)	/* mmc0_dat2.mmc0_dat2 gpio2[28]*/
+			0xfc (PIN_INPUT | MUX_MODE0)	/* mmc0_dat3.mmc0_dat3 gpio2[29]*/
+
+		>;
+	};
+
+	gpio3_pins: gpio3_pins {
+		pinctrl-single,pins = <
+		/* No connect */
+			0x190 (PIN_OUTPUT_PULLDOWN | MUX_MODE7)	/* mcasp0_aclkx,	gpio3[14] */
+			0x198 (PIN_OUTPUT_PULLDOWN | MUX_MODE7)	/* mcasp0_axr0,		gpio3[16] */
+			0x1a0 (PIN_OUTPUT_PULLDOWN | MUX_MODE7)	/* mcasp0_aclkr,	gpio3[18] */
+			0x1a4 (PIN_OUTPUT_PULLDOWN | MUX_MODE7)	/* mcasp0_fsr,		gpio3[19] */
+			0x1a8 (PIN_OUTPUT_PULLDOWN | MUX_MODE7)	/* mcasp0_axr1,		gpio3[20] */
+#if 0
+			0x1ac (PIN_OUTPUT | MUX_MODE7 )			/* mcasp0_ahclkx,	gpio3[21] */
+#endif
+		>;
+	};
+
+	gpio_led_pins: pinmux_gpio_led_pins {
+		pinctrl-single,pins = <
+		/* LED_BMC_BOT_GRN_N */
+
+		/* LED_BMC_BOT_BLU_N */
+
+		/* LED_BMC_BOT_RED_N */
+		>;
+	};
+#if 0
+	misc_pins: misc_pins {
+		pinctrl-single,pins = <
+			0x160 (PIN_INPUT | MUX_MODE2)	/* spi0_cs1,		ecap1_in_pwm1_out */
+			0x164 (PIN_INPUT | MUX_MODE0)	/* ecap0_in_pwm0_out	ecap0_in_pwm0_out */
+			0x19c (PIN_OUTPUT_PULLDOWN | MUX_MODE4)	/* mcasp0_ahclkr,	ecap2_in_pwm2_out fan_tach1 */
+			0xa0 (PIN_INPUT | MUX_MODE7)		/* lcd_data0,		ehrpwm2a fan_pwm1 */
+			0xc8 (PIN_INPUT | MUX_MODE7)		/* lcd_data10,		ehrpwm1a fan_pwm0 */
+
+			0x1f8 (PIN_INPUT | MUX_MODE0 )		/* rtc_porz,		RTC_porz */
+			0x204 (PIN_INPUT | MUX_MODE0 )		/* enz_kaldo_1p8v,	ENZ_KALDO_1P8V */
+			0x1f4 (PIN_OUTPUT_PULLUP | MUX_MODE0 )	/* pmic_power_en,	PMIC_POWER_EN */
+			0x1b8 (PIN_INPUT | MUX_MODE0 )		/* nresetin_out,	nRESETIN_OUT */
+			0x1c0 (PIN_INPUT | MUX_MODE0 )		/* nnmi,		nNMI */
+			0x200 (PIN_INPUT_PULLDOWN | MUX_MODE0 )	/* ext_wakeup,		EXT_WAKEUP */
+			0x1dc (PIN_INPUT | MUX_MODE0 )		/* tck,			TCK */
+			0x1d4 (PIN_INPUT | MUX_MODE0 )		/* tdi,			TDI */
+			0x1d8 (PIN_OUTPUT | MUX_MODE0 )		/* tdo,			TDO */
+			0x1d0 (PIN_INPUT | MUX_MODE0 )		/* tms,			TMS */
+			0x1e0 (PIN_INPUT_PULLUP| MUX_MODE0 )	/* ntrst,		nTRST */
+			0x1e4 (PIN_INPUT_PULLUP| MUX_MODE0 )	/* emu0,		EMU0 */
+			0x1e8 (PIN_INPUT_PULLUP| MUX_MODE0 )	/* emu1,		EMU1 */
+		>;
+	};
+#endif
+	/*
+	 * mmc1 is the 4bit SD card interface, SDCD and SDWP are not connected to the SD cage
+	 *
+	 * Note: mmc1 from am33xx.dtsi is mmc0 in all other documentation.  Sigh.
+	 */
+	mmc1_pins: pinmux_mmc1_pins {
+		pinctrl-single,pins = <
+#if 1
+			0x194 (PIN_INPUT_PULLDOWN | MUX_MODE7)	/* mcasp0_fsx mmc1_sdcd_mux1 */
+#endif
+		>;
+	};
+
+
+};
+
+&uart0 {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&uart0_pins>;
+
+};
+
+&uart2 {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&uart2_pins>;
+};
+
+&usb {
+	status = "okay";
+};
+
+&usb_ctrl_mod {
+	status = "okay";
+};
+
+&usb0_phy {
+	status = "okay";
+};
+
+&usb1_phy {
+	status = "okay";
+};
+
+&usb0 {
+	status = "okay";
+	dr_mode = "host";
+};
+
+&usb1 {
+	status = "okay";
+	dr_mode = "peripheral";
+};
+
+&cppi41dma  {
+	status = "okay";
+};
+
+
+&elm {
+	status = "okay";
+};
+
+&i2c0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&i2c0_pins>;
+
+	status = "okay";
+	clock-frequency = <400000>;
+
+	tps: tps@24 {
+		reg = <0x24>;
+	};
+
+};
+
+&i2c1 {
+	status = "okay";
+	clock-frequency = <400000>;
+		smbus_peci_r: smbus-peci@4b {
+			compatible = "smbus-peci";
+			reg = <0x4b>;
+		};
+		smbus_peci_w: smbus-peci@4c {
+			compatible = "smbus-peci";
+			reg = <0x4c>;
+			peci-bus@0 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+
+				peci-cputemp@cpu0 {
+					compatible = "intel,peci-cputemp";
+					reg = <0x30>;
+				};
+			};
+		};
+};
+
+/* /include/ "tps65217.dtsi" */
+
+&tps {
+	/*
+	 * Configure pmic to enter OFF-state instead of SLEEP-state ("RTC-only
+	 * mode") at poweroff.  Most BeagleBone versions do not support RTC-only
+	 * mode and risk hardware damage if this mode is entered.
+	 *
+	 * For details, see linux-omap mailing list May 2015 thread
+	 *	[PATCH] ARM: dts: am335x-bone* enable pmic-shutdown-controller
+	 * In particular, messages:
+	 *	http://www.spinics.net/lists/linux-omap/msg118585.html
+	 *	http://www.spinics.net/lists/linux-omap/msg118615.html
+	 *
+	 * You can override this later with
+	 *	&tps {  /delete-property/ ti,pmic-shutdown-controller;  }
+	 * if you want to use RTC-only mode and made sure you are not affected
+	 * by the hardware problems. (Tip: double-check by performing a current
+	 * measurement after shutdown: it should be less than 1 mA.)
+	 */
+	ti,pmic-shutdown-controller;
+
+/*	not_used { */
+	regulators {
+		dcdc1_reg: regulator@0 {
+			regulator-name = "vdds_dpr";
+			regulator-always-on;
+		};
+
+			/* VDD_MPU voltage limits 0.95V - 1.26V with +/-4% tolerance */
+		dcdc2_reg: regulator@1 {
+			regulator-name = "vdd_mpu";
+			regulator-min-microvolt = <925000>;
+			regulator-max-microvolt = <1325000>;
+			regulator-boot-on;
+			regulator-always-on;
+		};
+
+			/* VDD_CORE voltage limits 0.95V - 1.1V with +/-4% tolerance */
+/*
+		dcdc3_reg: regulator@2 {
+			regulator-name = "vdd_core";
+			regulator-min-microvolt = <925000>;
+			regulator-max-microvolt = <1150000>;
+			regulator-boot-on;
+			regulator-always-on;
+		};
+*/
+/*
+		ldo1_reg: regulator@3 {
+			regulator-name = "vio,vrtc,vdds";
+			regulator-always-on;
+		};
+
+		ldo2_reg: regulator@4 {
+			regulator-name = "vdd_3v3aux";
+			regulator-always-on;
+		};
+
+		ldo3_reg: regulator@5 {
+			regulator-name = "vdd_1v8";
+			regulator-always-on;
+		};
+
+		ldo4_reg: regulator@6 {
+			regulator-name = "vdd_3v3a";
+			regulator-always-on;
+		};
+*/
+	};
+};
+
+/*
+ * SPI0 is connected to a W25Q64 or equivalent SPI flash
+ */
+&spi0 {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&spi0_pins>;
+
+	/* BIOS SPI flash */
+	spi-flash@0 {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		label = "BIOS";
+		compatible = "jedec,spi-nor";
+		reg = <0>;
+		/* Limit to 25MHz, there are a number of muxes on the bus */
+		spi-max-frequency = <25000000>;
+		m25p,fast-read;
+	};
+};
+
+&spi1 {
+	status = "okay";
+};
+
+/*
+ * emac0 is RGMII interface to port 0 of the Marvell Peridot switch
+ *
+ * The TI part requires external delay of the clk relative to the data lines
+ *
+ * For receive (input to the AM3352) the waveform must look like:
+ *           _____       _
+ * RCLK    _/     \_____/
+ *         ____ _____ ____
+ * RD/RCTL ____X_____X____
+ *
+ *
+ * For transmit (output from the AM3352) the waveform looks like:
+ *           _____       _
+ * TCLK    _/     \_____/
+ *         _ _____ _____ _
+ * TD/TCTL _X_____X_____X_
+ *
+ */
+&cpsw_emac0 {
+	phy_id = <&davinci_mdio>, <1>;
+	phy-mode = "rgmii-txid";
+/*	dual_emac_res_vlan = <1>;*/
+/*	fixed-link {
+		   speed = <1000>;
+		   full-duplex;
+	};*/
+};
+
+&cpsw_emac1 {
+	phy_id = <&davinci_mdio>, <2>;
+	phy-mode = "rgmii-txid";
+/*	dual_emac_res_vlan = <2>;*/
+};
+
+&mac {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&cpsw_default>;
+	pinctrl-1 = <&cpsw_sleep>;
+	dual_emac = <1>;
+	active_slave = <1>;
+	status = "okay";
+};
+
+&davinci_mdio {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&davinci_mdio_default>;
+	pinctrl-1 = <&davinci_mdio_sleep>;
+	txen-skew-ps = <180>;
+	txd0-skew-ps = <180>;
+	txd1-skew-ps = <180>;
+	txd2-skew-ps = <180>;
+	txd3-skew-ps = <180>;
+	txc-skew-ps  = <1860>;
+	status = "okay";
+};
+
+
+&mmc2 {
+	status = "okay";
+	bus-width = <0x8>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&mmc2_pins>;
+
+	max-frequency = <96000000>;
+	vmmc-supply = <&vmmcsd_fixed>;
+	vqmmc-supply = <&vmmcsd_fixed>;
+/*	no-1-8-v;*/
+	cap-mmc-highspeed;
+	no-sdio;
+	no-sd;
+	non-removable;
+};
+
+&aes {
+	status = "okay";
+};
+
+&sham {
+	status = "okay";
+};
+
+
+/*gpio names not in use
+SMB_PECI_DATA
+SMB_PECI_CLK
+
+BMC_FP_BUTTON_OVERRIDE
+BMC_UART_MUX_SEL
+HOST_FRU_EEPROM_MUX_SEL
+RS232_CABLE_DETECTED
+LED_BMC_BOT_GRN_N
+BMC_RSTBTN_OUT_N - GPIO_HOST_6
+BMC_PWRBTN_OUT_N - GPIO_HOST_7
+DYING_GASP_N
+W_DIABLE_WWAN_N
+SYSBOOT_SD_N
+LED_BMC_BOT_BLU_N
+LED_BMC_BOT_RED_N
+*/
+&gpio0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&gpio0_pins>;
+
+	gpio-line-names =
+		"", /*  0 */
+		"", /*  1 */
+		"", /*  2 */
+		"", /*  3 */
+		"", /*  4 */
+		"", /*  5 */
+		"", /*  6 */
+		"", /*  7 */
+		"", /*  8 */
+		"", /*  9 */
+		"", /* 10 */
+		"", /* 11 */
+		"", /* 12 */
+		"", /* 13 */
+		"", /* 14 */
+		"FP_RSTBTN_N", /* 15 */
+		"", /* 16 */
+		"", /* 17 */
+		"", /* 18 */
+		"PSU_4_PWRGD", /* 19 */
+		"BMC_PWRBTN_OUT_N", /* 20 */
+		"", /* 21 */
+		"", /* 22 */
+		"", /* 23 */
+		"", /* 24 */
+		"", /* 25 */
+		"", /* 26 */
+		"", /* 27 */
+		"", /* 28 */
+		"", /* 29 */
+		"HOST_THERMTRIP_N", /* 30 */
+		"GPIO_HOST_2"; /* 31 */
+};
+
+&gpio1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&gpio1_pins>;
+
+	gpio-line-names =
+		"", /*  0 */
+		"", /*  1 */
+		"", /*  2 */
+		"", /*  3 */
+		"", /*  4 */
+		"", /*  5 */
+		"", /*  6 */
+		"", /*  7 */
+		"", /*  8 */
+		"", /*  9 */
+		"", /* 10 */
+		"", /* 11 */
+		"GPIO_HOST_3", /* 12 */
+		"", /* 13 */
+		"", /* 14 */
+		"", /* 15 */
+		"", /* 16 */
+		"", /* 17 */
+		"", /* 18 */
+		"", /* 19 */
+		"", /* 20 */
+		"", /* 21 */
+		"", /* 22 */
+		"", /* 23 */
+		"", /* 24 */
+		"", /* 25 */
+		"", /* 26 */
+		"", /* 27 */
+		"GPIO_HOST_5", /* 28 */
+		"", /* 29 */
+		"", /* 30 */
+		""; /* 31 */
+};
+
+&gpio2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&gpio2_pins>;
+
+	gpio-line-names =
+		"", /*  0 */
+		"", /*  1 */
+		"HOST_S3_N", /*  2 */
+		"HOST_ERROR_N", /*  3 */
+		"GPIO_HOST_0", /*  4 */
+		"HOST_S5_N", /*  5 */
+		"", /*  6 */
+		"", /*  7 */
+		"", /*  8 */
+		"", /*  9 */
+		"", /* 10 */
+		"", /* 11 */
+		"", /* 12 */
+		"", /* 13 */
+		"", /* 14 */
+		"", /* 15 */
+		"", /* 16 */
+		"", /* 17 */
+		"", /* 18 */
+		"", /* 19 */
+		"", /* 20 */
+		"", /* 21 */
+		"HOST_PLTRST_N", /* 22 */
+		"HOST_S4_N", /* 23 */
+		"TESTPOINT_SPARE", /* 24 */
+		"GPIO_HOST_1", /* 25 */
+		"GPIO_HOST_4", /* 26 */
+		"FP_PWRBTN_N", /* 27 */
+		"HOST_PROCHOT_N", /* 28 */
+		"", /* 29 */
+		"", /* 30 */
+		""; /* 31 */
+};
+
+&gpio3 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&gpio3_pins>;
+
+	gpio-line-names =
+		"", /*  0 */
+		"", /*  1 */
+		"", /*  2 */
+		"", /*  3 */
+		"", /*  4 */
+		"", /*  5 */
+		"", /*  6 */
+		"", /*  7 */
+		"", /*  8 */
+		"", /*  9 */
+		"", /* 10 */
+		"", /* 11 */
+		"", /* 12 */
+		"", /* 13 */
+		"PSU_LEFT_PWRGD", /* 14 */
+		"", /* 15 */
+		"SPI_HOST_MUX_EN", /* 16 */
+		"", /* 17 */
+		"PSU_RIGHT_PWRGD", /* 18 */
+		"BMC_RSTBTN_OUT_N", /* 19 */
+		"", /* 20 */
+		"PSU_3_PWRGD", /* 21 */
+		"", /* 22 */
+		"", /* 23 */
+		"", /* 24 */
+		"", /* 25 */
+		"", /* 26 */
+		"", /* 27 */
+		"", /* 28 */
+		"", /* 29 */
+		"", /* 30 */
+		""; /* 31 */
+};
+
