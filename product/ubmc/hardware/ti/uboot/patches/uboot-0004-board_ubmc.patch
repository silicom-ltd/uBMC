diff -uNr uboot-custom-orig/board/silicom/ubmc335x/board.c uboot-custom-silicom/board/silicom/ubmc335x/board.c
--- uboot-custom-orig/board/silicom/ubmc335x/board.c	1970-01-01 08:00:00.000000000 +0800
+++ uboot-custom-silicom/board/silicom/ubmc335x/board.c	2019-01-17 16:42:27.581014446 +0800
@@ -0,0 +1,742 @@
+/*
+ * board.c
+ *
+ * Board functions for TI AM335X based boards
+ *
+ * Copyright (C) 2011, Texas Instruments, Incorporated - http://www.ti.com/
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <errno.h>
+#include <spl.h>
+#include <serial.h>
+#include <asm/arch/cpu.h>
+#include <asm/arch/hardware.h>
+#include <asm/arch/omap.h>
+#include <asm/arch/ddr_defs.h>
+#include <asm/arch/clock.h>
+#include <asm/arch/clk_synthesizer.h>
+#include <asm/arch/gpio.h>
+#include <asm/arch/mmc_host_def.h>
+#include <asm/arch/sys_proto.h>
+#include <asm/arch/mem.h>
+#include <asm/io.h>
+#include <asm/emif.h>
+#include <asm/gpio.h>
+#include <asm/omap_sec_common.h>
+#include <i2c.h>
+#include <miiphy.h>
+#include <cpsw.h>
+#include <power/tps65217.h>
+#include <power/tps65910.h>
+#include <environment.h>
+#include <watchdog.h>
+#include <environment.h>
+#include <libfdt.h>
+#include <fdt_support.h>
+
+#include "mmc.h"
+#include "malloc.h"
+//#include "board_detect.h"
+#include "board.h"
+
+DECLARE_GLOBAL_DATA_PTR;
+
+/* GPIO that controls power to DDR on EVM-SK */
+#define GPIO_TO_PIN(bank, gpio)		(32 * (bank) + (gpio))
+#define GPIO_DDR_VTT_EN		GPIO_TO_PIN(0, 7)
+#define ICE_GPIO_DDR_VTT_EN	GPIO_TO_PIN(0, 18)
+#define GPIO_PR1_MII_CTRL	GPIO_TO_PIN(3, 4)
+#define GPIO_MUX_MII_CTRL	GPIO_TO_PIN(3, 10)
+#define GPIO_FET_SWITCH_CTRL	GPIO_TO_PIN(0, 7)
+#define GPIO_PHY_RESET		GPIO_TO_PIN(2, 5)
+#define GPIO_ETH0_MODE		GPIO_TO_PIN(0, 11)
+#define GPIO_ETH1_MODE		GPIO_TO_PIN(1, 26)
+
+static struct ctrl_dev *cdev = (struct ctrl_dev *)CTRL_DEVICE_BASE;
+
+#define GPIO0_RISINGDETECT	(AM33XX_GPIO0_BASE + OMAP_GPIO_RISINGDETECT)
+#define GPIO1_RISINGDETECT	(AM33XX_GPIO1_BASE + OMAP_GPIO_RISINGDETECT)
+
+#define GPIO0_IRQSTATUS1	(AM33XX_GPIO0_BASE + OMAP_GPIO_IRQSTATUS1)
+#define GPIO1_IRQSTATUS1	(AM33XX_GPIO1_BASE + OMAP_GPIO_IRQSTATUS1)
+
+#define GPIO0_IRQSTATUSRAW	(AM33XX_GPIO0_BASE + 0x024)
+#define GPIO1_IRQSTATUSRAW	(AM33XX_GPIO1_BASE + 0x024)
+
+#ifndef CONFIG_DM_SERIAL
+struct serial_device *default_serial_console(void)
+{
+	return &eserial1_device;
+}
+#endif
+
+#ifndef CONFIG_SKIP_LOWLEVEL_INIT
+
+#define HYNIX_UBMC_EMIF_SDCFG			0x60C04AB2
+#define HYNIX_UBMC_RATIO				0x40
+#define HYNIX_UBMC_ZQ_INVERT_CLKOUT		0x1
+#define HYNIX_UBMC_EMIF_DDR_PHY_CTRL	0x100007
+
+static struct emif_regs ddr3_emif_reg_data_hynix_ubmc = {
+        .sdram_config = HYNIX_UBMC_EMIF_SDCFG,
+        .ref_ctrl = HYNIX_UBMC_RATIO,
+        .sdram_tim1 = 0x0aaad4ef,
+        .sdram_tim2 = 0x5e6c7ffc,
+        .sdram_tim3 = 0x501f868f,
+        .zq_config = HYNIX_UBMC_ZQ_INVERT_CLKOUT,
+		.emif_ddr_phy_ctlr_1 = HYNIX_UBMC_EMIF_DDR_PHY_CTRL,
+};
+
+#if 1
+#define HYNIX_UBMC_RD_DQS			0x3B
+#define HYNIX_UBMC_WR_DQS			0x3C
+#define HYNIX_UBMC_PHY_FIFO_WE		0xA5
+#define HYNIX_UBMC_PHY_WR_DATA		0x74
+#ifdef CONFIG_TARGET_UBMC335X
+#define HYNIX_UBMC_1_RD_DQS			0x3B
+#define HYNIX_UBMC_1_WR_DQS			0x3C
+#define HYNIX_UBMC_1_PHY_FIFO_WE		0xA5
+#define HYNIX_UBMC_1_PHY_WR_DATA		0x74
+#endif
+#else
+#define HYNIX_UBMC_RD_DQS			0x00
+#define HYNIX_UBMC_WR_DQS			0x00
+#define HYNIX_UBMC_PHY_FIFO_WE		0x74
+#define HYNIX_UBMC_PHY_WR_DATA		0xBB
+
+#define HYNIX_UBMC_1_RD_DQS			0x00
+#define HYNIX_UBMC_1_WR_DQS			0x00
+#define HYNIX_UBMC_1_PHY_FIFO_WE	0x74
+#define HYNIX_UBMC_1_PHY_WR_DATA	0xBB
+#endif
+
+static const struct ddr_data ddr3_data_hynix_ubmc = {
+	.datardsratio0 = HYNIX_UBMC_RD_DQS,
+	.datawdsratio0 = HYNIX_UBMC_WR_DQS,
+	.datafwsratio0 = HYNIX_UBMC_PHY_FIFO_WE,
+	.datawrsratio0 = HYNIX_UBMC_PHY_WR_DATA,
+#ifdef CONFIG_TARGET_UBMC335X
+	.datardsratio1 = HYNIX_UBMC_1_RD_DQS,
+	.datawdsratio1 = HYNIX_UBMC_1_WR_DQS,
+	.datafwsratio1 = HYNIX_UBMC_1_PHY_FIFO_WE,
+	.datawrsratio1 = HYNIX_UBMC_1_PHY_WR_DATA,
+
+#endif
+};
+
+#if 1
+#define HYNIX_UBMC_CMD_RATIO			0x80
+#define HYNIX_UBMC_INVERT_CLKOUT		0x0
+#else
+#define HYNIX_UBMC_CMD_RATIO			0x100
+#define HYNIX_UBMC_INVERT_CLKOUT		0x1
+#endif
+static const struct cmd_control ddr3_cmd_ctrl_data_hynix_ubmc = {
+	.cmd0csratio = HYNIX_UBMC_CMD_RATIO,
+	.cmd0iclkout = HYNIX_UBMC_INVERT_CLKOUT,
+
+	.cmd1csratio = HYNIX_UBMC_CMD_RATIO,
+	.cmd1iclkout = HYNIX_UBMC_INVERT_CLKOUT,
+
+	.cmd2csratio = HYNIX_UBMC_CMD_RATIO,
+	.cmd2iclkout = HYNIX_UBMC_INVERT_CLKOUT,
+};
+
+#ifdef CONFIG_SPL_OS_BOOT
+int spl_start_uboot(void)
+{
+	/* break into full u-boot on 'c' */
+	if (serial_tstc() && serial_getc() == 'c')
+		return 1;
+
+#ifdef CONFIG_SPL_ENV_SUPPORT
+	env_init();
+	env_relocate_spec();
+	if (getenv_yesno("boot_os") != 1)
+		return 1;
+#endif
+
+	return 0;
+}
+#endif
+
+#if 1
+#define UBMC_DDR_303
+#else
+#define UBMC_DDR_400
+#endif
+
+const struct dpll_params *get_dpll_ddr_params(void)
+{
+	int ind = get_sys_clk_index();
+#ifndef NO_SILC_MOD
+#ifdef UBMC_DDR_400
+	return &dpll_ddr3_400MHz[ind];
+#else
+	return &dpll_ddr3_303MHz[ind];
+#endif
+#endif
+}
+
+const struct dpll_params *get_dpll_mpu_params(void)
+{
+	int ind = get_sys_clk_index();
+	int freq = am335x_get_efuse_mpu_max_freq(cdev);
+
+	switch (freq) {
+	case MPUPLL_M_1000:
+		return &dpll_mpu_opp[ind][5];
+	case MPUPLL_M_800:
+		return &dpll_mpu_opp[ind][4];
+	case MPUPLL_M_720:
+		return &dpll_mpu_opp[ind][3];
+	case MPUPLL_M_600:
+		return &dpll_mpu_opp[ind][2];
+	case MPUPLL_M_500:
+		return &dpll_mpu_opp100;
+	case MPUPLL_M_300:
+		return &dpll_mpu_opp[ind][0];
+	}
+
+	return &dpll_mpu_opp[ind][0];
+}
+
+void scale_vcores_generic(int freq)
+{
+	int sil_rev, mpu_vdd;
+
+	/*
+	 * The GP EVM, IDK and EVM SK use a TPS65910 PMIC.  For all
+	 * MPU frequencies we support we use a CORE voltage of
+	 * 1.10V.  For MPU voltage we need to switch based on
+	 * the frequency we are running at.
+	 */
+	if (i2c_probe(TPS65910_CTRL_I2C_ADDR))
+		return;
+
+	/*
+	 * Depending on MPU clock and PG we will need a different
+	 * VDD to drive at that speed.
+	 */
+	sil_rev = readl(&cdev->deviceid) >> 28;
+	mpu_vdd = am335x_get_tps65910_mpu_vdd(sil_rev, freq);
+
+	/* Tell the TPS65910 to use i2c */
+	tps65910_set_i2c_control();
+
+	/* First update MPU voltage. */
+	if (tps65910_voltage_update(MPU, mpu_vdd))
+		return;
+
+	/* Second, update the CORE voltage. */
+	if (tps65910_voltage_update(CORE, TPS65910_OP_REG_SEL_1_1_0))
+		return;
+
+}
+
+void gpi2c_init(void)
+{
+	/* When needed to be invoked prior to BSS initialization */
+	static bool first_time = true;
+
+	if (first_time) {
+		enable_i2c0_pin_mux();
+		i2c_init(CONFIG_SYS_OMAP24_I2C_SPEED,
+			 CONFIG_SYS_OMAP24_I2C_SLAVE);
+		first_time = false;
+	}
+}
+
+void scale_vcores(void)
+{
+	int freq;
+
+	gpi2c_init();
+	freq = am335x_get_efuse_mpu_max_freq(cdev);
+
+	scale_vcores_generic(freq);
+}
+
+void set_uart_mux_conf(void)
+{
+#if CONFIG_CONS_INDEX == 1
+	enable_uart0_pin_mux();
+#elif CONFIG_CONS_INDEX == 2
+	enable_uart1_pin_mux();
+#elif CONFIG_CONS_INDEX == 3
+	enable_uart2_pin_mux();
+#elif CONFIG_CONS_INDEX == 4
+	enable_uart3_pin_mux();
+#elif CONFIG_CONS_INDEX == 5
+	enable_uart4_pin_mux();
+#elif CONFIG_CONS_INDEX == 6
+	enable_uart5_pin_mux();
+#endif
+}
+
+void set_mux_conf_regs(void)
+{
+	enable_board_pin_mux();
+}
+
+const struct ctrl_ioregs ioregs_ubmc = {
+	.cm0ioctl		= 0x18B,
+	.cm1ioctl		= 0x18B,
+	.cm2ioctl		= 0x18B,
+	.dt0ioctl		= 0x18B,
+	.dt1ioctl		= 0x18B,
+};
+
+void sdram_init(void)
+{
+#ifndef NO_SILC_MOD
+	//the 400 here is of no use at all.
+#ifdef UBMC_DDR_400
+	printf("Configure ddr 400\n");
+#else
+	printf("Configure ddr 303\n");
+#endif
+	printf("\temif_regs\n");
+	printf("\t\tsdram_config   %08x\n", ddr3_emif_reg_data_hynix_ubmc.sdram_config);
+	printf("\t\tref_ctrl       %08x\n", ddr3_emif_reg_data_hynix_ubmc.ref_ctrl);
+	printf("\t\tsdram_tim1     %08x\n", ddr3_emif_reg_data_hynix_ubmc.sdram_tim1);
+	printf("\t\tsdram_tim2     %08x\n", ddr3_emif_reg_data_hynix_ubmc.sdram_tim2);
+	printf("\t\tsdram_tim3     %08x\n", ddr3_emif_reg_data_hynix_ubmc.sdram_tim3);
+	printf("\t\tzq_config      %08x\n", ddr3_emif_reg_data_hynix_ubmc.zq_config);
+	printf("\t\tddr_phy_ctrl_1 %08x\n", ddr3_emif_reg_data_hynix_ubmc.emif_ddr_phy_ctlr_1);
+	printf("\tio_regs\n");
+	printf("\t\tall ioregs     %08x\n", ioregs_ubmc.cm0ioctl);
+	printf("\tcmd_ctrl_regs\n");
+	printf("\t\tcmd0-2csratio  %08lx\n", ddr3_cmd_ctrl_data_hynix_ubmc.cmd0csratio);
+	printf("\t\tcmd0-2iclkout  %08lx\n", ddr3_cmd_ctrl_data_hynix_ubmc.cmd0iclkout);
+	printf("\tdata_reg\n");
+	printf("\t\trdsratio0      %08lx\n", ddr3_data_hynix_ubmc.datardsratio0);
+	printf("\t\twdsratio0      %08lx\n", ddr3_data_hynix_ubmc.datawdsratio0);
+	printf("\t\tfwsratio0      %08lx\n", ddr3_data_hynix_ubmc.datafwsratio0);
+	printf("\t\twrsratio0      %08lx\n", ddr3_data_hynix_ubmc.datawrsratio0);
+	printf("\t\trdsratio1      %08lx\n", ddr3_data_hynix_ubmc.datardsratio1);
+	printf("\t\twdsratio1      %08lx\n", ddr3_data_hynix_ubmc.datawdsratio1);
+	printf("\t\tfwsratio1      %08lx\n", ddr3_data_hynix_ubmc.datafwsratio1);
+	printf("\t\twrsratio1      %08lx\n", ddr3_data_hynix_ubmc.datawrsratio1);
+	
+#ifdef UBMC_DDR_400
+	config_ddr(400, &ioregs_ubmc,
+#else
+	config_ddr(303, &ioregs_ubmc,
+#endif
+		   &ddr3_data_hynix_ubmc,
+		   &ddr3_cmd_ctrl_data_hynix_ubmc,
+		   &ddr3_emif_reg_data_hynix_ubmc, 0);
+	emif_ddr_reg_dump(0);
+#endif
+}
+#endif
+
+#if !defined(CONFIG_SPL_BUILD) || \
+	(defined(CONFIG_SPL_ETH_SUPPORT) && defined(CONFIG_SPL_BUILD))
+static void request_and_set_gpio(int gpio, char *name, int val)
+{
+	int ret;
+
+	ret = gpio_request(gpio, name);
+	if (ret < 0) {
+		printf("%s: Unable to request %s\n", __func__, name);
+		return;
+	}
+
+	ret = gpio_direction_output(gpio, 0);
+	if (ret < 0) {
+		printf("%s: Unable to set %s  as output\n", __func__, name);
+		goto err_free_gpio;
+	}
+
+	gpio_set_value(gpio, val);
+
+	return;
+
+err_free_gpio:
+	gpio_free(gpio);
+}
+
+#define REQUEST_AND_SET_GPIO(N)	request_and_set_gpio(N, #N, 1);
+#define REQUEST_AND_CLR_GPIO(N)	request_and_set_gpio(N, #N, 0);
+
+/**
+ * RMII mode on ICEv2 board needs 50MHz clock. Given the clock
+ * synthesizer With a capacitor of 18pF, and 25MHz input clock cycle
+ * PLL1 gives an output of 100MHz. So, configuring the div2/3 as 2 to
+ * give 50MHz output for Eth0 and 1.
+ */
+static struct clk_synth cdce913_data = {
+	.id = 0x81,
+	.capacitor = 0x90,
+	.mux = 0x6d,
+	.pdiv2 = 0x2,
+	.pdiv3 = 0x2,
+};
+#endif
+
+#if !defined(CONFIG_SPL_BUILD) || \
+	(defined(CONFIG_SPL_ETH_SUPPORT) && defined(CONFIG_SPL_BUILD)) || \
+	(defined(CONFIG_OF_LIBFDT) && defined(CONFIG_OF_BOARD_SETUP))
+
+static bool eth0_is_mii;
+static bool eth1_is_mii;
+#endif
+
+/*
+ * Basic board specific setup.  Pinmux has been handled already.
+ */
+int board_init(void)
+{
+	printf("board_init ubmc335x\n");
+#if defined(CONFIG_HW_WATCHDOG)
+	hw_watchdog_init();
+#endif
+
+	gd->bd->bi_boot_params = CONFIG_SYS_SDRAM_BASE + 0x100;
+#if defined(CONFIG_NOR) || defined(CONFIG_NAND)
+	gpmc_init();
+#endif
+
+	return 0;
+}
+
+#if defined(CONFIG_GENERIC_MMC)
+#define boot_prn(fmt, ...)	printf("====\nBOOT:"fmt"\n====\n", ## __VA_ARGS__)
+int board_mmc_read_flag(struct blk_desc * mmc_blk_dev, unsigned long addr, char* ret_flag)
+{
+	unsigned long blksz=mmc_blk_dev->blksz;
+	unsigned long start_blk=addr/blksz;
+	char* tmp_buf;
+	int ret;
+	if ((start_blk*mmc_blk_dev->blksz) != addr)
+	{
+		boot_prn("Error: Unaligned mmc read, addr %lx, blksz %lx", addr, blksz);
+		return -EINVAL;
+	}
+	tmp_buf = malloc(mmc_blk_dev->blksz*2);
+	if(tmp_buf == NULL)
+	{
+		boot_prn("Error: not enough memory\n");
+		return -ENOMEM;
+	}
+	ret = blk_dread(mmc_blk_dev, start_blk, 1, tmp_buf);
+	if(ret!=1)
+	{
+		boot_prn("Error: MMC read returned %d, addr %lx, blksz %lx", ret, addr, blksz);
+		free(tmp_buf);
+		return -EINVAL;
+	}
+	*ret_flag = tmp_buf[0];
+	free(tmp_buf);
+	
+	return 0;
+}
+
+int board_mmc_write_flag(struct blk_desc * mmc_blk_dev, unsigned long addr, char wr_flag)
+{
+	unsigned long blksz=mmc_blk_dev->blksz;
+	unsigned long start_blk=addr/blksz;
+	int ret;
+	char* tmp_buf;
+	if ((start_blk*mmc_blk_dev->blksz) != addr)
+	{
+		boot_prn("Error: Unaligned mmc write, addr %lx, blksz %lx", addr, blksz);
+		return -EINVAL;
+	}
+	tmp_buf = malloc(mmc_blk_dev->blksz*2);
+	if(tmp_buf == NULL)
+	{
+		boot_prn("Error: not enough memory\n");
+		return -ENOMEM;
+	}
+	memset(tmp_buf, 0, blksz);
+	tmp_buf[0] = wr_flag;
+	ret = blk_dwrite(mmc_blk_dev, start_blk, 1, tmp_buf);
+	if(ret!=1)
+	{
+		boot_prn("Error: MMC write returned %d, addr %lx, blksz %lx", ret, addr, blksz);
+		free(tmp_buf);
+		return -EINVAL;
+	}
+	free(tmp_buf);
+	return 0;
+}
+
+
+#define SILC_FLAG_INDEX_BOOT     0
+#define SILC_FLAG_INDEX_UPGRADE  1
+
+#define UBMC_BOOT_FLAG_ADDR			0x10000
+#define UBMC_UPGRADE_FLAG_ADDR			0x11000
+static struct mmc *init_mmc_device(int dev, bool force_init)
+{
+	struct mmc *mmc;
+	mmc = find_mmc_device(dev);
+	if (!mmc) {
+		boot_prn("no mmc device at slot %x\n", dev);
+		return NULL;
+	}
+
+	if (force_init)
+		mmc->has_init = 0;
+	if (mmc_init(mmc))
+		return NULL;
+	return mmc;
+}
+
+#include "../silicom_autoboot.c"
+int board_get_boot_info(void)
+{
+	//ubmc eval has only one mmc device
+	return silicom_autoboot_mmc(1, 0);
+}
+
+#endif
+
+#ifdef CONFIG_BOARD_LATE_INIT
+void __maybe_unused set_board_info_env(char *name)
+{
+	setenv("board_name", name);
+	setenv("board_rev", "0.9");
+	setenv("board_serial", "XXXX-XXXXX");
+}
+
+int board_late_init(void)
+{
+#if !defined(CONFIG_SPL_BUILD)
+	uint8_t mac_addr[6];
+	uint32_t mac_hi, mac_lo;
+#endif
+
+#ifdef CONFIG_ENV_VARS_UBOOT_RUNTIME_CONFIG
+	char *name = "ubmc335x";
+
+	set_board_info_env(name);
+
+	/*
+	 * Default FIT boot on HS devices. Non FIT images are not allowed
+	 * on HS devices.
+	 */
+	if (get_device_type() == HS_DEVICE)
+		setenv("boot_fit", "1");
+#endif
+
+#if !defined(CONFIG_SPL_BUILD)
+	/* try reading mac address from efuse */
+	mac_lo = readl(&cdev->macid0l);
+	mac_hi = readl(&cdev->macid0h);
+	mac_addr[0] = mac_hi & 0xFF;
+	mac_addr[1] = (mac_hi & 0xFF00) >> 8;
+	mac_addr[2] = (mac_hi & 0xFF0000) >> 16;
+	mac_addr[3] = (mac_hi & 0xFF000000) >> 24;
+	mac_addr[4] = mac_lo & 0xFF;
+	mac_addr[5] = (mac_lo & 0xFF00) >> 8;
+
+	if (!getenv("ethaddr")) {
+		printf("<ethaddr> not set. Validating first E-fuse MAC\n");
+
+		if (is_valid_ethaddr(mac_addr))
+			eth_setenv_enetaddr("ethaddr", mac_addr);
+	}
+
+	mac_lo = readl(&cdev->macid1l);
+	mac_hi = readl(&cdev->macid1h);
+	mac_addr[0] = mac_hi & 0xFF;
+	mac_addr[1] = (mac_hi & 0xFF00) >> 8;
+	mac_addr[2] = (mac_hi & 0xFF0000) >> 16;
+	mac_addr[3] = (mac_hi & 0xFF000000) >> 24;
+	mac_addr[4] = mac_lo & 0xFF;
+	mac_addr[5] = (mac_lo & 0xFF00) >> 8;
+
+	if (!getenv("eth1addr")) {
+		if (is_valid_ethaddr(mac_addr))
+			eth_setenv_enetaddr("eth1addr", mac_addr);
+	}
+#endif
+
+	board_get_boot_info();
+	return 0;
+}
+#endif
+
+#ifndef CONFIG_DM_ETH
+
+#if (defined(CONFIG_DRIVER_TI_CPSW) && !defined(CONFIG_SPL_BUILD)) || \
+	(defined(CONFIG_SPL_ETH_SUPPORT) && defined(CONFIG_SPL_BUILD))
+static void cpsw_control(int enabled)
+{
+	/* VTP can be added here */
+
+	return;
+}
+
+static struct cpsw_slave_data cpsw_slaves[] = {
+	{
+		.slave_reg_ofs	= 0x208,
+		.sliver_reg_ofs	= 0xd80,
+		.phy_addr	= 0,
+	},
+	{
+		.slave_reg_ofs	= 0x308,
+		.sliver_reg_ofs	= 0xdc0,
+		.phy_addr	= 1,
+	},
+};
+
+static struct cpsw_platform_data cpsw_data = {
+	.mdio_base		= CPSW_MDIO_BASE,
+	.cpsw_base		= CPSW_BASE,
+	.mdio_div		= 0xff,
+	.channels		= 8,
+	.cpdma_reg_ofs		= 0x800,
+	.slaves			= 1,
+	.slave_data		= cpsw_slaves,
+	.ale_reg_ofs		= 0xd00,
+	.ale_entries		= 1024,
+	.host_port_reg_ofs	= 0x108,
+	.hw_stats_reg_ofs	= 0x900,
+	.bd_ram_ofs		= 0x2000,
+	.mac_control		= (1 << 5),
+	.control		= cpsw_control,
+	.host_port_num		= 0,
+	.version		= CPSW_CTRL_VERSION_2,
+};
+#endif
+
+#if ((defined(CONFIG_SPL_ETH_SUPPORT) || defined(CONFIG_SPL_USBETH_SUPPORT)) &&\
+	defined(CONFIG_SPL_BUILD)) || \
+	((defined(CONFIG_DRIVER_TI_CPSW) || \
+	  defined(CONFIG_USB_ETHER) && defined(CONFIG_MUSB_GADGET)) && \
+	 !defined(CONFIG_SPL_BUILD))
+
+/*
+ * This function will:
+ * Read the eFuse for MAC addresses, and set ethaddr/eth1addr/usbnet_devaddr
+ * in the environment
+ * Perform fixups to the PHY present on certain boards.  We only need this
+ * function in:
+ * - SPL with either CPSW or USB ethernet support
+ * - Full U-Boot, with either CPSW or USB ethernet
+ * Build in only these cases to avoid warnings about unused variables
+ * when we build an SPL that has neither option but full U-Boot will.
+ */
+int board_eth_init(bd_t *bis)
+{
+	int rv, n = 0;
+	uint8_t mac_addr[6];
+#if defined(CONFIG_USB_ETHER) && \
+	(!defined(CONFIG_SPL_BUILD) || defined(CONFIG_SPL_USBETH_SUPPORT))
+	uint32_t mac_hi, mac_lo;
+
+	/*
+	 * use efuse mac address for USB ethernet as we know that
+	 * both CPSW and USB ethernet will never be active at the same time
+	 */
+	mac_lo = readl(&cdev->macid0l);
+	mac_hi = readl(&cdev->macid0h);
+	mac_addr[0] = mac_hi & 0xFF;
+	mac_addr[1] = (mac_hi & 0xFF00) >> 8;
+	mac_addr[2] = (mac_hi & 0xFF0000) >> 16;
+	mac_addr[3] = (mac_hi & 0xFF000000) >> 24;
+	mac_addr[4] = mac_lo & 0xFF;
+	mac_addr[5] = (mac_lo & 0xFF00) >> 8;
+#endif
+
+
+#if (defined(CONFIG_DRIVER_TI_CPSW) && !defined(CONFIG_SPL_BUILD)) || \
+	(defined(CONFIG_SPL_ETH_SUPPORT) && defined(CONFIG_SPL_BUILD))
+	if (!getenv("ethaddr")) {
+		puts("<ethaddr> not set. Validating first E-fuse MAC\n");
+		if (is_valid_ethaddr(mac_addr))
+			eth_setenv_enetaddr("ethaddr", mac_addr);
+	}
+
+#ifdef CONFIG_DRIVER_TI_CPSW
+	{
+#ifndef CONFIG_TARGET_UBMC335X
+		writel((RGMII_MODE_ENABLE | RGMII_INT_DELAY), &cdev->miisel);
+#else
+		writel((GMII1_SEL_RGMII | RGMII1_IDMODE | GMII2_SEL_RMII | RMII2_IO_CLK_EN),
+		       &cdev->miisel);
+#endif
+		cpsw_slaves[0].phy_if = cpsw_slaves[1].phy_if =
+				PHY_INTERFACE_MODE_RGMII;
+	}
+
+	rv = cpsw_register(&cpsw_data);
+	if (rv < 0)
+		printf("Error %d registering CPSW switch\n", rv);
+	else
+		n += rv;
+#endif
+
+#endif
+#if defined(CONFIG_USB_ETHER) && \
+	(!defined(CONFIG_SPL_BUILD) || defined(CONFIG_SPL_USBETH_SUPPORT))
+	if (is_valid_ethaddr(mac_addr))
+		eth_setenv_enetaddr("usbnet_devaddr", mac_addr);
+
+	rv = usb_eth_initialize(bis);
+	if (rv < 0)
+		printf("Error %d registering USB_ETHER\n", rv);
+	else
+		n += rv;
+#endif
+	return n;
+}
+#endif
+
+#endif /* CONFIG_DM_ETH */
+
+#ifdef CONFIG_SPL_LOAD_FIT
+int board_fit_config_name_match(const char *name)
+{
+#ifndef NO_SILC_MOD
+	if (strcmp(name, "ubmc335x")==0)
+		return 0;
+	return -1;
+#endif
+}
+#endif
+
+#ifdef CONFIG_TI_SECURE_DEVICE
+void board_fit_image_post_process(void **p_image, size_t *p_size)
+{
+	secure_boot_verify_image(p_image, p_size);
+}
+#endif
+
+#if defined(CONFIG_OF_LIBFDT) && defined(CONFIG_OF_BOARD_SETUP)
+
+static const char pruss_eth0_alias[] = "/pruss_eth/ethernet-mii0";
+static const char pruss_eth1_alias[] = "/pruss_eth/ethernet-mii1";
+
+int ft_board_setup(void *fdt, bd_t *bd)
+{
+	return 0;
+}
+#endif
+
+#if defined(CONFIG_GENERIC_MMC)
+
+int board_mmc_init(bd_t *bis)
+{
+	int ret;
+#if defined(CONFIG_UMBC_SD_UBOOT)
+	//Initialize SD card only, mmc0 of the am3352, it will become BOOT_DEVICE_MMC1
+	ret = omap_mmc_init(0, 0, 0, -1, -1);
+	printf("MMC/SD init %d\n", ret);
+#else
+	//Initialize emmc only, mmc1 of the am3352, it will also become BOOT_DEVICE_MMC1
+	ret = omap_mmc_init(1, 0, 0, -1, -1);
+	printf("EMMC init %d\n", ret);
+#endif
+
+	return 0;
+}
+#endif
diff -uNr uboot-custom-orig/board/silicom/ubmc335x/board_detect.c uboot-custom-silicom/board/silicom/ubmc335x/board_detect.c
--- uboot-custom-orig/board/silicom/ubmc335x/board_detect.c	1970-01-01 08:00:00.000000000 +0800
+++ uboot-custom-silicom/board/silicom/ubmc335x/board_detect.c	2018-07-23 22:42:52.964237002 +0800
@@ -0,0 +1,395 @@
+/*
+ * Library to support early TI EVM EEPROM handling
+ *
+ * Copyright (C) 2015-2016 Texas Instruments Incorporated - http://www.ti.com/
+ *	Lokesh Vutla
+ *	Steve Kipisz
+ *
+ * SPDX-License-Identifier:    GPL-2.0+
+ */
+
+#include <common.h>
+#include <asm/omap_common.h>
+#include <i2c.h>
+
+#include "board_detect.h"
+
+/**
+ * ti_i2c_eeprom_init - Initialize an i2c bus and probe for a device
+ * @i2c_bus: i2c bus number to initialize
+ * @dev_addr: Device address to probe for
+ *
+ * Return: 0 on success or corresponding error on failure.
+ */
+static int __maybe_unused ti_i2c_eeprom_init(int i2c_bus, int dev_addr)
+{
+	int rc;
+
+	if (i2c_bus >= 0) {
+		rc = i2c_set_bus_num(i2c_bus);
+		if (rc)
+			return rc;
+	}
+
+	return i2c_probe(dev_addr);
+}
+
+/**
+ * ti_i2c_eeprom_read - Read data from an EEPROM
+ * @dev_addr: The device address of the EEPROM
+ * @offset: Offset to start reading in the EEPROM
+ * @ep: Pointer to a buffer to read into
+ * @epsize: Size of buffer
+ *
+ * Return: 0 on success or corresponding result of i2c_read
+ */
+static int __maybe_unused ti_i2c_eeprom_read(int dev_addr, int offset,
+					     uchar *ep, int epsize)
+{
+	return i2c_read(dev_addr, offset, 2, ep, epsize);
+}
+
+/**
+ * ti_eeprom_string_cleanup() - Handle eeprom programming errors
+ * @s:	eeprom string (should be NULL terminated)
+ *
+ * Some Board manufacturers do not add a NULL termination at the
+ * end of string, instead some binary information is kludged in, hence
+ * convert the string to just printable characters of ASCII chart.
+ */
+static void __maybe_unused ti_eeprom_string_cleanup(char *s)
+{
+	int i, l;
+
+	l = strlen(s);
+	for (i = 0; i < l; i++, s++)
+		if (*s < ' ' || *s > '~') {
+			*s = 0;
+			break;
+		}
+}
+
+__weak void gpi2c_init(void)
+{
+}
+
+static int __maybe_unused ti_i2c_eeprom_get(int bus_addr, int dev_addr,
+					    u32 header, u32 size, uint8_t *ep)
+{
+	u32 byte, hdr_read;
+	int rc;
+
+	gpi2c_init();
+	rc = ti_i2c_eeprom_init(bus_addr, dev_addr);
+	if (rc)
+		return rc;
+
+	/*
+	 * Read the header first then only read the other contents.
+	 */
+	byte = 2;
+	rc = i2c_read(dev_addr, 0x0, byte, (uint8_t *)&hdr_read, 4);
+	if (rc)
+		return rc;
+
+	/* Corrupted data??? */
+	if (hdr_read != header) {
+		rc = i2c_read(dev_addr, 0x0, byte, (uint8_t *)&hdr_read, 4);
+		/*
+		 * read the eeprom header using i2c again, but use only a
+		 * 1 byte address (some legacy boards need this..)
+		 */
+		byte = 1;
+		if (rc)
+			rc = i2c_read(dev_addr, 0x0, byte, (uint8_t *)&hdr_read,
+				      4);
+		if (rc)
+			return rc;
+	}
+	if (hdr_read != header)
+		return -1;
+
+	rc = i2c_read(dev_addr, 0x0, byte, ep, size);
+	if (rc)
+		return rc;
+
+	return 0;
+}
+
+int __maybe_unused ti_i2c_eeprom_am_set(const char *name, const char *rev)
+{
+	struct ti_common_eeprom *ep;
+
+	if (!name || !rev)
+		return -1;
+
+	ep = TI_EEPROM_DATA;
+	if (ep->header == TI_EEPROM_HEADER_MAGIC)
+		goto already_set;
+
+	/* Set to 0 all fields */
+	memset(ep, 0, sizeof(*ep));
+	strncpy(ep->name, name, TI_EEPROM_HDR_NAME_LEN);
+	strncpy(ep->version, rev, TI_EEPROM_HDR_REV_LEN);
+	/* Some dummy serial number to identify the platform */
+	strncpy(ep->serial, "0000", TI_EEPROM_HDR_SERIAL_LEN);
+	/* Mark it with a valid header */
+	ep->header = TI_EEPROM_HEADER_MAGIC;
+
+already_set:
+	return 0;
+}
+
+int __maybe_unused ti_i2c_eeprom_am_get(int bus_addr, int dev_addr)
+{
+	int rc;
+	struct ti_am_eeprom am_ep;
+	struct ti_common_eeprom *ep;
+
+	ep = TI_EEPROM_DATA;
+#ifndef CONFIG_SPL_BUILD
+	if (ep->header == TI_EEPROM_HEADER_MAGIC)
+		return 0; /* EEPROM has already been read */
+#endif
+
+	/* Initialize with a known bad marker for i2c fails.. */
+	ep->header = TI_DEAD_EEPROM_MAGIC;
+	ep->name[0] = 0x0;
+	ep->version[0] = 0x0;
+	ep->serial[0] = 0x0;
+	ep->config[0] = 0x0;
+
+	rc = ti_i2c_eeprom_get(bus_addr, dev_addr, TI_EEPROM_HEADER_MAGIC,
+			       sizeof(am_ep), (uint8_t *)&am_ep);
+	if (rc)
+		return rc;
+
+	ep->header = am_ep.header;
+	strlcpy(ep->name, am_ep.name, TI_EEPROM_HDR_NAME_LEN + 1);
+	ti_eeprom_string_cleanup(ep->name);
+
+	/* BeagleBone Green '1' eeprom, board_rev: 0x1a 0x00 0x00 0x00 */
+	if (am_ep.version[0] == 0x1a && am_ep.version[1] == 0x00 &&
+	    am_ep.version[2] == 0x00 && am_ep.version[3] == 0x00)
+		strlcpy(ep->version, "BBG1", TI_EEPROM_HDR_REV_LEN + 1);
+	else
+		strlcpy(ep->version, am_ep.version, TI_EEPROM_HDR_REV_LEN + 1);
+	ti_eeprom_string_cleanup(ep->version);
+	strlcpy(ep->serial, am_ep.serial, TI_EEPROM_HDR_SERIAL_LEN + 1);
+	ti_eeprom_string_cleanup(ep->serial);
+	strlcpy(ep->config, am_ep.config, TI_EEPROM_HDR_CONFIG_LEN + 1);
+	ti_eeprom_string_cleanup(ep->config);
+
+	memcpy(ep->mac_addr, am_ep.mac_addr,
+	       TI_EEPROM_HDR_NO_OF_MAC_ADDR * TI_EEPROM_HDR_ETH_ALEN);
+
+	return 0;
+}
+
+int __maybe_unused ti_i2c_eeprom_dra7_get(int bus_addr, int dev_addr)
+{
+	int rc, offset = 0;
+	struct dra7_eeprom dra7_ep;
+	struct ti_common_eeprom *ep;
+
+	ep = TI_EEPROM_DATA;
+#ifndef CONFIG_SPL_BUILD
+	if (ep->header == DRA7_EEPROM_HEADER_MAGIC)
+		return 0; /* EEPROM has already been read */
+#endif
+
+	/* Initialize with a known bad marker for i2c fails.. */
+	ep->header = TI_DEAD_EEPROM_MAGIC;
+	ep->name[0] = 0x0;
+	ep->version[0] = 0x0;
+	ep->serial[0] = 0x0;
+	ep->config[0] = 0x0;
+	ep->emif1_size = 0;
+	ep->emif2_size = 0;
+
+	rc = ti_i2c_eeprom_get(bus_addr, dev_addr, DRA7_EEPROM_HEADER_MAGIC,
+			       sizeof(dra7_ep), (uint8_t *)&dra7_ep);
+	if (rc)
+		return rc;
+
+	ep->header = dra7_ep.header;
+	strlcpy(ep->name, dra7_ep.name, TI_EEPROM_HDR_NAME_LEN + 1);
+	ti_eeprom_string_cleanup(ep->name);
+
+	offset = dra7_ep.version_major - 1;
+
+	/* Rev F is skipped */
+	if (offset >= 5)
+		offset = offset + 1;
+	snprintf(ep->version, TI_EEPROM_HDR_REV_LEN + 1, "%c.%d",
+		 'A' + offset, dra7_ep.version_minor);
+	ti_eeprom_string_cleanup(ep->version);
+	ep->emif1_size = (u64)dra7_ep.emif1_size;
+	ep->emif2_size = (u64)dra7_ep.emif2_size;
+	strlcpy(ep->config, dra7_ep.config, TI_EEPROM_HDR_CONFIG_LEN + 1);
+	ti_eeprom_string_cleanup(ep->config);
+
+	return 0;
+}
+
+bool __maybe_unused board_ti_is(char *name_tag)
+{
+	struct ti_common_eeprom *ep = TI_EEPROM_DATA;
+
+	if (ep->header == TI_DEAD_EEPROM_MAGIC)
+		return false;
+	return !strncmp(ep->name, name_tag, TI_EEPROM_HDR_NAME_LEN);
+}
+
+bool __maybe_unused board_ti_rev_is(char *rev_tag, int cmp_len)
+{
+	struct ti_common_eeprom *ep = TI_EEPROM_DATA;
+	int l;
+
+	if (ep->header == TI_DEAD_EEPROM_MAGIC)
+		return false;
+
+	l = cmp_len > TI_EEPROM_HDR_REV_LEN ? TI_EEPROM_HDR_REV_LEN : cmp_len;
+	return !strncmp(ep->version, rev_tag, l);
+}
+
+char * __maybe_unused board_ti_get_rev(void)
+{
+	struct ti_common_eeprom *ep = TI_EEPROM_DATA;
+
+	/* if ep->header == TI_DEAD_EEPROM_MAGIC, this is empty already */
+	return ep->version;
+}
+
+char * __maybe_unused board_ti_get_config(void)
+{
+	struct ti_common_eeprom *ep = TI_EEPROM_DATA;
+
+	/* if ep->header == TI_DEAD_EEPROM_MAGIC, this is empty already */
+	return ep->config;
+}
+
+char * __maybe_unused board_ti_get_name(void)
+{
+	struct ti_common_eeprom *ep = TI_EEPROM_DATA;
+
+	/* if ep->header == TI_DEAD_EEPROM_MAGIC, this is empty already */
+	return ep->name;
+}
+
+void __maybe_unused
+board_ti_get_eth_mac_addr(int index,
+			  u8 mac_addr[TI_EEPROM_HDR_ETH_ALEN])
+{
+	struct ti_common_eeprom *ep = TI_EEPROM_DATA;
+
+	if (ep->header == TI_DEAD_EEPROM_MAGIC)
+		goto fail;
+
+	if (index < 0 || index >= TI_EEPROM_HDR_NO_OF_MAC_ADDR)
+		goto fail;
+
+	memcpy(mac_addr, ep->mac_addr[index], TI_EEPROM_HDR_ETH_ALEN);
+	return;
+
+fail:
+	memset(mac_addr, 0, TI_EEPROM_HDR_ETH_ALEN);
+}
+
+u64 __maybe_unused board_ti_get_emif1_size(void)
+{
+	struct ti_common_eeprom *ep = TI_EEPROM_DATA;
+
+	if (ep->header != DRA7_EEPROM_HEADER_MAGIC)
+		return 0;
+
+	return ep->emif1_size;
+}
+
+u64 __maybe_unused board_ti_get_emif2_size(void)
+{
+	struct ti_common_eeprom *ep = TI_EEPROM_DATA;
+
+	if (ep->header != DRA7_EEPROM_HEADER_MAGIC)
+		return 0;
+
+	return ep->emif2_size;
+}
+
+void __maybe_unused set_board_info_env(char *name)
+{
+	char *unknown = "unknown";
+	struct ti_common_eeprom *ep = TI_EEPROM_DATA;
+
+	setenv("board_name", "ubmc335x");
+	setenv("board_rev", "0.9");
+	setenv("board_serial", "XXXX-XXXXX");
+
+}
+
+static u64 mac_to_u64(u8 mac[6])
+{
+	int i;
+	u64 addr = 0;
+
+	for (i = 0; i < 6; i++) {
+		addr <<= 8;
+		addr |= mac[i];
+	}
+
+	return addr;
+}
+
+static void u64_to_mac(u64 addr, u8 mac[6])
+{
+	mac[5] = addr;
+	mac[4] = addr >> 8;
+	mac[3] = addr >> 16;
+	mac[2] = addr >> 24;
+	mac[1] = addr >> 32;
+	mac[0] = addr >> 40;
+}
+
+void board_ti_set_ethaddr(int index)
+{
+	uint8_t mac_addr[6];
+	int i;
+	u64 mac1, mac2;
+	u8 mac_addr1[6], mac_addr2[6];
+	int num_macs;
+	/*
+	 * Export any Ethernet MAC addresses from EEPROM.
+	 * The 2 MAC addresses in EEPROM define the address range.
+	 */
+	board_ti_get_eth_mac_addr(0, mac_addr1);
+	board_ti_get_eth_mac_addr(1, mac_addr2);
+
+	if (is_valid_ethaddr(mac_addr1) && is_valid_ethaddr(mac_addr2)) {
+		mac1 = mac_to_u64(mac_addr1);
+		mac2 = mac_to_u64(mac_addr2);
+
+		/* must contain an address range */
+		num_macs = mac2 - mac1 + 1;
+		/* <= 50 to protect against user programming error */
+		if (num_macs > 0 && num_macs <= 50) {
+			for (i = 0; i < num_macs; i++) {
+				u64_to_mac(mac1 + i, mac_addr);
+				if (is_valid_ethaddr(mac_addr)) {
+					eth_setenv_enetaddr_by_index("eth",
+								     i + index,
+								     mac_addr);
+				}
+			}
+		}
+	}
+}
+
+bool __maybe_unused board_ti_was_eeprom_read(void)
+{
+	struct ti_common_eeprom *ep = TI_EEPROM_DATA;
+
+	if (ep->header == TI_EEPROM_HEADER_MAGIC)
+		return true;
+	else
+		return false;
+}
diff -uNr uboot-custom-orig/board/silicom/ubmc335x/board_detect.h uboot-custom-silicom/board/silicom/ubmc335x/board_detect.h
--- uboot-custom-orig/board/silicom/ubmc335x/board_detect.h	1970-01-01 08:00:00.000000000 +0800
+++ uboot-custom-silicom/board/silicom/ubmc335x/board_detect.h	2018-07-23 22:42:52.964237002 +0800
@@ -0,0 +1,234 @@
+/*
+ * Library to support early TI EVM EEPROM handling
+ *
+ * Copyright (C) 2015-2016 Texas Instruments Incorporated - http://www.ti.com
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __BOARD_DETECT_H
+#define __BOARD_DETECT_H
+
+/* TI EEPROM MAGIC Header identifier */
+#define TI_EEPROM_HEADER_MAGIC	0xEE3355AA
+#define TI_DEAD_EEPROM_MAGIC	0xADEAD12C
+
+#define TI_EEPROM_HDR_NAME_LEN		8
+#define TI_EEPROM_HDR_REV_LEN		4
+#define TI_EEPROM_HDR_SERIAL_LEN	12
+#define TI_EEPROM_HDR_CONFIG_LEN	32
+#define TI_EEPROM_HDR_NO_OF_MAC_ADDR	3
+#define TI_EEPROM_HDR_ETH_ALEN		6
+
+/**
+ * struct ti_am_eeprom - This structure holds data read in from the
+ *                     AM335x, AM437x, AM57xx TI EVM EEPROMs.
+ * @header: This holds the magic number
+ * @name: The name of the board
+ * @version: Board revision
+ * @serial: Board serial number
+ * @config: Reserved
+ * @mac_addr: Any MAC addresses written in the EEPROM
+ *
+ * The data is this structure is read from the EEPROM on the board.
+ * It is used for board detection which is based on name. It is used
+ * to configure specific TI boards. This allows booting of multiple
+ * TI boards with a single MLO and u-boot.
+ */
+struct ti_am_eeprom {
+	unsigned int header;
+	char name[TI_EEPROM_HDR_NAME_LEN];
+	char version[TI_EEPROM_HDR_REV_LEN];
+	char serial[TI_EEPROM_HDR_SERIAL_LEN];
+	char config[TI_EEPROM_HDR_CONFIG_LEN];
+	char mac_addr[TI_EEPROM_HDR_NO_OF_MAC_ADDR][TI_EEPROM_HDR_ETH_ALEN];
+} __attribute__ ((__packed__));
+
+/* DRA7 EEPROM MAGIC Header identifier */
+#define DRA7_EEPROM_HEADER_MAGIC	0xAA5533EE
+#define DRA7_EEPROM_HDR_NAME_LEN	16
+#define DRA7_EEPROM_HDR_CONFIG_LEN	4
+
+/**
+ * struct dra7_eeprom - This structure holds data read in from the DRA7 EVM
+ *			EEPROMs.
+ * @header: This holds the magic number
+ * @name: The name of the board
+ * @version_major: Board major version
+ * @version_minor: Board minor version
+ * @config: Board specific config options
+ * @emif1_size: Size of DDR attached to EMIF1
+ * @emif2_size: Size of DDR attached to EMIF2
+ *
+ * The data is this structure is read from the EEPROM on the board.
+ * It is used for board detection which is based on name. It is used
+ * to configure specific DRA7 boards. This allows booting of multiple
+ * DRA7 boards with a single MLO and u-boot.
+ */
+struct dra7_eeprom {
+	u32 header;
+	char name[DRA7_EEPROM_HDR_NAME_LEN];
+	u16 version_major;
+	u16 version_minor;
+	char config[DRA7_EEPROM_HDR_CONFIG_LEN];
+	u32 emif1_size;
+	u32 emif2_size;
+} __attribute__ ((__packed__));
+
+/**
+ * struct ti_common_eeprom - Null terminated, usable EEPROM contents.
+ * header:	Magic number
+ * @name:	NULL terminated name
+ * @version:	NULL terminated version
+ * @serial:	NULL terminated serial number
+ * @config:	NULL terminated Board specific config options
+ * @mac_addr:	MAC addresses
+ * @emif1_size:	Size of the ddr available on emif1
+ * @emif2_size:	Size of the ddr available on emif2
+ */
+struct ti_common_eeprom {
+	u32 header;
+	char name[TI_EEPROM_HDR_NAME_LEN + 1];
+	char version[TI_EEPROM_HDR_REV_LEN + 1];
+	char serial[TI_EEPROM_HDR_SERIAL_LEN + 1];
+	char config[TI_EEPROM_HDR_CONFIG_LEN + 1];
+	char mac_addr[TI_EEPROM_HDR_NO_OF_MAC_ADDR][TI_EEPROM_HDR_ETH_ALEN];
+	u64 emif1_size;
+	u64 emif2_size;
+};
+
+#define TI_EEPROM_DATA ((struct ti_common_eeprom *)\
+				TI_SRAM_SCRATCH_BOARD_EEPROM_START)
+
+/**
+ * ti_i2c_eeprom_am_get() - Consolidated eeprom data collection for AM* TI EVMs
+ * @bus_addr:	I2C bus address
+ * @dev_addr:	I2C slave address
+ *
+ * ep in SRAM is populated by the this AM generic function that consolidates
+ * the basic initialization logic common across all AM* platforms.
+ */
+int ti_i2c_eeprom_am_get(int bus_addr, int dev_addr);
+
+/**
+ * ti_i2c_eeprom_dra7_get() - Consolidated eeprom data for DRA7 TI EVMs
+ * @bus_addr:	I2C bus address
+ * @dev_addr:	I2C slave address
+ */
+int ti_i2c_eeprom_dra7_get(int bus_addr, int dev_addr);
+
+/**
+ * board_ti_is() - Board detection logic for TI EVMs
+ * @name_tag:	Tag used in eeprom for the board
+ *
+ * Return: false if board information does not match OR eeprom wasn't read.
+ *	   true otherwise
+ */
+bool board_ti_is(char *name_tag);
+
+/**
+ * board_ti_rev_is() - Compare board revision for TI EVMs
+ * @rev_tag:	Revision tag to check in eeprom
+ * @cmp_len:	How many chars to compare?
+ *
+ * NOTE: revision information is often messed up (hence the str len match) :(
+ *
+ * Return: false if board information does not match OR eeprom wasn't read.
+ *	   true otherwise
+ */
+bool board_ti_rev_is(char *rev_tag, int cmp_len);
+
+/**
+ * board_ti_get_rev() - Get board revision for TI EVMs
+ *
+ * Return: Empty string if eeprom wasn't read.
+ *	   Board revision otherwise
+ */
+char *board_ti_get_rev(void);
+
+/**
+ * board_ti_get_config() - Get board config for TI EVMs
+ *
+ * Return: Empty string if eeprom wasn't read.
+ *	   Board config otherwise
+ */
+char *board_ti_get_config(void);
+
+/**
+ * board_ti_get_name() - Get board name for TI EVMs
+ *
+ * Return: Empty string if eeprom wasn't read.
+ *	   Board name otherwise
+ */
+char *board_ti_get_name(void);
+
+/**
+ * board_ti_get_eth_mac_addr() - Get Ethernet MAC address from EEPROM MAC list
+ * @index:	0 based index within the list of MAC addresses
+ * @mac_addr:	MAC address contained at the index is returned here
+ *
+ * Does not sanity check the mac_addr. Whatever is stored in EEPROM is returned.
+ */
+void board_ti_get_eth_mac_addr(int index, u8 mac_addr[TI_EEPROM_HDR_ETH_ALEN]);
+
+/**
+ * board_ti_get_emif1_size() - Get size of the DDR on emif1 for TI EVMs
+ *
+ * Return: NULL if eeprom wasn't read or emif1_size is not available.
+ */
+u64 board_ti_get_emif1_size(void);
+
+/**
+ * board_ti_get_emif2_size() - Get size of the DDR on emif2 for TI EVMs
+ *
+ * Return: NULL if eeprom wasn't read or emif2_size is not available.
+ */
+u64 board_ti_get_emif2_size(void);
+
+/**
+ * set_board_info_env() - Setup commonly used board information environment vars
+ * @name:	Name of the board
+ *
+ * If name is NULL, default_name is used.
+ */
+void set_board_info_env(char *name);
+
+/**
+ * board_ti_was_eeprom_read() - Check to see if the eeprom contents have been read
+ *
+ * This function is useful to determine if the eeprom has already been read and
+ * its contents have already been loaded into memory. It utiltzes the magic
+ * number that the header value is set to upon successful eeprom read.
+ */
+bool board_ti_was_eeprom_read(void);
+
+/**
+ * ti_i2c_eeprom_am_set() - Setup the eeprom data with predefined values
+ * @name:	Name of the board
+ * @rev:	Revision of the board
+ *
+ * In some cases such as in RTC-only mode, we are able to skip reading eeprom
+ * and wasting i2c based initialization time by using predefined flags for
+ * detecting what platform we are booting on. For those platforms, provide
+ * a handy function to pre-program information.
+ *
+ * NOTE: many eeprom information such as serial number, mac address etc is not
+ * available.
+ *
+ * Return: 0 if all went fine, else return error.
+ */
+int ti_i2c_eeprom_am_set(const char *name, const char *rev);
+
+/**
+ * board_ti_set_ethaddr- Sets the ethaddr environment from EEPROM
+ * @index: The first eth<index>addr environment variable to set
+ *
+ * EEPROM should be already read before calling this function.
+ * The EEPROM contains 2 MAC addresses which define the MAC address
+ * range (i.e. first and last MAC address).
+ * This function sets the ethaddr environment variable for all
+ * the available MAC addresses starting from eth<index>addr.
+ */
+void board_ti_set_ethaddr(int index);
+
+#endif	/* __BOARD_DETECT_H */
diff -uNr uboot-custom-orig/board/silicom/ubmc335x/board.h uboot-custom-silicom/board/silicom/ubmc335x/board.h
--- uboot-custom-orig/board/silicom/ubmc335x/board.h	1970-01-01 08:00:00.000000000 +0800
+++ uboot-custom-silicom/board/silicom/ubmc335x/board.h	2018-08-06 22:24:07.084622047 +0800
@@ -0,0 +1,88 @@
+/*
+ * board.h
+ *
+ * TI AM335x boards information header
+ *
+ * Copyright (C) 2011, Texas Instruments, Incorporated - http://www.ti.com/
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef _BOARD_H_
+#define _BOARD_H_
+
+/**
+ * AM335X (EMIF_4D) EMIF REG_COS_COUNT_1, REG_COS_COUNT_2, and
+ * REG_PR_OLD_COUNT values to avoid LCDC DMA FIFO underflows and Frame
+ * Synchronization Lost errors. The values are the biggest that work
+ * reliably with offered video modes and the memory subsystem on the
+ * boards. These register have are briefly documented in "7.3.3.5.2
+ * Command Starvation" section of AM335x TRM. The REG_COS_COUNT_1 and
+ * REG_COS_COUNT_2 do not have any effect on current versions of
+ * AM335x.
+ */
+#define EMIF_OCP_CONFIG_BEAGLEBONE_BLACK       0x00141414
+#define EMIF_OCP_CONFIG_AM335X_EVM             0x003d3d3d
+
+#if 0
+static inline int board_is_bone(void)
+{
+	return board_ti_is("A335BONE");
+}
+
+static inline int board_is_bone_lt(void)
+{
+	return board_ti_is("A335BNLT");
+}
+
+static inline int board_is_bbg1(void)
+{
+	return board_is_bone_lt() && !strncmp(board_ti_get_rev(), "BBG1", 4);
+}
+
+static inline int board_is_beaglebonex(void)
+{
+	return board_is_bone() || board_is_bone_lt() || board_is_bbg1();
+}
+
+static inline int board_is_evm_sk(void)
+{
+	return board_ti_is("A335X_SK");
+}
+
+static inline int board_is_idk(void)
+{
+	return !strncmp(board_ti_get_config(), "SKU#02", 6);
+}
+
+static inline int board_is_gp_evm(void)
+{
+	return board_ti_is("A33515BB");
+}
+
+static inline int board_is_evm_15_or_later(void)
+{
+	return (board_is_gp_evm() &&
+		strncmp("1.5", board_ti_get_rev(), 3) <= 0);
+}
+
+static inline int board_is_icev2(void)
+{
+	return board_ti_is("A335_ICE") && !strncmp("2", board_ti_get_rev(), 1);
+}
+#endif
+/*
+ * We have three pin mux functions that must exist.  We must be able to enable
+ * uart0, for initial output and i2c0 to read the main EEPROM.  We then have a
+ * main pinmux function that can be overridden to enable all other pinmux that
+ * is required on the board.
+ */
+void enable_uart0_pin_mux(void);
+void enable_uart1_pin_mux(void);
+void enable_uart2_pin_mux(void);
+void enable_uart3_pin_mux(void);
+void enable_uart4_pin_mux(void);
+void enable_uart5_pin_mux(void);
+void enable_i2c0_pin_mux(void);
+void enable_board_pin_mux(void);
+#endif
diff -uNr uboot-custom-orig/board/silicom/ubmc335x/emc2300_init.c uboot-custom-silicom/board/silicom/ubmc335x/emc2300_init.c
--- uboot-custom-orig/board/silicom/ubmc335x/emc2300_init.c	1970-01-01 08:00:00.000000000 +0800
+++ uboot-custom-silicom/board/silicom/ubmc335x/emc2300_init.c	2018-07-23 22:42:52.964237002 +0800
@@ -0,0 +1,383 @@
+#include <common.h>
+#include <errno.h>
+#include <spl.h>
+#include <asm/arch/cpu.h>
+#include <asm/arch/hardware.h>
+#include <asm/arch/omap.h>
+#include <asm/arch/sys_proto.h>
+#include <asm/io.h>
+#include <asm/gpio.h>
+#include <i2c.h>
+//#include <asm/errno.h>
+
+
+#define	GPIO_BMC_UART_MUX_SEL			54  
+#define	GPIO_SPI_HOST_MUX_EN			27  
+#define	GPIO_W_DISABLE_WWAN_N			67  
+#define	GPIO_HOST_FRU_EEPROM_MUX_SEL	31  
+#define	GPIO_LED_BMC_BOT_RED_N			69  
+#define	GPIO_LED_BMC_BOT_GRN_N			60  
+#define	GPIO_LED_BMC_BOT_BLU_N			86  
+#define	GPIO_BMC_FP_BUTTON_OVERRIDE		87  
+#define	GPIO_BMC_RSTBTN_OUT_N			89  
+#define	GPIO_BMC_PWRBTN_OUT_N			29  
+#define	GPIO_SMB_PECI_CLK				117 
+
+typedef struct {
+	int	flat_gpio;
+	int	value;
+	const char	*label;
+} output_gpio_init_t;
+
+static output_gpio_init_t	output_gpio_init [] =
+{
+	{.flat_gpio =  54, .value =  0, .label = "GPIO_BMC_UART_MUX_SEL"},
+	{.flat_gpio =  27, .value =  0, .label = "GPIO_SPI_HOST_MUX_EN"},
+	{.flat_gpio =  67, .value =  1, .label = "GPIO_W_DISABLE_WWAN_N"},
+	{.flat_gpio =  31, .value =  0, .label = "GPIO_HOST_FRU_EEPROM_MUX_SEL"},
+	{.flat_gpio =  69, .value =  1, .label = "GPIO_LED_BMC_BOT_RED_N"},
+	{.flat_gpio =  60, .value =  1, .label = "GPIO_LED_BMC_BOT_GRN_N"},
+	{.flat_gpio =  86, .value =  1, .label = "GPIO_LED_BMC_BOT_BLU_N"},
+	{.flat_gpio =  87, .value =  0, .label = "GPIO_BMC_FP_BUTTON_OVERRIDE"},
+	{.flat_gpio =  89, .value =  1, .label = "GPIO_BMC_RSTBTN_OUT_N"},
+	{.flat_gpio =  29, .value =  1, .label = "GPIO_BMC_PWRBTN_OUT_N"},
+	{.flat_gpio = 117, .value =  0, .label = "GPIO_SMB_PECI_CLK"},
+};
+
+// GPIO setup for VECPE BMC.
+//
+int
+vecpe_bmc_gpio_init (void)
+{
+	int	i;
+	output_gpio_init_t	*ginit;
+
+	printf ("%s:%u\n", __func__, __LINE__);
+
+	ginit = output_gpio_init;
+
+	for (i = 0; i < ARRAY_SIZE(output_gpio_init); i++) {
+		gpio_request (ginit->flat_gpio, ginit->label);
+#if 0
+		printf ("%s:%u flat_gpio: %u  value: %u\n",
+			__func__, __LINE__, ginit->flat_gpio, ginit->value);
+#endif
+		gpio_direction_output (ginit->flat_gpio, ginit->value);
+
+		ginit++;
+	}
+
+	return 0;
+}
+
+
+typedef struct {
+	u8	reg;
+	u8	value;
+} fanreg_init_t;
+
+static fanreg_init_t adt7475_init[] =
+{
+   /*
+    * Ready/Lock/Start Monitoring register:
+	*/
+	{.reg = 0x40, .value = 0x00},		/* The Start bit is set at the end of the script.
+							In production, the Lock bit should probably
+							be set at the end of the script also.*/
+	/*
+	 *  Temperature Limit Registers:
+	 */
+	{.reg = 0x4e, .value = 0x00}, 	/* Remote Diode 1 (on motherboard, near SoC)
+							Low Temperature, 0 degrees C */
+	{.reg = 0x4f, .value = 0x55}, 	/* Remote Diode 1 (on motherboard, near SoC)
+							High Temperature, 85 degrees C */
+	{.reg = 0x52, .value = 0x00}, 	/* Remote Diode 2 (on Front Panel Module, ambient)
+							Low Temperature, 0 degrees C */
+	{.reg = 0x53, .value = 0x28}, 	/* Remote Diode 2 (on Front Panel Module, ambient)
+							High Temperature, 40 degrees C */
+	/* 
+	 *  PWM Configuration Registers:
+	 *  Fan on Zone 1 (Remote Diode 1), Invert output, 1 sec spin-up time
+	 */
+	{.reg = 0x5c, .value = 0x15},  	/* PWM1 */ /****** Pavel DBG:  0x52 ******/
+	{.reg = 0x5d, .value = 0x15},  	/* PWM2 */
+	{.reg = 0x5e, .value = 0x15},  	/* PWM3 */
+
+	/*
+	 * Zone Temperature Range, PWM frequency:
+	 * Range: 26.67 degrees C, ~25 kHz
+	 */
+	{.reg = 0x5f, .value = 0xba},  	/* Zone 1 / Fan 1 */
+	{.reg = 0x60, .value = 0xba},  	/* Zone 2 / Fan 2 */
+	{.reg = 0x61, .value = 0xba},  	/* Zone 3 / Fan 3 */
+
+	/*
+	 * PWM Ramp Rate Control:
+	 * 4.59 seconds to ramp from 0% to 100%
+	 */
+	{.reg = 0x62, .value = 0xed},  	/* PWM1 */
+	{.reg = 0x63, .value = 0xdd},  	/* PWM2 and PWM3 */
+
+	/*
+	 * Minimum PWM Duty Cycle:
+	 */
+	{.reg = 0x64, .value = 0x26},  	/* PWM1 - 15% */
+	{.reg = 0x65, .value = 0x26},  	/* PWM2 - 15% */
+	{.reg = 0x66, .value = 0x26},  	/* PWM3 - 15% */
+
+	
+#if 0
+	/*
+	 * Maximum PWM Duty Cycle:
+	 */
+*	{.reg = 0x38, .value = 0x26},  	/* PWM1 - 15% */
+	{.reg = 0x39, .value = 0x26},  	/* PWM2 - 15% */
+	{.reg = 0x3A, .value = 0x26},  	/* PWM3 - 15% */
+#endif	
+	
+	/*
+	 * Zone Low Temperature Limit - 56 degrees C
+	 * Note: all three registers must be set to a non-default value to
+	 * allow the fan control to operate!
+	 * 2/13 ... Changed from '0x38' to '0x2e' (46 C) based on lab testing
+	 */
+	{.reg = 0x67, .value = 0x2e},  	/* Zone 1 */
+	{.reg = 0x68, .value = 0x2e},  	/* Zone 2 */
+	{.reg = 0x69, .value = 0x2e},  	/* Zone 3 */
+
+	/*
+	 * Absolute Temperature Limit - 85 degrees C
+	 * 2/13 ... Changed from '0x55' to '0x49' (73 C) based on lab testing
+	 */
+	{.reg = 0x6a, .value = 0x49},  	/* Zone 1 */
+	{.reg = 0x6b, .value = 0x49},  	/* Zone 2 */
+	{.reg = 0x6c, .value = 0x49},  	/* Zone 3 */
+	
+	/*
+	 * Configuration Register 5
+	 */
+	{.reg = 0x7C, .value = 0x03},  	/* Apply offset registers and temp range */	
+	
+	/*
+	 * Ready / Lock / Start Register
+	 */
+	{.reg = 0x40, .value = 0x01},  	/* enable monitoring and PWM control */  
+};
+
+static fanreg_init_t emc2300_init[] =
+{
+	/*
+	 * Ready/Lock/Start Monitoring register:
+	 */
+	{.reg = 0x40, .value = 0x00},		/* The Start bit is set at the end of the script.
+							In production, the Lock bit should probably
+							be set at the end of the script also.*/
+	/*
+	 *  Temperature Limit Registers:
+	 */
+	{.reg = 0x4e, .value = 0x00}, 	/* Remote Diode 1 (on motherboard, near SoC)
+							Low Temperature, 0 degrees C */
+	{.reg = 0x4f, .value = 0x55}, 	/* Remote Diode 1 (on motherboard, near SoC)
+							High Temperature, 85 degrees C */
+	{.reg = 0x52, .value = 0x00}, 	/* Remote Diode 2 (on Front Panel Module, ambient)
+							Low Temperature, 0 degrees C */
+	{.reg = 0x53, .value = 0x28}, 	/* Remote Diode 2 (on Front Panel Module, ambient)
+							High Temperature, 40 degrees C */
+	/* 
+	 *  PWM Configuration Registers:
+	 *  Fan on Zone 1 (Remote Diode 1), Invert output, 1 sec spin-up time
+	 */
+	{.reg = 0x5c, .value = 0x15},  	/* PWM1 */
+	{.reg = 0x5d, .value = 0x15},  	/* PWM2 */
+	{.reg = 0x5e, .value = 0x15},  	/* PWM3 */
+
+	/*
+	 * Zone Temperature Range, PWM frequency:
+	 * Range: 26.67 degrees C, ~25 kHz
+	 */
+	{.reg = 0x5f, .value = 0xba},  	/* Zone 1 / Fan 1 */
+	{.reg = 0x60, .value = 0xba},  	/* Zone 2 / Fan 2 */
+	{.reg = 0x61, .value = 0xba},  	/* Zone 3 / Fan 3 */
+
+	/*
+	 * PWM Ramp Rate Control:
+	 * 4.59 seconds to ramp from 0% to 100%
+	 */
+	{.reg = 0x62, .value = 0xed},  	/* PWM1 */
+	{.reg = 0x63, .value = 0xdd},  	/* PWM2 and PWM3 */
+
+	/*
+	 * Minimum PWM Duty Cycle:
+	 */
+	{.reg = 0x64, .value = 0x26},  	/* PWM1 - 15% */
+	{.reg = 0x65, .value = 0x26},  	/* PWM2 - 15% */
+	{.reg = 0x66, .value = 0x26},  	/* PWM3 - 15% */
+
+	
+#if 0
+	/*
+	 * Maximum PWM Duty Cycle:
+	 */
+	{.reg = 0x38, .value = 0x26},  	/* PWM1 - 15% */
+	{.reg = 0x39, .value = 0x26},  	/* PWM2 - 15% */
+	{.reg = 0x3A, .value = 0x26},  	/* PWM3 - 15% */
+#endif	
+	
+	/*
+	 * Zone Low Temperature Limit - 56 degrees C
+	 * Note: all three registers must be set to a non-default value to
+	 * allow the fan control to operate!
+	 * 2/13 ... Changed from '0x38' to '0x2e' (46 C) based on lab testing
+	 */
+	{.reg = 0x67, .value = 0x2e},  	/* Zone 1 */
+	{.reg = 0x68, .value = 0x2e},  	/* Zone 2 */
+	{.reg = 0x69, .value = 0x2e},  	/* Zone 3 */
+
+	/*
+	 * Absolute Temperature Limit - 85 degrees C
+	 * 2/13 ... Changed from '0x55' to '0x49' (73 C) based on lab testing
+	 */
+	{.reg = 0x6a, .value = 0x49},  	/* Zone 1 */
+	{.reg = 0x6b, .value = 0x49},  	/* Zone 2 */
+	{.reg = 0x6c, .value = 0x49},  	/* Zone 3 */
+	
+	/*
+	 * Interrupt Enable 1 Register
+	 */
+	{.reg = 0x7e, .value = 0x64},  	/* disable VCC and VCCP interrupts */
+
+	/*
+	 * Configuration Register
+	 */
+	{.reg = 0x7f, .value = 0x00},  	/* no soft reset, disable spin-up reduction,
+							PWM2 output, Tach3 input */
+
+	/*
+	 * Interrupt Enable 2 Register - Tachometer
+	 */
+	{.reg = 0x80, .value = 0x0e},  	/* disable TACH measurement control of
+							the INT# pin, enable status register updates */
+							
+	/*
+	 * Tach <--> PWM Association Register
+	 */
+	{.reg = 0x81, .value = 0xa4},  	/* associate TACH1 with PWM1,
+							TACH2 with PWM2 and TACH3 with PWM3 */
+
+	/*
+	 * Interrupt Enable 3 Register - Temperature Measurements
+	 */
+	{.reg = 0x82, .value = 0x04},  	/* disable Temperature measurement control of
+							the INT# pin, enable Remote Diode 1 monitor
+							to update the status register */
+							
+	/*
+	 * Tach Option Registers
+	 */
+	{.reg = 0x90, .value = 0x00},  	/* Tach 1, standard mode, 2 edges */
+	{.reg = 0x91, .value = 0x00},  	/* Tach 2, standard mode, 2 edges */
+	{.reg = 0x92, .value = 0x00},  	/* Tach 3, standard mode, 2 edges */
+	{.reg = 0x93, .value = 0x00},  	/* Tach 4, standard mode, 2 edges */
+
+	/*
+	 * PWM Otion Registers
+	 */
+	{.reg = 0x94, .value = 0x08},  	/* PWM1, 16 clocks guard time, step PWM down */
+	{.reg = 0x95, .value = 0x08},  	/* PWM2, 16 clocks guard time, step PWM down */
+	{.reg = 0x96, .value = 0x08},  	/* PWM3, 16 clocks guard time, step PWM down */
+	
+	/*
+	 * Ready / Lock / Start Register
+	 */
+	{.reg = 0x40, .value = 0x01},  	/* enable monitoring and PWM control */  
+};
+
+#define	I2C_FAN_BUS		(0)
+#define	EMC2300_SLAVE	(0x2e)
+
+// Fan setup for VECPE BMC.
+//
+int
+vecpe_bmc_fan_init (void)
+{
+	int	i;
+	int	rc;
+	int	rsize;
+	uchar	buf[4];
+	fanreg_init_t	*rinit;
+
+	printf ("%s:%u\n", __func__, __LINE__);
+
+	rc = i2c_set_bus_num (I2C_FAN_BUS);
+	if (rc) {
+		if (rc) {
+			printf ("%s:%u\n", __func__, __LINE__);
+			printf ("    Error: unable to set Fan ctrl bus number!\n");
+			return rc;
+		}
+	}
+
+        /*
+	 * Get Company IDs
+	 */
+	if (i2c_read(EMC2300_SLAVE, 0x3E, 1, buf, 1)) {
+		printf ("%s:%u\n", __func__, __LINE__);
+		printf ("i2c read - error\n");
+#if 1		
+		return 1;
+#endif		
+	}
+		
+	if (buf[0] == 0x41) {
+		rinit = adt7475_init;
+		rsize = ARRAY_SIZE(adt7475_init);
+#if 1		
+		printf ("Adt7475 Fan ctrl detected.\n");
+#endif		
+	} else if (buf[0] == 0x5C) {
+		rinit = emc2300_init;
+		rsize = ARRAY_SIZE(emc2300_init);
+#if 1		
+		printf ("Emc2300 Fan ctrl detected.\n");
+#endif		
+	} else {
+		printf ("%s:%u\n", __func__, __LINE__);
+		printf ("    Error: unknown Fan ctrl detected!\n");
+#if 0		
+		return 1;
+#else		
+		printf ("!!! trying configure as Adt7475...\n");
+		rinit = adt7475_init;
+		rsize = ARRAY_SIZE(adt7475_init);
+#endif		
+	}
+
+	for (i = 0; i < rsize; i++) {
+		rc = i2c_write (EMC2300_SLAVE, rinit->reg, 1, &rinit->value, 1);
+		if (rc) {
+			printf ("%s:%u\n", __func__, __LINE__);
+			printf ("    Error: unable to write to Fan ctrl!\n");
+			printf ("    reg: 0x%2.2x  value: 0x%2.2x\n", rinit->reg, rinit->value);
+			return rc;
+		}
+		rinit++;
+	}
+
+	return 0;
+}
+
+int
+vecpe_bmc_early_init (void)
+{
+	int rc;
+
+	printf ("%s:%u\n", __func__, __LINE__);
+
+	rc = vecpe_bmc_gpio_init ();
+	if (rc)
+		return rc;
+
+	rc = vecpe_bmc_fan_init ();
+	if (rc)
+		return rc;
+}
diff -uNr uboot-custom-orig/board/silicom/ubmc335x/Kconfig uboot-custom-silicom/board/silicom/ubmc335x/Kconfig
--- uboot-custom-orig/board/silicom/ubmc335x/Kconfig	1970-01-01 08:00:00.000000000 +0800
+++ uboot-custom-silicom/board/silicom/ubmc335x/Kconfig	2018-08-04 21:16:32.285348479 +0800
@@ -0,0 +1,39 @@
+if TARGET_UBMC335X
+
+config SYS_BOARD
+	default "ubmc335x"
+
+config SYS_VENDOR
+	default "silicom"
+
+config SYS_SOC
+	default "am33xx"
+
+config SYS_CONFIG_NAME
+	default "ubmc335x"
+
+config CONS_INDEX
+	int "UART used for console"
+	range 1 6
+	default 1
+	help
+	  The AM335x SoC has a total of 6 UARTs (UART0 to UART5 as referenced
+	  in documentation, etc) available to it.  Depending on your specific
+	  board you may want something other than UART0 as for example the IDK
+	  uses UART3 so enter 4 here.
+
+config UMBC_SD_UBOOT
+	bool "Select to enable uboot build for sd card booting"
+	help
+		Select this, would cause the SPL MLO to load uboot from sdcard.
+		Also enables auto loading of dtb/zimage/rootfs from sd card
+		if not selected, then default autobooting from emmc with upgrade support
+
+config UBMC_UBOOT_ETH_INDX
+	range 1 2
+	default 1
+	help 
+		select which port to use for uboot ethernet traffic in the cpsw driver.
+		Default to (1), as ubmc_335x's 2 uses NCSI, we can't support ncsi inside uboot. 
+
+endif
diff -uNr uboot-custom-orig/board/silicom/ubmc335x/MAINTAINERS uboot-custom-silicom/board/silicom/ubmc335x/MAINTAINERS
--- uboot-custom-orig/board/silicom/ubmc335x/MAINTAINERS	1970-01-01 08:00:00.000000000 +0800
+++ uboot-custom-silicom/board/silicom/ubmc335x/MAINTAINERS	2018-08-04 21:16:32.285348479 +0800
@@ -0,0 +1,13 @@
+BAV335x BOARD
+M:	Gilles Gameiro <gilles@gigadevices.com>
+S:	Maintained
+F:	include/configs/bav335x.h
+F:	board/birdland/bav335x/Kconfig
+F:	board/birdland/bav335x/Makefile
+F:	board/birdland/bav335x/README
+F:	board/birdland/bav335x/board.c
+F:	board/birdland/bav335x/board.h
+F:	board/birdland/bav335x/mux.c
+F:	board/birdland/bav335x/u-boot.lds
+F:	configs/birdland_bav335a_defconfig
+F:	configs/birdland_bav335b_defconfig
diff -uNr uboot-custom-orig/board/silicom/ubmc335x/Makefile uboot-custom-silicom/board/silicom/ubmc335x/Makefile
--- uboot-custom-orig/board/silicom/ubmc335x/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ uboot-custom-silicom/board/silicom/ubmc335x/Makefile	2018-08-04 21:16:32.285348479 +0800
@@ -0,0 +1,14 @@
+#
+# Makefile
+#
+# Copyright (C) 2012-2014, Birdland Audio - http://birdland.com/oem
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+ifeq ($(CONFIG_SKIP_LOWLEVEL_INIT),)
+obj-y	:= mux.o
+endif
+
+obj-y	+= board.o
+obj-y   += emc2300_init.o
diff -uNr uboot-custom-orig/board/silicom/ubmc335x/mux.c uboot-custom-silicom/board/silicom/ubmc335x/mux.c
--- uboot-custom-orig/board/silicom/ubmc335x/mux.c	1970-01-01 08:00:00.000000000 +0800
+++ uboot-custom-silicom/board/silicom/ubmc335x/mux.c	2018-08-04 21:16:32.285348479 +0800
@@ -0,0 +1,615 @@
+/*
+ * mux.c
+ *
+ * Copyright (C) 2011 Texas Instruments Incorporated - http://www.ti.com/
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation version 2.
+ *
+ * This program is distributed "as is" WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ */
+
+#include <common.h>
+#include <asm/arch/sys_proto.h>
+#include <asm/arch/hardware.h>
+#include <asm/arch/mux.h>
+#include <asm/io.h>
+#include <i2c.h>
+#include "board_detect.h"
+#include "board.h"
+#ifndef NO_SILC_UBMC
+//#include "vecpe_bmc_pinmux.h"
+#define RXDISABLE	(0x0 << 5)
+#define MUX_CFG_SILC(a,b)	MUX_CFG((b), (a))
+#endif
+
+static struct module_pin_mux uart0_pin_mux[] = {
+	{OFFSET(uart0_rxd), (MODE(0) | PULLUP_EN | RXACTIVE)},	/* UART0_RXD */
+	{OFFSET(uart0_txd), (MODE(0) | PULLUDEN)},		/* UART0_TXD */
+	{-1},
+};
+
+static struct module_pin_mux uart1_pin_mux[] = {
+	{OFFSET(uart1_rxd), (MODE(0) | PULLUP_EN | RXACTIVE)},	/* UART1_RXD */
+	{OFFSET(uart1_txd), (MODE(0) | PULLUDEN)},		/* UART1_TXD */
+	{-1},
+};
+
+static struct module_pin_mux uart2_pin_mux[] = {
+	{OFFSET(spi0_sclk), (MODE(1) | PULLUP_EN | RXACTIVE)},	/* UART2_RXD */
+	{OFFSET(spi0_d0), (MODE(1) | PULLUDEN)},		/* UART2_TXD */
+	{-1},
+};
+
+static struct module_pin_mux uart3_pin_mux[] = {
+	{OFFSET(spi0_cs1), (MODE(1) | PULLUP_EN | RXACTIVE)},	/* UART3_RXD */
+	{OFFSET(ecap0_in_pwm0_out), (MODE(1) | PULLUDEN)},	/* UART3_TXD */
+	{-1},
+};
+
+static struct module_pin_mux uart4_pin_mux[] = {
+	{OFFSET(gpmc_wait0), (MODE(6) | PULLUP_EN | RXACTIVE)},	/* UART4_RXD */
+	{OFFSET(gpmc_wpn), (MODE(6) | PULLUDEN)},		/* UART4_TXD */
+	{-1},
+};
+
+static struct module_pin_mux uart5_pin_mux[] = {
+	{OFFSET(lcd_data9), (MODE(4) | PULLUP_EN | RXACTIVE)},	/* UART5_RXD */
+	{OFFSET(lcd_data8), (MODE(4) | PULLUDEN)},		/* UART5_TXD */
+	{-1},
+};
+
+static struct module_pin_mux mmc0_pin_mux[] = {
+	{OFFSET(mmc0_dat3), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_DAT3 */
+	{OFFSET(mmc0_dat2), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_DAT2 */
+	{OFFSET(mmc0_dat1), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_DAT1 */
+	{OFFSET(mmc0_dat0), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_DAT0 */
+	{OFFSET(mmc0_clk), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_CLK */
+	{OFFSET(mmc0_cmd), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_CMD */
+	{OFFSET(mcasp0_aclkr), (MODE(4) | RXACTIVE)},		/* MMC0_WP */
+	{OFFSET(spi0_cs1), (MODE(7) | RXACTIVE | PULLUP_EN)},	/* GPIO0_6 */
+	{-1},
+};
+
+static struct module_pin_mux mmc0_no_cd_pin_mux[] = {
+	{OFFSET(mmc0_dat3), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_DAT3 */
+	{OFFSET(mmc0_dat2), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_DAT2 */
+	{OFFSET(mmc0_dat1), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_DAT1 */
+	{OFFSET(mmc0_dat0), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_DAT0 */
+	{OFFSET(mmc0_clk), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_CLK */
+	{OFFSET(mmc0_cmd), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_CMD */
+	{OFFSET(mcasp0_aclkr), (MODE(4) | RXACTIVE)},		/* MMC0_WP */
+	{-1},
+};
+
+static struct module_pin_mux mmc0_pin_mux_sk_evm[] = {
+	{OFFSET(mmc0_dat3), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_DAT3 */
+	{OFFSET(mmc0_dat2), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_DAT2 */
+	{OFFSET(mmc0_dat1), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_DAT1 */
+	{OFFSET(mmc0_dat0), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_DAT0 */
+	{OFFSET(mmc0_clk), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_CLK */
+	{OFFSET(mmc0_cmd), (MODE(0) | RXACTIVE | PULLUP_EN)},	/* MMC0_CMD */
+	{OFFSET(spi0_cs1), (MODE(5) | RXACTIVE | PULLUP_EN)},	/* MMC0_CD */
+	{-1},
+};
+
+static struct module_pin_mux mmc1_pin_mux[] = {
+	{OFFSET(gpmc_ad3), (MODE(1) | RXACTIVE | PULLUP_EN)},	/* MMC1_DAT3 */
+	{OFFSET(gpmc_ad2), (MODE(1) | RXACTIVE | PULLUP_EN)},	/* MMC1_DAT2 */
+	{OFFSET(gpmc_ad1), (MODE(1) | RXACTIVE | PULLUP_EN)},	/* MMC1_DAT1 */
+	{OFFSET(gpmc_ad0), (MODE(1) | RXACTIVE | PULLUP_EN)},	/* MMC1_DAT0 */
+	{OFFSET(gpmc_csn1), (MODE(2) | RXACTIVE | PULLUP_EN)},	/* MMC1_CLK */
+	{OFFSET(gpmc_csn2), (MODE(2) | RXACTIVE | PULLUP_EN)},	/* MMC1_CMD */
+	{OFFSET(gpmc_csn0), (MODE(7) | RXACTIVE | PULLUP_EN)},	/* MMC1_WP */
+	{OFFSET(gpmc_advn_ale), (MODE(7) | RXACTIVE | PULLUP_EN)},	/* MMC1_CD */
+	{-1},
+};
+
+static struct module_pin_mux i2c0_pin_mux[] = {
+	{OFFSET(i2c0_sda), (MODE(0) | RXACTIVE |
+			PULLUDEN | SLEWCTRL)}, /* I2C_DATA */
+	{OFFSET(i2c0_scl), (MODE(0) | RXACTIVE |
+			PULLUDEN | SLEWCTRL)}, /* I2C_SCLK */
+	{-1},
+};
+
+static struct module_pin_mux i2c1_pin_mux[] = {
+	{OFFSET(spi0_d1), (MODE(2) | RXACTIVE |
+			PULLUDEN | SLEWCTRL)},	/* I2C_DATA */
+	{OFFSET(spi0_cs0), (MODE(2) | RXACTIVE |
+			PULLUDEN | SLEWCTRL)},	/* I2C_SCLK */
+	{-1},
+};
+
+static struct module_pin_mux spi0_pin_mux[] = {
+	{OFFSET(spi0_sclk), (MODE(0) | RXACTIVE | PULLUDEN)},	/* SPI0_SCLK */
+	{OFFSET(spi0_d0), (MODE(0) | RXACTIVE |
+			PULLUDEN | PULLUP_EN)},			/* SPI0_D0 */
+	{OFFSET(spi0_d1), (MODE(0) | RXACTIVE | PULLUDEN)},	/* SPI0_D1 */
+	{OFFSET(spi0_cs0), (MODE(0) | RXACTIVE |
+			PULLUDEN | PULLUP_EN)},			/* SPI0_CS0 */
+	{-1},
+};
+
+static struct module_pin_mux gpio0_7_pin_mux[] = {
+	{OFFSET(ecap0_in_pwm0_out), (MODE(7) | PULLUDEN)},	/* GPIO0_7 */
+	{-1},
+};
+
+static struct module_pin_mux gpio0_18_pin_mux[] = {
+	{OFFSET(usb0_drvvbus), (MODE(7) | PULLUDEN)},	/* GPIO0_18 */
+	{-1},
+};
+
+static struct module_pin_mux rgmii1_pin_mux[] = {
+	{OFFSET(mii1_txen), MODE(2)},			/* RGMII1_TCTL */
+	{OFFSET(mii1_rxdv), MODE(2) | RXACTIVE},	/* RGMII1_RCTL */
+	{OFFSET(mii1_txd3), MODE(2)},			/* RGMII1_TD3 */
+	{OFFSET(mii1_txd2), MODE(2)},			/* RGMII1_TD2 */
+	{OFFSET(mii1_txd1), MODE(2)},			/* RGMII1_TD1 */
+	{OFFSET(mii1_txd0), MODE(2)},			/* RGMII1_TD0 */
+	{OFFSET(mii1_txclk), MODE(2)},			/* RGMII1_TCLK */
+	{OFFSET(mii1_rxclk), MODE(2) | RXACTIVE},	/* RGMII1_RCLK */
+	{OFFSET(mii1_rxd3), MODE(2) | RXACTIVE},	/* RGMII1_RD3 */
+	{OFFSET(mii1_rxd2), MODE(2) | RXACTIVE},	/* RGMII1_RD2 */
+	{OFFSET(mii1_rxd1), MODE(2) | RXACTIVE},	/* RGMII1_RD1 */
+	{OFFSET(mii1_rxd0), MODE(2) | RXACTIVE},	/* RGMII1_RD0 */
+	{OFFSET(mdio_data), MODE(0) | RXACTIVE | PULLUP_EN},/* MDIO_DATA */
+	{OFFSET(mdio_clk), MODE(0) | PULLUP_EN},	/* MDIO_CLK */
+	{-1},
+};
+
+static struct module_pin_mux mii1_pin_mux[] = {
+	{OFFSET(mii1_rxerr), MODE(0) | RXACTIVE},	/* MII1_RXERR */
+	{OFFSET(mii1_txen), MODE(0)},			/* MII1_TXEN */
+	{OFFSET(mii1_rxdv), MODE(0) | RXACTIVE},	/* MII1_RXDV */
+	{OFFSET(mii1_txd3), MODE(0)},			/* MII1_TXD3 */
+	{OFFSET(mii1_txd2), MODE(0)},			/* MII1_TXD2 */
+	{OFFSET(mii1_txd1), MODE(0)},			/* MII1_TXD1 */
+	{OFFSET(mii1_txd0), MODE(0)},			/* MII1_TXD0 */
+	{OFFSET(mii1_txclk), MODE(0) | RXACTIVE},	/* MII1_TXCLK */
+	{OFFSET(mii1_rxclk), MODE(0) | RXACTIVE},	/* MII1_RXCLK */
+	{OFFSET(mii1_rxd3), MODE(0) | RXACTIVE},	/* MII1_RXD3 */
+	{OFFSET(mii1_rxd2), MODE(0) | RXACTIVE},	/* MII1_RXD2 */
+	{OFFSET(mii1_rxd1), MODE(0) | RXACTIVE},	/* MII1_RXD1 */
+	{OFFSET(mii1_rxd0), MODE(0) | RXACTIVE},	/* MII1_RXD0 */
+	{OFFSET(mdio_data), MODE(0) | RXACTIVE | PULLUP_EN}, /* MDIO_DATA */
+	{OFFSET(mdio_clk), MODE(0) | PULLUP_EN},	/* MDIO_CLK */
+	{-1},
+};
+
+static struct module_pin_mux rmii1_pin_mux[] = {
+	{OFFSET(mdio_clk), MODE(0) | PULLUP_EN},	/* MDIO_CLK */
+	{OFFSET(mdio_data), MODE(0) | RXACTIVE | PULLUP_EN}, /* MDIO_DATA */
+	{OFFSET(mii1_crs), MODE(1) | RXACTIVE},		/* MII1_CRS */
+	{OFFSET(mii1_rxerr), MODE(1) | RXACTIVE},	/* MII1_RXERR */
+	{OFFSET(mii1_txen), MODE(1)},			/* MII1_TXEN */
+	{OFFSET(mii1_txd1), MODE(1)},			/* MII1_TXD1 */
+	{OFFSET(mii1_txd0), MODE(1)},			/* MII1_TXD0 */
+	{OFFSET(mii1_rxd1), MODE(1) | RXACTIVE},	/* MII1_RXD1 */
+	{OFFSET(mii1_rxd0), MODE(1) | RXACTIVE},	/* MII1_RXD0 */
+	{OFFSET(rmii1_refclk), MODE(0) | RXACTIVE},	/* RMII1_REFCLK */
+	{-1},
+};
+
+#ifdef CONFIG_NAND
+static struct module_pin_mux nand_pin_mux[] = {
+	{OFFSET(gpmc_ad0),	(MODE(0) | PULLUDDIS | RXACTIVE)}, /* AD0  */
+	{OFFSET(gpmc_ad1),	(MODE(0) | PULLUDDIS | RXACTIVE)}, /* AD1  */
+	{OFFSET(gpmc_ad2),	(MODE(0) | PULLUDDIS | RXACTIVE)}, /* AD2  */
+	{OFFSET(gpmc_ad3),	(MODE(0) | PULLUDDIS | RXACTIVE)}, /* AD3  */
+	{OFFSET(gpmc_ad4),	(MODE(0) | PULLUDDIS | RXACTIVE)}, /* AD4  */
+	{OFFSET(gpmc_ad5),	(MODE(0) | PULLUDDIS | RXACTIVE)}, /* AD5  */
+	{OFFSET(gpmc_ad6),	(MODE(0) | PULLUDDIS | RXACTIVE)}, /* AD6  */
+	{OFFSET(gpmc_ad7),	(MODE(0) | PULLUDDIS | RXACTIVE)}, /* AD7  */
+#ifdef CONFIG_SYS_NAND_BUSWIDTH_16BIT
+	{OFFSET(gpmc_ad8),	(MODE(0) | PULLUDDIS | RXACTIVE)}, /* AD8  */
+	{OFFSET(gpmc_ad9),	(MODE(0) | PULLUDDIS | RXACTIVE)}, /* AD9  */
+	{OFFSET(gpmc_ad10),	(MODE(0) | PULLUDDIS | RXACTIVE)}, /* AD10 */
+	{OFFSET(gpmc_ad11),	(MODE(0) | PULLUDDIS | RXACTIVE)}, /* AD11 */
+	{OFFSET(gpmc_ad12),	(MODE(0) | PULLUDDIS | RXACTIVE)}, /* AD12 */
+	{OFFSET(gpmc_ad13),	(MODE(0) | PULLUDDIS | RXACTIVE)}, /* AD13 */
+	{OFFSET(gpmc_ad14),	(MODE(0) | PULLUDDIS | RXACTIVE)}, /* AD14 */
+	{OFFSET(gpmc_ad15),	(MODE(0) | PULLUDDIS | RXACTIVE)}, /* AD15 */
+#endif
+	{OFFSET(gpmc_wait0),	(MODE(0) | PULLUP_EN | RXACTIVE)}, /* nWAIT */
+	{OFFSET(gpmc_wpn),	(MODE(7) | PULLUP_EN)},		   /* nWP */
+	{OFFSET(gpmc_csn0),	(MODE(0) | PULLUP_EN)},		   /* nCS */
+	{OFFSET(gpmc_wen),	(MODE(0) | PULLDOWN_EN)},	   /* WEN */
+	{OFFSET(gpmc_oen_ren),	(MODE(0) | PULLDOWN_EN)},	   /* OE */
+	{OFFSET(gpmc_advn_ale),	(MODE(0) | PULLDOWN_EN)},	   /* ADV_ALE */
+	{OFFSET(gpmc_be0n_cle),	(MODE(0) | PULLDOWN_EN)},	   /* BE_CLE */
+	{-1},
+};
+#elif defined(CONFIG_NOR)
+static struct module_pin_mux bone_norcape_pin_mux[] = {
+	{OFFSET(gpmc_a0), MODE(0) | PULLUDDIS},			/* NOR_A0 */
+	{OFFSET(gpmc_a1), MODE(0) | PULLUDDIS},			/* NOR_A1 */
+	{OFFSET(gpmc_a2), MODE(0) | PULLUDDIS},			/* NOR_A2 */
+	{OFFSET(gpmc_a3), MODE(0) | PULLUDDIS},			/* NOR_A3 */
+	{OFFSET(gpmc_a4), MODE(0) | PULLUDDIS},			/* NOR_A4 */
+	{OFFSET(gpmc_a5), MODE(0) | PULLUDDIS},			/* NOR_A5 */
+	{OFFSET(gpmc_a6), MODE(0) | PULLUDDIS},			/* NOR_A6 */
+	{OFFSET(gpmc_a7), MODE(0) | PULLUDDIS},			/* NOR_A7 */
+	{OFFSET(gpmc_ad0), MODE(0) | PULLUDDIS | RXACTIVE},	/* NOR_AD0 */
+	{OFFSET(gpmc_ad1), MODE(0) | PULLUDDIS | RXACTIVE},	/* NOR_AD1 */
+	{OFFSET(gpmc_ad2), MODE(0) | PULLUDDIS | RXACTIVE},	/* NOR_AD2 */
+	{OFFSET(gpmc_ad3), MODE(0) | PULLUDDIS | RXACTIVE},	/* NOR_AD3 */
+	{OFFSET(gpmc_ad4), MODE(0) | PULLUDDIS | RXACTIVE},	/* NOR_AD4 */
+	{OFFSET(gpmc_ad5), MODE(0) | PULLUDDIS | RXACTIVE},	/* NOR_AD5 */
+	{OFFSET(gpmc_ad6), MODE(0) | PULLUDDIS | RXACTIVE},	/* NOR_AD6 */
+	{OFFSET(gpmc_ad7), MODE(0) | PULLUDDIS | RXACTIVE},	/* NOR_AD7 */
+	{OFFSET(gpmc_ad8), MODE(0) | PULLUDDIS | RXACTIVE},	/* NOR_AD8 */
+	{OFFSET(gpmc_ad9), MODE(0) | PULLUDDIS | RXACTIVE},	/* NOR_AD9 */
+	{OFFSET(gpmc_ad10), MODE(0) | PULLUDDIS | RXACTIVE},	/* NOR_AD10 */
+	{OFFSET(gpmc_ad11), MODE(0) | PULLUDDIS | RXACTIVE},	/* NOR_AD11 */
+	{OFFSET(gpmc_ad12), MODE(0) | PULLUDDIS | RXACTIVE},	/* NOR_AD12 */
+	{OFFSET(gpmc_ad13), MODE(0) | PULLUDDIS | RXACTIVE},	/* NOR_AD13 */
+	{OFFSET(gpmc_ad14), MODE(0) | PULLUDDIS | RXACTIVE},	/* NOR_AD14 */
+	{OFFSET(gpmc_ad15), MODE(0) | PULLUDDIS | RXACTIVE},	/* NOR_AD15 */
+	{OFFSET(gpmc_csn0), MODE(0) | PULLUDEN | PULLUP_EN},     /* CE */
+	{OFFSET(gpmc_advn_ale), MODE(0) | PULLUDEN | PULLDOWN_EN}, /* ALE */
+	{OFFSET(gpmc_oen_ren), MODE(0) | PULLUDEN | PULLDOWN_EN},/* OEn_REN */
+	{OFFSET(gpmc_be0n_cle), MODE(0) | PULLUDEN | PULLDOWN_EN},/* unused */
+	{OFFSET(gpmc_wen), MODE(0) | PULLUDEN | PULLDOWN_EN},    /* WEN */
+	{OFFSET(gpmc_wait0), MODE(0) | PULLUDEN | PULLUP_EN | RXACTIVE},/*WAIT*/
+	{-1},
+};
+#endif
+
+static struct module_pin_mux uart3_icev2_pin_mux[] = {
+	{OFFSET(mii1_rxd3), (MODE(1) | PULLUP_EN | RXACTIVE)},	/* UART3_RXD */
+	{OFFSET(mii1_rxd2), MODE(1) | PULLUDEN},		/* UART3_TXD */
+	{-1},
+};
+
+#if defined(CONFIG_NOR_BOOT)
+void enable_norboot_pin_mux(void)
+{
+	configure_module_pin_mux(bone_norcape_pin_mux);
+}
+#endif
+
+void enable_uart0_pin_mux(void)
+{
+#ifdef NO_SILC_UBMC
+	configure_module_pin_mux(uart0_pin_mux);
+#else
+	MUX_CFG_SILC(OFFSET(uart0_txd),			 (RXDISABLE | PULLUDDIS | MODE(0) )) /* uart0_txd */;
+	MUX_CFG_SILC(OFFSET(uart0_rxd),			 (RXACTIVE  | PULLUDDIS | MODE(0) )) /* uart0_rxd */;
+	MUX_CFG_SILC(OFFSET(uart0_rtsn),		 (RXDISABLE | PULLUDDIS | MODE(0) )) /* uart0_rtsn */;
+	MUX_CFG_SILC(OFFSET(uart0_ctsn),		 (RXACTIVE  | PULLUDDIS | MODE(0) )) /* uart0_ctsn */;
+#endif
+}
+
+void enable_uart1_pin_mux(void)
+{
+#ifdef NO_SILC_UBMC
+	configure_module_pin_mux(uart1_pin_mux);
+#endif
+}
+
+void enable_uart2_pin_mux(void)
+{
+#ifdef NO_SILC_UBMC
+	configure_module_pin_mux(uart2_pin_mux);
+#endif
+}
+
+void enable_uart3_pin_mux(void)
+{
+#ifdef NO_SILC_UBMC
+	configure_module_pin_mux(uart3_pin_mux);
+#endif
+}
+
+void enable_uart4_pin_mux(void)
+{
+#ifdef NO_SILC_UBMC
+	configure_module_pin_mux(uart4_pin_mux);
+#endif
+}
+
+void enable_uart5_pin_mux(void)
+{
+#ifdef NO_SILC_UBMC
+	configure_module_pin_mux(uart5_pin_mux);
+#endif
+}
+
+void enable_i2c0_pin_mux(void)
+{
+#ifdef NO_SILC_UBMC
+	configure_module_pin_mux(i2c0_pin_mux);
+#endif
+}
+
+/*
+ * The AM335x GP EVM, if daughter card(s) are connected, can have 8
+ * different profiles.  These profiles determine what peripherals are
+ * valid and need pinmux to be configured.
+ */
+#define PROFILE_NONE	0x0
+#define PROFILE_0	(1 << 0)
+#define PROFILE_1	(1 << 1)
+#define PROFILE_2	(1 << 2)
+#define PROFILE_3	(1 << 3)
+#define PROFILE_4	(1 << 4)
+#define PROFILE_5	(1 << 5)
+#define PROFILE_6	(1 << 6)
+#define PROFILE_7	(1 << 7)
+#define PROFILE_MASK	0x7
+#define PROFILE_ALL	0xFF
+
+/* CPLD registers */
+#define I2C_CPLD_ADDR	0x35
+#define CFG_REG		0x10
+
+static unsigned short detect_daughter_board_profile(void)
+{
+	unsigned short val;
+
+	if (i2c_probe(I2C_CPLD_ADDR))
+		return PROFILE_NONE;
+
+	if (i2c_read(I2C_CPLD_ADDR, CFG_REG, 1, (unsigned char *)(&val), 2))
+		return PROFILE_NONE;
+
+	return (1 << (val & PROFILE_MASK));
+}
+
+void enable_board_pin_mux(void)
+{
+#if 0
+	/* Do board-specific muxes. */
+	if (board_is_bone()) {
+		/* Beaglebone pinmux */
+		configure_module_pin_mux(mii1_pin_mux);
+		configure_module_pin_mux(mmc0_pin_mux);
+#if defined(CONFIG_NAND)
+		configure_module_pin_mux(nand_pin_mux);
+#elif defined(CONFIG_NOR)
+		configure_module_pin_mux(bone_norcape_pin_mux);
+#else
+		configure_module_pin_mux(mmc1_pin_mux);
+#endif
+	} else if (board_is_gp_evm()) {
+		/* General Purpose EVM */
+		unsigned short profile = detect_daughter_board_profile();
+		configure_module_pin_mux(rgmii1_pin_mux);
+		configure_module_pin_mux(mmc0_pin_mux);
+		/* In profile #2 i2c1 and spi0 conflict. */
+		if (profile & ~PROFILE_2)
+			configure_module_pin_mux(i2c1_pin_mux);
+		/* Profiles 2 & 3 don't have NAND */
+#ifdef CONFIG_NAND
+		if (profile & ~(PROFILE_2 | PROFILE_3))
+			configure_module_pin_mux(nand_pin_mux);
+#endif
+		else if (profile == PROFILE_2) {
+			configure_module_pin_mux(mmc1_pin_mux);
+			configure_module_pin_mux(spi0_pin_mux);
+		}
+	} else if (board_is_idk()) {
+		/* Industrial Motor Control (IDK) */
+		configure_module_pin_mux(mii1_pin_mux);
+		configure_module_pin_mux(mmc0_no_cd_pin_mux);
+	} else if (board_is_evm_sk()) {
+		/* Starter Kit EVM */
+		configure_module_pin_mux(i2c1_pin_mux);
+		configure_module_pin_mux(gpio0_7_pin_mux);
+		configure_module_pin_mux(rgmii1_pin_mux);
+		configure_module_pin_mux(mmc0_pin_mux_sk_evm);
+	} else if (board_is_bone_lt()) {
+		/* Beaglebone LT pinmux */
+		configure_module_pin_mux(mii1_pin_mux);
+		configure_module_pin_mux(mmc0_pin_mux);
+#if defined(CONFIG_NAND) && defined(CONFIG_EMMC_BOOT)
+		configure_module_pin_mux(nand_pin_mux);
+#elif defined(CONFIG_NOR) && defined(CONFIG_EMMC_BOOT)
+		configure_module_pin_mux(bone_norcape_pin_mux);
+#else
+		configure_module_pin_mux(mmc1_pin_mux);
+#endif
+	} else if (board_is_icev2()) {
+		configure_module_pin_mux(mmc0_pin_mux);
+		configure_module_pin_mux(gpio0_18_pin_mux);
+		configure_module_pin_mux(uart3_icev2_pin_mux);
+		configure_module_pin_mux(rmii1_pin_mux);
+		configure_module_pin_mux(spi0_pin_mux);
+	} else {
+		/* Unknown board. We might still be able to boot. */
+		puts("Bad EEPROM or unknown board, cannot configure pinmux.");
+	}
+#else
+/*
+ * MODE(0) - Mux Mode 0
+ * MODE(1) - Mux Mode 1
+ * MODE(2) - Mux Mode 2
+ * MODE(3) - Mux Mode 3
+ * MODE(4) - Mux Mode 4
+ * MODE(5) - Mux Mode 5
+ * MODE(6) - Mux Mode 6
+ * MODE(7) - Mux Mode 7
+ * RXDISABLE - Receiver disabled
+ * RXACTIVE - Receiver enabled
+ * PULLUDEN - Internal pull-down
+ * PULLUP_EN - Internal pull-up
+ * PULLUDDIS - Internal pull disabled
+ */
+	printf("Setting board_pin_mux ubmc335x\n");
+
+	//I2C0
+	MUX_CFG_SILC(OFFSET(uart1_ctsn),		 (RXACTIVE  | PULLUDDIS | MODE(3) )) /* I2C2_SDA_mux0 */;
+	MUX_CFG_SILC(OFFSET(uart1_rtsn),		 (RXACTIVE  | PULLUDDIS | MODE(3) )) /* I2C2_SCL_mux0 */;
+	//I2C2
+	MUX_CFG_SILC(OFFSET(i2c0_sda),			 (RXACTIVE  | PULLUDDIS | MODE(0) )) /* I2C0_SDA */;
+	MUX_CFG_SILC(OFFSET(i2c0_scl),			 (RXACTIVE  | PULLUDDIS | MODE(0) )) /* I2C0_SCL */;
+	//UART0
+	MUX_CFG_SILC(OFFSET(uart0_ctsn),		 (RXACTIVE  | PULLUDDIS | MODE(0) )) /* uart0_ctsn */;
+	MUX_CFG_SILC(OFFSET(uart0_rtsn),		 (RXDISABLE | PULLUDDIS | MODE(0) )) /* uart0_rtsn */;
+	MUX_CFG_SILC(OFFSET(uart0_rxd),			 (RXACTIVE  | PULLUDDIS | MODE(0) )) /* uart0_rxd */;
+	MUX_CFG_SILC(OFFSET(uart0_txd),			 (RXDISABLE | PULLUDDIS | MODE(0) )) /* uart0_txd */;
+	//UART1
+	MUX_CFG_SILC(OFFSET(uart1_rxd),			 (RXACTIVE  | PULLUDDIS | MODE(0) )) /* uart1_rxd */;
+	MUX_CFG_SILC(OFFSET(uart1_txd),			 (RXDISABLE | PULLUDDIS | MODE(0) )) /* uart1_txd */;
+	//MMC0
+	MUX_CFG_SILC(OFFSET(mmc0_dat0),			 (RXACTIVE  | PULLUDDIS | MODE(0) )) /* mmc0_dat0 */;
+	MUX_CFG_SILC(OFFSET(mmc0_dat1),			 (RXACTIVE  | PULLUDDIS | MODE(0) )) /* mmc0_dat1 */;
+	MUX_CFG_SILC(OFFSET(mmc0_dat2),			 (RXACTIVE  | PULLUDDIS | MODE(0) )) /* mmc0_dat2 */;
+	MUX_CFG_SILC(OFFSET(mmc0_dat3),			 (RXACTIVE  | PULLUDDIS | MODE(0) )) /* mmc0_dat3 */;
+	MUX_CFG_SILC(OFFSET(mmc0_clk),			 (RXACTIVE  | PULLUDDIS | MODE(0) )) /* mmc0_clk */;
+	MUX_CFG_SILC(OFFSET(mmc0_cmd),			 (RXACTIVE  | PULLUDDIS | MODE(0) )) /* mmc0_cmd */;
+	//MMC1
+	MUX_CFG_SILC(OFFSET(gpmc_ad0),			 (RXACTIVE  | PULLUDDIS | MODE(1) )) /* mmc1_dat0_mux2 */;
+	MUX_CFG_SILC(OFFSET(gpmc_ad1),			 (RXACTIVE  | PULLUDDIS | MODE(1) )) /* mmc1_dat1_mux2 */;
+	MUX_CFG_SILC(OFFSET(gpmc_ad2),			 (RXACTIVE  | PULLUDDIS | MODE(1) )) /* mmc1_dat2_mux2 */;
+	MUX_CFG_SILC(OFFSET(gpmc_ad3),			 (RXACTIVE  | PULLUDDIS | MODE(1) )) /* mmc1_dat3_mux2 */;
+	MUX_CFG_SILC(OFFSET(gpmc_ad4),			 (RXACTIVE  | PULLUDDIS | MODE(1) )) /* mmc1_dat4_mux2 */;
+	MUX_CFG_SILC(OFFSET(gpmc_ad5),			 (RXACTIVE  | PULLUDDIS | MODE(1) )) /* mmc1_dat5_mux2 */;
+	MUX_CFG_SILC(OFFSET(gpmc_ad6),			 (RXACTIVE  | PULLUDDIS | MODE(1) )) /* mmc1_dat6_mux2 */;
+	MUX_CFG_SILC(OFFSET(gpmc_ad7),			 (RXACTIVE  | PULLUDDIS | MODE(1) )) /* mmc1_dat7_mux2 */;
+	MUX_CFG_SILC(OFFSET(gpmc_csn1),			 (RXACTIVE  | PULLUDDIS | MODE(2) )) /* mmc1_clk_mux0 */;
+	MUX_CFG_SILC(OFFSET(gpmc_csn2),			 (RXACTIVE  | PULLUDDIS | MODE(2) )) /* mmc1_cmd_mux0 */;
+	MUX_CFG_SILC(OFFSET(mcasp0_fsx),		 (RXACTIVE  | PULLUP_EN | MODE(4) )) /* mmc1_sdcd_mux1 */;
+	//RMII1
+	MUX_CFG_SILC(OFFSET(mii1_txen),			 (RXDISABLE | PULLUDDIS | MODE(2) )) /* rgmii1_tctl */;
+	MUX_CFG_SILC(OFFSET(mii1_rxdv),			 (RXACTIVE  | PULLUDDIS | MODE(2) )) /* rgmii1_rctl */;
+	MUX_CFG_SILC(OFFSET(mii1_txd3),			 (RXDISABLE | PULLUDDIS | MODE(2) )) /* rgmii1_td3 */;
+	MUX_CFG_SILC(OFFSET(mii1_txd2),			 (RXDISABLE | PULLUDDIS | MODE(2) )) /* rgmii1_td2 */;
+	MUX_CFG_SILC(OFFSET(mii1_txd1),			 (RXDISABLE | PULLUDDIS | MODE(2) )) /* rgmii1_td1 */;
+	MUX_CFG_SILC(OFFSET(mii1_txd0),			 (RXDISABLE | PULLUDDIS | MODE(2) )) /* rgmii1_td0 */;
+	MUX_CFG_SILC(OFFSET(mii1_txclk),		 (RXDISABLE | PULLUDDIS | MODE(2) )) /* rgmii1_tclk */;
+	MUX_CFG_SILC(OFFSET(mii1_rxclk),		 (RXACTIVE  | PULLUDDIS | MODE(2) )) /* rgmii1_rclk */;
+	MUX_CFG_SILC(OFFSET(mii1_rxd3),			 (RXACTIVE  | PULLUDDIS | MODE(2) )) /* rgmii1_rd3 */;
+	MUX_CFG_SILC(OFFSET(mii1_rxd2),			 (RXACTIVE  | PULLUDDIS | MODE(2) )) /* rgmii1_rd2 */;
+	MUX_CFG_SILC(OFFSET(mii1_rxd1),			 (RXACTIVE  | PULLUDDIS | MODE(2) )) /* rgmii1_rd1 */;
+	MUX_CFG_SILC(OFFSET(mii1_rxd0),			 (RXACTIVE  | PULLUDDIS | MODE(2) )) /* rgmii1_rd0 */;
+	//RMII2
+	MUX_CFG_SILC(OFFSET(gpmc_a0),			 (RXDISABLE | PULLUDDIS | MODE(3) )) /* rmii2_txen */;
+	MUX_CFG_SILC(OFFSET(gpmc_a4),			 (RXDISABLE | PULLUDDIS | MODE(3) )) /* rmii2_txd1 */;
+	MUX_CFG_SILC(OFFSET(gpmc_a5),			 (RXDISABLE | PULLUDDIS | MODE(3) )) /* rmii2_txd0 */;
+	MUX_CFG_SILC(OFFSET(gpmc_a10),			 (RXACTIVE  | PULLUDDIS | MODE(3) )) /* rmii2_rxd1 */;
+	MUX_CFG_SILC(OFFSET(gpmc_a11),			 (RXACTIVE  | PULLUDDIS | MODE(3) )) /* rmii2_rxd0 */;
+	MUX_CFG_SILC(OFFSET(gpmc_wait0),		 (RXACTIVE  | PULLUDDIS | MODE(3) )) /* rmii2_crs_dv_mux0 */;
+	MUX_CFG_SILC(OFFSET(mii1_col),			 (RXACTIVE  | PULLUDDIS | MODE(1) )) /* rmii2_refclk */;
+	//USB
+	MUX_CFG_SILC(OFFSET(usb0_drvvbus),		 (RXDISABLE | PULLUDEN  | MODE(0) )) /* USB0_DRVVBUS */;
+	MUX_CFG_SILC(OFFSET(usb1_drvvbus),		 (RXDISABLE | PULLUDEN  | MODE(0) )) /* USB1_DRVVBUS */;
+
+
+
+
+	MUX_CFG_SILC(OFFSET(mdio_data),			 (RXDISABLE | PULLUDDIS | MODE(7) )) /* gpio0[0] */;
+	MUX_CFG_SILC(OFFSET(mdio_clk),			 (RXDISABLE | PULLUDEN  | MODE(7) )) /* gpio0[1] */;
+	MUX_CFG_SILC(OFFSET(spi0_cs1),			 (RXDISABLE | PULLUDEN  | MODE(7) )) /* gpio0[6] */;
+	MUX_CFG_SILC(OFFSET(ecap0_in_pwm0_out),	 (RXDISABLE | PULLUDEN  | MODE(7) )) /* gpio0[7] */;
+	MUX_CFG_SILC(OFFSET(lcd_data12),		 (RXACTIVE  | PULLUDDIS | MODE(7) )) /* gpio0[8] */;
+	MUX_CFG_SILC(OFFSET(lcd_data13),		 (RXACTIVE  | PULLUDDIS | MODE(7) )) /* gpio0[9] */;
+	MUX_CFG_SILC(OFFSET(lcd_data14),		 (RXACTIVE  | PULLUDDIS | MODE(7) )) /* gpio0[10] */;
+	MUX_CFG_SILC(OFFSET(lcd_data15),		 (RXACTIVE  | PULLUDDIS | MODE(7) )) /* gpio0[11] */;
+	MUX_CFG_SILC(OFFSET(xdma_event_intr0),	 (RXACTIVE  | PULLUDDIS | MODE(7) )) /* gpio0[19] */;
+	MUX_CFG_SILC(OFFSET(xdma_event_intr1),	 (RXDISABLE | PULLUDEN  | MODE(7) )) /* gpio0[20] */;
+	MUX_CFG_SILC(OFFSET(gpmc_ad8),			 (RXDISABLE | PULLUDEN  | MODE(7) )) /* gpio0[22] */;
+	MUX_CFG_SILC(OFFSET(gpmc_ad9),			 (RXACTIVE  | PULLUDDIS | MODE(7) )) /* gpio0[23] */;
+	MUX_CFG_SILC(OFFSET(gpmc_ad10),			 (RXACTIVE  | PULLUDDIS | MODE(7) )) /* gpio0[26] */;
+	MUX_CFG_SILC(OFFSET(gpmc_ad11),			 (RXDISABLE | PULLUDDIS | MODE(7) )) /* gpio0[27] */;
+	MUX_CFG_SILC(OFFSET(rmii1_refclk),		 (RXDISABLE | PULLUDDIS | MODE(7) )) /* gpio0[29] */;
+	MUX_CFG_SILC(OFFSET(gpmc_wpn),			 (RXDISABLE | PULLUDDIS | MODE(7) )) /* gpio0[31] */;
+
+
+	MUX_CFG_SILC(OFFSET(gpmc_ad12),			 (RXACTIVE  | PULLUDDIS | MODE(7) )) /* gpio1[12] */;
+	MUX_CFG_SILC(OFFSET(gpmc_ad13),			 (RXACTIVE  | PULLUDDIS | MODE(7) )) /* gpio1[13] */;
+	MUX_CFG_SILC(OFFSET(gpmc_ad14),			 (RXACTIVE  | PULLUDDIS | MODE(7) )) /* gpio1[14] */;
+	MUX_CFG_SILC(OFFSET(gpmc_ad15),			 (RXACTIVE  | PULLUDDIS | MODE(7) )) /* gpio1[15] */;
+	MUX_CFG_SILC(OFFSET(gpmc_a1),			 (RXACTIVE  | PULLUDEN  | MODE(7) )) /* gpio1[17] */;
+	MUX_CFG_SILC(OFFSET(gpmc_a2),			 (RXACTIVE  | PULLUDEN  | MODE(7) )) /* gpio1[18] */;
+	MUX_CFG_SILC(OFFSET(gpmc_a3),			 (RXACTIVE  | PULLUDEN  | MODE(7) )) /* gpio1[19] */;
+	MUX_CFG_SILC(OFFSET(gpmc_a6),			 (RXDISABLE | PULLUDDIS | MODE(7) )) /* gpio1[22] */;
+	MUX_CFG_SILC(OFFSET(gpmc_a7),			 (RXACTIVE  | PULLUDDIS | MODE(7) )) /* gpio1[23] */;
+	MUX_CFG_SILC(OFFSET(gpmc_a8),			 (RXACTIVE  | PULLUDDIS | MODE(7) )) /* gpio1[24] */;
+	MUX_CFG_SILC(OFFSET(gpmc_a9),			 (RXACTIVE  | PULLUDDIS | MODE(7) )) /* gpio1[25] */;
+	MUX_CFG_SILC(OFFSET(gpmc_be1n),			 (RXDISABLE | PULLUP_EN | MODE(7) )) /* gpio1[28] */;
+	MUX_CFG_SILC(OFFSET(gpmc_csn0),			 (RXACTIVE  | PULLUDDIS | MODE(7) )) /* gpio1[29] */;
+
+	MUX_CFG_SILC(OFFSET(gpmc_csn3),			 (RXACTIVE  | PULLUDDIS | MODE(7) )) /* gpio2[0] */;
+	MUX_CFG_SILC(OFFSET(gpmc_advn_ale),		 (RXACTIVE  | PULLUDDIS | MODE(7) )) /* gpio2[2] */;
+	MUX_CFG_SILC(OFFSET(gpmc_oen_ren),		 (RXDISABLE | PULLUDDIS | MODE(7) )) /* gpio2[3] */;
+	MUX_CFG_SILC(OFFSET(gpmc_wen),			 (RXACTIVE  | PULLUDDIS | MODE(7) )) /* gpio2[4] */;
+	MUX_CFG_SILC(OFFSET(gpmc_clk),			 (RXACTIVE  | PULLUDDIS | MODE(7) )) /* gpio2[1] */;
+	MUX_CFG_SILC(OFFSET(gpmc_be0n_cle),		 (RXDISABLE | PULLUP_EN | MODE(7) )) /* gpio2[5] */;
+	MUX_CFG_SILC(OFFSET(lcd_data11),		 (RXACTIVE  | PULLUDDIS | MODE(7) )) /* gpio2[17] */;
+	MUX_CFG_SILC(OFFSET(lcd_data10),		 (RXACTIVE  | PULLUDDIS | MODE(7) )) /* gpio2[16] */;
+	MUX_CFG_SILC(OFFSET(lcd_data9),			 (RXACTIVE  | PULLUDDIS | MODE(7) )) /* gpio2[15] */;
+	MUX_CFG_SILC(OFFSET(lcd_data8),			 (RXACTIVE  | PULLUDDIS | MODE(7) )) /* gpio2[14] */;
+	MUX_CFG_SILC(OFFSET(lcd_data7),			 (RXACTIVE  | PULLUDDIS | MODE(7) )) /* gpio2[13] */;
+	MUX_CFG_SILC(OFFSET(lcd_data6),			 (RXACTIVE  | PULLUDDIS | MODE(7) )) /* gpio2[12] */;
+	MUX_CFG_SILC(OFFSET(lcd_data5),			 (RXACTIVE  | PULLUDDIS | MODE(7) )) /* gpio2[11] */;
+	MUX_CFG_SILC(OFFSET(lcd_data4),			 (RXACTIVE  | PULLUDDIS | MODE(7) )) /* gpio2[10] */;
+	MUX_CFG_SILC(OFFSET(lcd_data3),			 (RXACTIVE  | PULLUDDIS | MODE(7) )) /* gpio2[9] */;
+	MUX_CFG_SILC(OFFSET(lcd_data2),			 (RXACTIVE  | PULLUDDIS | MODE(7) )) /* gpio2[8] */;
+	MUX_CFG_SILC(OFFSET(lcd_data1),			 (RXACTIVE  | PULLUDDIS | MODE(7) )) /* gpio2[7] */;
+	MUX_CFG_SILC(OFFSET(lcd_data0),			 (RXACTIVE  | PULLUDDIS | MODE(7) )) /* gpio2[6] */;
+	MUX_CFG_SILC(OFFSET(lcd_vsync),			 (RXDISABLE | PULLUP_EN | MODE(7) )) /* gpio2[22] */;
+	MUX_CFG_SILC(OFFSET(lcd_hsync),			 (RXDISABLE | PULLUDDIS | MODE(7) )) /* gpio2[23] */;
+	MUX_CFG_SILC(OFFSET(lcd_pclk),			 (RXACTIVE  | PULLUDEN  | MODE(7) )) /* gpio2[24] */;
+	MUX_CFG_SILC(OFFSET(lcd_ac_bias_en),	 (RXDISABLE | PULLUDDIS | MODE(7) )) /* gpio2[25] */;
+
+
+
+
+
+	MUX_CFG_SILC(OFFSET(mii1_crs),			 (RXDISABLE | PULLUDEN  | MODE(7) )) /* gpio3[1] */;
+	MUX_CFG_SILC(OFFSET(mii1_rxerr),		 (RXDISABLE | PULLUDEN  | MODE(7) )) /* gpio3[2] */;
+	MUX_CFG_SILC(OFFSET(mcasp0_aclkr),		 (RXDISABLE | PULLUDEN  | MODE(7) )) /* gpio3[18] */;
+	MUX_CFG_SILC(OFFSET(mcasp0_aclkx),		 (RXDISABLE | PULLUDEN  | MODE(7) )) /* gpio3[14] */;
+
+	MUX_CFG_SILC(OFFSET(mcasp0_ahclkr),		 (RXDISABLE | PULLUDEN  | MODE(7) )) /* gpio3[17] */;
+	MUX_CFG_SILC(OFFSET(mcasp0_ahclkx),		 (RXDISABLE | PULLUDDIS | MODE(7) )) /* gpio3[21] */;
+
+	MUX_CFG_SILC(OFFSET(mcasp0_axr0),		 (RXDISABLE | PULLUDEN  | MODE(7) )) /* gpio3[16] */;
+	MUX_CFG_SILC(OFFSET(mcasp0_axr1),		 (RXDISABLE | PULLUDEN  | MODE(7) )) /* gpio3[20] */;
+
+	MUX_CFG_SILC(OFFSET(mcasp0_fsr),		 (RXDISABLE | PULLUDEN  | MODE(7) )) /* gpio3[19] */;
+
+	MUX_CFG_SILC(OFFSET(spi0_sclk),			 (RXDISABLE | PULLUDDIS | MODE(0) )) /* spi0_sclk */;
+	MUX_CFG_SILC(OFFSET(spi0_cs0),			 (RXDISABLE | PULLUDDIS | MODE(0) )) /* spi0_cs0 */;
+	MUX_CFG_SILC(OFFSET(spi0_d0),			 (RXACTIVE  | PULLUDDIS | MODE(0) )) /* spi0_d0 */;
+	MUX_CFG_SILC(OFFSET(spi0_d1),			 (RXDISABLE | PULLUDDIS | MODE(0) )) /* spi0_d1 */;
+
+
+
+	MUX_CFG_SILC(OFFSET(rtc_porz),			 (RXACTIVE  | PULLUDDIS | MODE(0) )) /* RTC_porz */;
+
+	MUX_CFG_SILC(OFFSET(enz_kaldo_1p8v),	 (RXACTIVE  | PULLUDDIS | MODE(0) )) /* ENZ_KALDO_1P8V */;
+
+	MUX_CFG_SILC(OFFSET(pmic_power_en),		 (RXDISABLE | PULLUP_EN | MODE(0) )) /* PMIC_POWER_EN */;
+
+
+	MUX_CFG_SILC(OFFSET(nresetin_out),		 (RXACTIVE  | PULLUDDIS | MODE(0) )) /* nRESETIN_OUT */;
+
+	MUX_CFG_SILC(OFFSET(nnmi),				 (RXACTIVE  | PULLUDDIS | MODE(0) )) /* nNMI */;
+
+	MUX_CFG_SILC(OFFSET(ext_wakeup),		 (RXACTIVE  | PULLUDEN  | MODE(0) )) /* EXT_WAKEUP */;
+
+	MUX_CFG_SILC(OFFSET(tck),				 (RXACTIVE  | PULLUDDIS | MODE(0) )) /* TCK */;
+	MUX_CFG_SILC(OFFSET(tdi),				 (RXACTIVE  | PULLUDDIS | MODE(0) )) /* TDI */;
+	MUX_CFG_SILC(OFFSET(tdo),				 (RXDISABLE | PULLUDDIS | MODE(0) )) /* TDO */;
+	MUX_CFG_SILC(OFFSET(tms),				 (RXACTIVE  | PULLUDDIS | MODE(0) )) /* TMS */;
+	MUX_CFG_SILC(OFFSET(ntrst),				 (RXACTIVE  | PULLUP_EN | MODE(0) )) /* nTRST */;
+
+	MUX_CFG_SILC(OFFSET(emu0),				 (RXACTIVE  | PULLUP_EN | MODE(0) )) /* EMU0 */;
+	MUX_CFG_SILC(OFFSET(emu1),				 (RXACTIVE  | PULLUP_EN | MODE(0) )) /* EMU1 */;
+
+
+#endif
+
+	i2c_init(100000, 1);
+
+	printf ("#### FUNC %s: LINE : %u VECPE BMC early setup.\n", __func__, __LINE__);
+	vecpe_bmc_early_init ();
+}
diff -uNr uboot-custom-orig/board/silicom/ubmc335x/README uboot-custom-silicom/board/silicom/ubmc335x/README
--- uboot-custom-orig/board/silicom/ubmc335x/README	1970-01-01 08:00:00.000000000 +0800
+++ uboot-custom-silicom/board/silicom/ubmc335x/README	2018-07-23 22:42:52.964237002 +0800
@@ -0,0 +1,15 @@
+Summary
+=======
+
+This document covers various features of the 'ubmc335x' board build.
+For more information about this board, visit http://birdland.com/oem
+
+
+Hardware
+========
+
+Silicom ubmc hardware
+
+Customization
+=============
+
diff -uNr uboot-custom-orig/board/silicom/ubmc335x/u-boot.lds uboot-custom-silicom/board/silicom/ubmc335x/u-boot.lds
--- uboot-custom-orig/board/silicom/ubmc335x/u-boot.lds	1970-01-01 08:00:00.000000000 +0800
+++ uboot-custom-silicom/board/silicom/ubmc335x/u-boot.lds	2018-07-23 22:42:52.965236992 +0800
@@ -0,0 +1,116 @@
+/*
+ * Copyright (c) 2012-2014 Birdland Audio - http://birdland.com/oem
+ * Copyright (c) 2004-2008 Texas Instruments
+ *
+ * (C) Copyright 2002
+ * Gary Jennejohn, DENX Software Engineering, <garyj@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+OUTPUT_FORMAT("elf32-littlearm", "elf32-littlearm", "elf32-littlearm")
+OUTPUT_ARCH(arm)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text :
+	{
+		*(.__image_copy_start)
+		*(.vectors)
+		CPUDIR/start.o (.text*)
+		board/silicom/ubmc335x/built-in.o (.text*)
+		*(.text*)
+	}
+
+	. = ALIGN(4);
+	.rodata : { *(SORT_BY_ALIGNMENT(SORT_BY_NAME(.rodata*))) }
+
+	. = ALIGN(4);
+	.data : {
+		*(.data*)
+	}
+
+	. = ALIGN(4);
+
+	. = .;
+
+	. = ALIGN(4);
+	.u_boot_list : {
+		KEEP(*(SORT(.u_boot_list*)));
+	}
+
+	. = ALIGN(4);
+
+	.image_copy_end :
+	{
+		*(.__image_copy_end)
+	}
+
+	.rel_dyn_start :
+	{
+		*(.__rel_dyn_start)
+	}
+
+	.rel.dyn : {
+		*(.rel*)
+	}
+
+	.rel_dyn_end :
+	{
+		*(.__rel_dyn_end)
+	}
+
+	.hash : { *(.hash*) }
+
+	.end :
+	{
+		*(.__end)
+	}
+
+	_image_binary_end = .;
+
+	/*
+	 * Deprecated: this MMU section is used by pxa at present but
+	 * should not be used by new boards/CPUs.
+	 */
+	. = ALIGN(4096);
+	.mmutable : {
+		*(.mmutable)
+	}
+
+/*
+ * Compiler-generated __bss_start and __bss_end, see arch/arm/lib/bss.c
+ * __bss_base and __bss_limit are for linker only (overlay ordering)
+ */
+
+	.bss_start __rel_dyn_start (OVERLAY) : {
+		KEEP(*(.__bss_start));
+		__bss_base = .;
+	}
+
+	.bss __bss_base (OVERLAY) : {
+		*(.bss*)
+		 . = ALIGN(4);
+		 __bss_limit = .;
+	}
+
+	.bss_end __bss_limit (OVERLAY) : {
+		KEEP(*(.__bss_end));
+	}
+
+	.dynsym _image_binary_end : { *(.dynsym) }
+	.dynbss : { *(.dynbss) }
+	.dynstr : { *(.dynstr*) }
+	.dynamic : { *(.dynamic*) }
+	.gnu.hash : { *(.gnu.hash) }
+	.plt : { *(.plt*) }
+	.interp : { *(.interp*) }
+	.gnu : { *(.gnu*) }
+	.ARM.exidx : { *(.ARM.exidx*) }
+}
diff -uNr uboot-custom-orig/board/silicom/ubmc335x/vecpe_bmc_pinmux.h uboot-custom-silicom/board/silicom/ubmc335x/vecpe_bmc_pinmux.h
--- uboot-custom-orig/board/silicom/ubmc335x/vecpe_bmc_pinmux.h	1970-01-01 08:00:00.000000000 +0800
+++ uboot-custom-silicom/board/silicom/ubmc335x/vecpe_bmc_pinmux.h	2018-07-23 22:42:52.965236992 +0800
@@ -0,0 +1,187 @@
+#ifndef _VECPE_BMC_PINMUX_H_
+#define _VECPE_BMC_PINMUX_H_
+
+/*
+	Use 4 space tabs and things will look much better.
+*/
+
+/*
+ * MODE(0) - Mux Mode 0
+ * MODE(1) - Mux Mode 1
+ * MODE(2) - Mux Mode 2
+ * MODE(3) - Mux Mode 3
+ * MODE(4) - Mux Mode 4
+ * MODE(5) - Mux Mode 5
+ * MODE(6) - Mux Mode 6
+ * MODE(7) - Mux Mode 7
+ * RXDISABLE - Receiver disabled
+ * RXACTIVE - Receiver enabled
+ * PULLUDEN - Internal pull-down
+ * PULLUP_EN - Internal pull-up
+ * PULLUDDIS - Internal pull disabled
+ */
+#define RXDISABLE	(0x0 << 5)
+
+#define MUX_UBMC() \
+MUX_CFG(gpmc_a0,			 (RXDISABLE | PULLUDDIS | MODE(3) )) /* rmii2_txen */\
+MUX_CFG(gpmc_a1,			 (RXACTIVE  | PULLUDEN  | MODE(7) )) /* gpio1[17] */\
+MUX_CFG(gpmc_a2,			 (RXACTIVE  | PULLUDEN  | MODE(7) )) /* gpio1[18] */\
+MUX_CFG(gpmc_a3,			 (RXACTIVE  | PULLUDEN  | MODE(7) )) /* gpio1[19] */\
+MUX_CFG(gpmc_a4,			 (RXDISABLE | PULLUDDIS | MODE(3) )) /* rmii2_txd1 */\
+MUX_CFG(gpmc_a5,			 (RXDISABLE | PULLUDDIS | MODE(3) )) /* rmii2_txd0 */\
+MUX_CFG(gpmc_a6,			 (RXDISABLE | PULLUDDIS | MODE(7) )) /* gpio1[22] */\
+MUX_CFG(gpmc_a7,			 (RXACTIVE  | PULLUDDIS | MODE(7) )) /* gpio1[23] */\
+MUX_CFG(gpmc_a8,			 (RXACTIVE  | PULLUDDIS | MODE(7) )) /* gpio1[24] */\
+MUX_CFG(gpmc_a9,			 (RXACTIVE  | PULLUDDIS | MODE(7) )) /* gpio1[25] */\
+MUX_CFG(gpmc_a10,			 (RXACTIVE  | PULLUDDIS | MODE(3) )) /* rmii2_rxd1 */\
+MUX_CFG(gpmc_a11,			 (RXACTIVE  | PULLUDDIS | MODE(3) )) /* rmii2_rxd0 */\
+\
+MUX_CFG(gpmc_ad0,			 (RXACTIVE  | PULLUDDIS | MODE(1) )) /* mmc1_dat0_mux2 */\
+MUX_CFG(gpmc_ad1,			 (RXACTIVE  | PULLUDDIS | MODE(1) )) /* mmc1_dat1_mux2 */\
+MUX_CFG(gpmc_ad2,			 (RXACTIVE  | PULLUDDIS | MODE(1) )) /* mmc1_dat2_mux2 */\
+MUX_CFG(gpmc_ad3,			 (RXACTIVE  | PULLUDDIS | MODE(1) )) /* mmc1_dat3_mux2 */\
+MUX_CFG(gpmc_ad4,			 (RXACTIVE  | PULLUDDIS | MODE(1) )) /* mmc1_dat4_mux2 */\
+MUX_CFG(gpmc_ad5,			 (RXACTIVE  | PULLUDDIS | MODE(1) )) /* mmc1_dat5_mux2 */\
+MUX_CFG(gpmc_ad6,			 (RXACTIVE  | PULLUDDIS | MODE(1) )) /* mmc1_dat6_mux2 */\
+MUX_CFG(gpmc_ad7,			 (RXACTIVE  | PULLUDDIS | MODE(1) )) /* mmc1_dat7_mux2 */\
+MUX_CFG(gpmc_ad8,			 (RXDISABLE | PULLUDEN  | MODE(7) )) /* gpio0[22] */\
+MUX_CFG(gpmc_ad9,			 (RXACTIVE  | PULLUDDIS | MODE(7) )) /* gpio0[23] */\
+MUX_CFG(gpmc_ad10,			 (RXACTIVE  | PULLUDDIS | MODE(7) )) /* gpio0[26] */\
+MUX_CFG(gpmc_ad11,			 (RXDISABLE | PULLUDDIS | MODE(7) )) /* gpio0[27] */\
+MUX_CFG(gpmc_ad12,			 (RXACTIVE  | PULLUDDIS | MODE(7) )) /* gpio1[12] */\
+MUX_CFG(gpmc_ad13,			 (RXACTIVE  | PULLUDDIS | MODE(7) )) /* gpio1[13] */\
+MUX_CFG(gpmc_ad14,			 (RXACTIVE  | PULLUDDIS | MODE(7) )) /* gpio1[14] */\
+MUX_CFG(gpmc_ad15,			 (RXACTIVE  | PULLUDDIS | MODE(7) )) /* gpio1[15] */\
+\
+MUX_CFG(gpmc_csn0,			 (RXACTIVE  | PULLUDDIS | MODE(7) )) /* gpio1[29] */\
+MUX_CFG(gpmc_csn1,			 (RXACTIVE  | PULLUDDIS | MODE(2) )) /* mmc1_clk_mux0 */\
+MUX_CFG(gpmc_csn2,			 (RXACTIVE  | PULLUDDIS | MODE(2) )) /* mmc1_cmd_mux0 */\
+MUX_CFG(gpmc_csn3,			 (RXACTIVE  | PULLUDDIS | MODE(7) )) /* gpio2[0] */\
+\
+MUX_CFG(gpmc_advn_ale,		 (RXACTIVE  | PULLUDDIS | MODE(7) )) /* gpio2[2] */\
+MUX_CFG(gpmc_oen_ren,		 (RXDISABLE | PULLUDDIS | MODE(7) )) /* gpio2[3] */\
+MUX_CFG(gpmc_wen,			 (RXACTIVE  | PULLUDDIS | MODE(7) )) /* gpio2[4] */\
+MUX_CFG(gpmc_wpn,			 (RXDISABLE | PULLUDDIS | MODE(7) )) /* gpio0[31] */\
+MUX_CFG(gpmc_clk,			 (RXACTIVE  | PULLUDDIS | MODE(7) )) /* gpio2[1] */\
+MUX_CFG(gpmc_ben0_cle,		 (RXDISABLE | PULLUDDIS | MODE(7) )) /* gpio2[5] */\
+MUX_CFG(gpmc_ben1,			 (RXDISABLE | PULLUDDIS | MODE(7) )) /* gpio1[28] */\
+MUX_CFG(gpmc_wait0,			 (RXACTIVE  | PULLUDDIS | MODE(3) )) /* rmii2_crs_dv_mux0 */\
+\
+MUX_CFG(mmc0_dat0,			 (RXACTIVE  | PULLUDDIS | MODE(0) )) /* mmc0_dat0 */\
+MUX_CFG(mmc0_dat1,			 (RXACTIVE  | PULLUDDIS | MODE(0) )) /* mmc0_dat1 */\
+MUX_CFG(mmc0_dat2,			 (RXACTIVE  | PULLUDDIS | MODE(0) )) /* mmc0_dat2 */\
+MUX_CFG(mmc0_dat3,			 (RXACTIVE  | PULLUDDIS | MODE(0) )) /* mmc0_dat3 */\
+\
+MUX_CFG(mmc0_clk,			 (RXACTIVE  | PULLUDDIS | MODE(0) )) /* mmc0_clk */\
+MUX_CFG(mmc0_cmd,			 (RXACTIVE  | PULLUDDIS | MODE(0) )) /* mmc0_cmd */\
+\
+MUX_CFG(usb0_drvvbus,		 (RXDISABLE | PULLUDEN  | MODE(0) )) /* USB0_DRVVBUS */\
+MUX_CFG(usb1_drvvbus,		 (RXDISABLE | PULLUDEN  | MODE(0) )) /* USB1_DRVVBUS */\
+\
+MUX_CFG(uart0_txd,			 (RXDISABLE | PULLUDDIS | MODE(0) )) /* uart0_txd */\
+MUX_CFG(uart0_rxd,			 (RXACTIVE  | PULLUDDIS | MODE(0) )) /* uart0_rxd */\
+MUX_CFG(uart0_rtsn,			 (RXDISABLE | PULLUDDIS | MODE(0) )) /* uart0_rtsn */\
+MUX_CFG(uart0_ctsn,			 (RXACTIVE  | PULLUDDIS | MODE(0) )) /* uart0_ctsn */\
+\
+MUX_CFG(uart1_txd,			 (RXDISABLE | PULLUDDIS | MODE(0) )) /* uart1_txd */\
+MUX_CFG(uart1_rxd,			 (RXACTIVE  | PULLUDDIS | MODE(0) )) /* uart1_rxd */\
+MUX_CFG(uart1_rtsn,			 (RXACTIVE  | PULLUDDIS | MODE(3) )) /* I2C2_SCL_mux0 */\
+MUX_CFG(uart1_ctsn,			 (RXACTIVE  | PULLUDDIS | MODE(3) )) /* I2C2_SDA_mux0 */\
+\
+MUX_CFG(i2c0_sda,			 (RXACTIVE  | PULLUDDIS  | MODE(0) )) /* I2C0_SDA */\
+MUX_CFG(i2c0_scl,			 (RXACTIVE  | PULLUDDIS  | MODE(0) )) /* I2C0_SCL */\
+\
+MUX_CFG(spi0_sclk,			 (RXDISABLE | PULLUDDIS | MODE(0) )) /* spi0_sclk */\
+MUX_CFG(spi0_cs0,			 (RXDISABLE | PULLUDDIS | MODE(0) )) /* spi0_cs0 */\
+MUX_CFG(spi0_cs1,			 (RXDISABLE | PULLUDEN  | MODE(7) )) /* gpio0[6] */\
+MUX_CFG(spi0_d0,			 (RXACTIVE  | PULLUDDIS | MODE(0) )) /* spi0_d0 */\
+MUX_CFG(spi0_d1,			 (RXDISABLE | PULLUDDIS | MODE(0) )) /* spi0_d1 */\
+\
+MUX_CFG(lcd_data15,			 (RXACTIVE  | PULLUDDIS | MODE(7) )) /* gpio0[11] */\
+MUX_CFG(lcd_data14,			 (RXACTIVE  | PULLUDDIS | MODE(7) )) /* gpio0[10] */\
+MUX_CFG(lcd_data13,			 (RXACTIVE  | PULLUDDIS | MODE(7) )) /* gpio0[9] */\
+MUX_CFG(lcd_data12,			 (RXACTIVE  | PULLUDDIS | MODE(7) )) /* gpio0[8] */\
+MUX_CFG(lcd_data11,			 (RXACTIVE  | PULLUDDIS | MODE(7) )) /* gpio2[17] */\
+MUX_CFG(lcd_data10,			 (RXACTIVE  | PULLUDDIS | MODE(7) )) /* gpio2[16] */\
+MUX_CFG(lcd_data9,			 (RXACTIVE  | PULLUDDIS | MODE(7) )) /* gpio2[15] */\
+MUX_CFG(lcd_data8,			 (RXACTIVE  | PULLUDDIS | MODE(7) )) /* gpio2[14] */\
+MUX_CFG(lcd_data7,			 (RXACTIVE  | PULLUDDIS | MODE(7) )) /* gpio2[13] */\
+MUX_CFG(lcd_data6,			 (RXACTIVE  | PULLUDDIS | MODE(7) )) /* gpio2[12] */\
+MUX_CFG(lcd_data5,			 (RXACTIVE  | PULLUDDIS | MODE(7) )) /* gpio2[11] */\
+MUX_CFG(lcd_data4,			 (RXACTIVE  | PULLUDDIS | MODE(7) )) /* gpio2[10] */\
+MUX_CFG(lcd_data3,			 (RXACTIVE  | PULLUDDIS | MODE(7) )) /* gpio2[9] */\
+MUX_CFG(lcd_data2,			 (RXACTIVE  | PULLUDDIS | MODE(7) )) /* gpio2[8] */\
+MUX_CFG(lcd_data1,			 (RXACTIVE  | PULLUDDIS | MODE(7) )) /* gpio2[7] */\
+MUX_CFG(lcd_data0,			 (RXACTIVE  | PULLUDDIS | MODE(7) )) /* gpio2[6] */\
+\
+MUX_CFG(lcd_pclk,			 (RXACTIVE  | PULLUDEN  | MODE(7) )) /* gpio2[24] */\
+\
+MUX_CFG(lcd_vsync,			 (RXDISABLE | PULLUDDIS | MODE(7) )) /* gpio2[22] */\
+MUX_CFG(lcd_hsync,			 (RXDISABLE | PULLUDDIS | MODE(7) )) /* gpio2[23] */\
+\
+MUX_CFG(lcd_ac_bias_en,		 (RXDISABLE | PULLUDDIS | MODE(7) )) /* gpio2[25] */\
+\
+MUX_CFG(mii1_txd0,			 (RXDISABLE | PULLUDDIS | MODE(2) )) /* rgmii1_td0 */\
+MUX_CFG(mii1_txd1,			 (RXDISABLE | PULLUDDIS | MODE(2) )) /* rgmii1_td1 */\
+MUX_CFG(mii1_txd2,			 (RXDISABLE | PULLUDDIS | MODE(2) )) /* rgmii1_td2 */\
+MUX_CFG(mii1_txd3,			 (RXDISABLE | PULLUDDIS | MODE(2) )) /* rgmii1_td3 */\
+\
+MUX_CFG(mii1_tx_clk,		 (RXDISABLE | PULLUDDIS | MODE(2) )) /* rgmii1_tclk */\
+MUX_CFG(mii1_tx_en,			 (RXDISABLE | PULLUDDIS | MODE(2) )) /* rgmii1_tctl */\
+MUX_CFG(mii1_crs,			 (RXDISABLE | PULLUDEN  | MODE(7) )) /* gpio3[1] */\
+MUX_CFG(mii1_col,			 (RXACTIVE  | PULLUDDIS | MODE(1) )) /* rmii2_refclk */\
+\
+MUX_CFG(mii1_rxd0,			 (RXACTIVE  | PULLUDDIS | MODE(2) )) /* rgmii1_rd0 */\
+MUX_CFG(mii1_rxd1,			 (RXACTIVE  | PULLUDDIS | MODE(2) )) /* rgmii1_rd1 */\
+MUX_CFG(mii1_rxd2,			 (RXACTIVE  | PULLUDDIS | MODE(2) )) /* rgmii1_rd2 */\
+MUX_CFG(mii1_rxd3,			 (RXACTIVE  | PULLUDDIS | MODE(2) )) /* rgmii1_rd3 */\
+\
+MUX_CFG(mii1_rx_clk,		 (RXACTIVE  | PULLUDDIS | MODE(2) )) /* rgmii1_rclk */\
+MUX_CFG(mii1_rx_dv,			 (RXACTIVE  | PULLUDDIS | MODE(2) )) /* rgmii1_rctl */\
+MUX_CFG(mii1_rx_er,			 (RXDISABLE | PULLUDEN  | MODE(7) )) /* gpio3[2] */\
+\
+MUX_CFG(rmii1_ref_clk,		 (RXDISABLE | PULLUDDIS | MODE(7) )) /* gpio0[29] */\
+\
+MUX_CFG(mdio,				 (RXDISABLE | PULLUDDIS | MODE(7) )) /* gpio0[0] */\
+MUX_CFG(mdc,				 (RXDISABLE | PULLUDEN  | MODE(7) )) /* gpio0[1] */\
+\
+MUX_CFG(rtc_pwronrstn,		 (RXACTIVE  | PULLUDDIS | MODE(0) )) /* RTC_porz */\
+\
+MUX_CFG(rtc_kaldo_enn,		 (RXACTIVE  | PULLUDDIS | MODE(0) )) /* ENZ_KALDO_1P8V */\
+\
+MUX_CFG(pmic_power_en,		 (RXDISABLE | PULLUP_EN  | MODE(0) )) /* PMIC_POWER_EN */\
+\
+\
+MUX_CFG(warmrstn,			 (RXACTIVE  | PULLUDDIS | MODE(0) )) /* nRESETIN_OUT */\
+\
+MUX_CFG(extintn,			 (RXACTIVE  | PULLUDDIS | MODE(0) )) /* nNMI */\
+\
+MUX_CFG(ext_wakeup,			 (RXACTIVE  | PULLUDEN  | MODE(0) )) /* EXT_WAKEUP */\
+\
+MUX_CFG(tck,				 (RXACTIVE  | PULLUDDIS | MODE(0) )) /* TCK */\
+MUX_CFG(tdi,				 (RXACTIVE  | PULLUDDIS | MODE(0) )) /* TDI */\
+MUX_CFG(tdo,				 (RXDISABLE | PULLUDDIS | MODE(0) )) /* TDO */\
+MUX_CFG(tms,				 (RXACTIVE  | PULLUDDIS | MODE(0) )) /* TMS */\
+MUX_CFG(trstn,				 (RXACTIVE  | PULLUP_EN  | MODE(0) )) /* nTRST */\
+\
+MUX_CFG(emu0,				 (RXACTIVE  | PULLUP_EN  | MODE(0) )) /* EMU0 */\
+MUX_CFG(emu1,				 (RXACTIVE  | PULLUP_EN  | MODE(0) )) /* EMU1 */\
+\
+MUX_CFG(mcasp0_aclkr,		 (RXDISABLE | PULLUDEN  | MODE(7) )) /* gpio3[18] */\
+MUX_CFG(mcasp0_aclkx,		 (RXDISABLE | PULLUDEN  | MODE(7) )) /* gpio3[14] */\
+\
+MUX_CFG(mcasp0_ahclkr,		 (RXDISABLE | PULLUDEN  | MODE(7) )) /* gpio3[17] */\
+MUX_CFG(mcasp0_ahclkx,		 (RXDISABLE | PULLUDDIS | MODE(7) )) /* gpio3[21] */\
+\
+MUX_CFG(mcasp0_axr0,		 (RXDISABLE | PULLUDEN  | MODE(7) )) /* gpio3[16] */\
+MUX_CFG(mcasp0_axr1,		 (RXDISABLE | PULLUDEN  | MODE(7) )) /* gpio3[20] */\
+\
+MUX_CFG(mcasp0_fsr,			 (RXDISABLE | PULLUDEN  | MODE(7) )) /* gpio3[19] */\
+MUX_CFG(mcasp0_fsx,			 (RXACTIVE  | PULLUP_EN  | MODE(4) )) /* mmc1_sdcd_mux1 */\
+\
+MUX_CFG(ecap0_in_pwm0_out,	 (RXDISABLE | PULLUDEN  | MODE(7) )) /* gpio0[7] */\
+\
+MUX_CFG(xdma_event_intr0,	 (RXACTIVE  | PULLUDDIS | MODE(7) )) /* gpio0[19] */\
+MUX_CFG(xdma_event_intr1,	 (RXDISABLE | PULLUDEN  | MODE(7) )) /* gpio0[20] */\
+
+#endif
--- uboot-custom-orig/arch/arm/dts/ubmc335x.dts	1970-01-01 08:00:00.000000000 +0800
+++ uboot-custom-silicom/arch/arm/dts/ubmc335x.dts	2019-04-01 10:19:12.691579580 +0800
@@ -0,0 +1,924 @@
+/*
+ * Copyright (C) 2012 Texas Instruments Incorporated - http://www.ti.com/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+/dts-v1/;
+
+#include "am33xx.dtsi"
+#include <dt-bindings/interrupt-controller/irq.h>
+#include <dt-bindings/pinctrl/am33xx.h>
+
+/ {
+	model = "Silicom ubmc vecpe";
+	compatible = "silicom,ubmc335x", "ti,am33xx";
+
+	chosen {
+		stdout-path = &uart0;
+		tick-timer = &timer2;
+	};
+
+	cpus {
+		cpu@0 {
+			cpu0-supply = <&vdd1_reg>;
+		};
+	};
+
+	memory {
+		device_type = "memory";
+		reg = <0x80000000 0x20000000>; /* 512 MB */
+	};
+
+	vdd1_reg: fixedregulator@0 {
+		compatible = "regulator-fixed";
+		regulator-name = "vdd1_reg";
+		regulator-min-microvolt = <1100000>;
+		regulator-max-microvolt = <1100000>;
+		regulator-boot-on;
+	};
+
+	vmmc_reg: fixedregulator {
+		compatible = "regulator-fixed";
+		regulator-name = "vmmc_reg";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		regulator-boot-on;
+		regulator-always-on;
+	};
+
+	/* W_DISABLE_WWAN_N on gpio2_3 */
+	wlan_en_reg: fixedregulator@2 {
+		compatible = "regulator-fixed";
+		regulator-name = "wlan-en-regulator";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+
+		/* WLAN_EN GPIO for this board - Bank2, pin3 */
+		gpio = <&gpio2 3 0>;
+
+		/* WLAN card specific delay */
+		startup-delay-us = <70000>;
+		enable-active-high;
+	};
+
+	i2c_peci: i2c {
+		pinctrl-names = "default";
+		pinctrl-0 = <&i2c1_pins>;
+                gpios = <&gpio0 19 0>, /* sda */
+                        <&gpio3 21 0>; /* scl */
+
+		compatible = "i2c-gpio";
+		/* TODO - The linux version of this binding needs to set the gpio flags to (GPIO_ACTIVE_HIGH|GPIO_OPEN_DRAIN) */
+		sda-gpios = <&gpio0 19 0>;
+		scl-gpios = <&gpio3 21 0>;
+		i2c-gpio,delay-us = <5>;	/* ~100 kHz */
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		smbus_peci_r: smbus-peci@4b {
+			compatible = "smbus-peci";
+			reg = <0x4b>;
+		};
+		smbus_peci_w: smbus-peci@4c {
+			compatible = "smbus-peci";
+			reg = <0x4c>;
+			peci-bus@0 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+
+				peci-cputemp@cpu0 {
+					compatible = "intel,peci-cputemp";
+					reg = <0x30>;
+				};
+			};
+		};
+		/* TODO - Having a hwmon device for SMBus PECI would be cool */
+	};
+
+	peci: peci {
+		compatible = "simple-bus";
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges = <0x0 0x1e78b000 0x60>;
+
+		peci0: peci-bus@0 {
+			compatible = "peci-smbus";
+			reg = <0x0 0x60>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			interrupts = <15>;
+		};
+	};
+
+
+};
+
+&am33xx_pinmux {
+	pinctrl-names = "default";
+
+	/* BMC's master for sensors/PROMs */
+	i2c0_pins: pinmux_i2c0_pins {
+		pinctrl-single,pins = <
+			0x188 (PIN_INPUT | MUX_MODE0)	/* i2c0_sda.i2c0_sda */
+			0x18c (PIN_INPUT | MUX_MODE0)	/* i2c0_scl.i2c0_scl */
+		>;
+	};
+
+	/* I2C1 controller is unused, uses bit-banged SCL(gpio3_21) & SDA (gpio0_19) */
+	i2c1_pins: pinmux_i2c1_pins {
+		pinctrl-single,pins = <
+			0x1b0 (PIN_INPUT | MUX_MODE7)		/* xdma_event_intr0	gpio0[19] */
+			0x1ac (PIN_INPUT | MUX_MODE7)		/* mcasp0_ahclkx	gpio3[21] */
+		>;
+	};
+
+	/* I2C2 is slaved to SMB_HOST from denverton */
+	i2c2_pins: pinmux_i2c2_pins {
+		pinctrl-single,pins = <
+			0x178 (PIN_INPUT | MUX_MODE3)	/* uart1_ctsn.uart1_ctsn I2C2_SDA_mux0*/
+			0x17C (PIN_INPUT | MUX_MODE3)	/* uart1_rtsn.uart1_rtsn I2C2_SCL_mux0*/
+		>;
+	};
+
+	/* UART connected to Denverton ttyS0 */
+	uart0_pins: pinmux_uart0_pins {
+		pinctrl-single,pins = <
+			0x168 (PIN_INPUT | MUX_MODE0)	/* uart0_ctsn.uart0_ctsn */
+			0x16C (PIN_OUTPUT | MUX_MODE0)	/* uart0_rtsn.uart0_rtsn */
+			0x170 (PIN_INPUT | MUX_MODE0)	/* uart0_rxd.uart0_rxd */
+			0x174 (PIN_OUTPUT | MUX_MODE0)	/* uart0_txd.uart0_txd */
+		>;
+	};
+
+	/* UART for SoL operations */
+	uart1_pins: pinmux_uart1_pins {
+		pinctrl-single,pins = <
+			0x180 (PIN_INPUT | MUX_MODE0)	/* uart1_rxd.uart1_rxd */
+			0x184 (PIN_OUTPUT | MUX_MODE0)	/* uart1_txd.uart1_txd */
+		>;
+	};
+
+	/* Get a reference clock on xdma_event_intr1 */
+	clkout2_pin: pinmux_clkout2_pin {
+		pinctrl-single,pins = <
+#if 0
+			AM33XX_IOPAD(conf_xdma_event_intr1, PIN_OUTPUT_PULLDOWN | MUX_MODE3)	/* xdma_event_intr1.clkout2 */
+#endif
+			0x1b4 (PIN_OUTPUT_PULLDOWN | MUX_MODE7)	/* xdma_event_intr1	gpio0[20] */
+		>;
+	};
+
+	cpsw_default: cpsw_default {
+		pinctrl-single,pins = <
+			/* emac0 using RGMII1 */
+			0x114 (PIN_OUTPUT | MUX_MODE2)	/* mii1_txen.rgmii1_tctl */
+			0x118 (PIN_INPUT  | MUX_MODE2)	/* mii1_rxdv.rgmii1_rctl */
+			0x11c (PIN_OUTPUT | MUX_MODE2)	/* mii1_txd3.rgmii1_td3 */
+			0x120 (PIN_OUTPUT | MUX_MODE2)	/* mii1_txd2.rgmii1_td2 */
+			0x124 (PIN_OUTPUT | MUX_MODE2)	/* mii1_txd1.rgmii1_td1 */
+			0x128 (PIN_OUTPUT | MUX_MODE2)	/* mii1_txd0.rgmii1_td0 */
+			0x12c (PIN_OUTPUT | MUX_MODE2)	/* mii1_txclk.rgmii1_tclk */
+			0x130 (PIN_INPUT | MUX_MODE2)	/* mii1_rxclk.rgmii1_rclk */
+			0x134 (PIN_INPUT | MUX_MODE2)	/* mii1_rxd3.rgmii1_rd3 */
+			0x138 (PIN_INPUT | MUX_MODE2)	/* mii1_rxd2.rgmii1_rd2 */
+			0x13c (PIN_INPUT | MUX_MODE2)	/* mii1_rxd1.rgmii1_rd1 */
+			0x140 (PIN_INPUT | MUX_MODE2)	/* mii1_rxd0.rgmii1_rd0 */
+
+			/* emac1 using RMII2 */
+			0x40 (PIN_OUTPUT | MUX_MODE3)	/* gpmc_a0 mii2_txen.rgmii2_tctl */
+			0x50 (PIN_OUTPUT | MUX_MODE3)	/* gpmc_a4 mii2_txd1.rgmii2_td1 */
+			0x54 (PIN_OUTPUT | MUX_MODE3)	/* gpmc_a5 mii2_txd0.rgmii2_td0 */
+			0x68 (PIN_INPUT | MUX_MODE3)	/* gpmc_a10 mii2_rxd1.rgmii2_rd1 */
+			0x6c (PIN_INPUT | MUX_MODE3)	/* gpmc_a11 mii2_rxd0.rgmii2_rd0 */
+			0x70 (PIN_INPUT | MUX_MODE3)	/* gpmc_wait0 rgmii2_crs_dv_mux0 */
+			0x108 (PIN_INPUT | MUX_MODE1)	/* mii1_col rgmii2_refclk */
+
+			/* TODO - Update this once hardware is fixed, right now it's connected to FRU EEPROM mux select */
+			0x74 (PIN_INPUT_PULLDOWN | MUX_MODE3)	/* gpmc_wpn.rmii2_rxer */
+		>;
+	};
+
+	cpsw_sleep: cpsw_sleep{
+		pinctrl-single,pins = <
+			/* emac0 using RGMII1 */
+			0x114 (PIN_OUTPUT | MUX_MODE7)	/* mii1_txen.rgmii1_tctl */
+			0x118 (PIN_INPUT  | MUX_MODE7)	/* mii1_rxdv.rgmii1_rctl */
+			0x11c (PIN_OUTPUT | MUX_MODE7)	/* mii1_txd3.rgmii1_td3 */
+			0x120 (PIN_OUTPUT | MUX_MODE7)	/* mii1_txd2.rgmii1_td2 */
+			0x124 (PIN_OUTPUT | MUX_MODE7)	/* mii1_txd1.rgmii1_td1 */
+			0x128 (PIN_OUTPUT | MUX_MODE7)	/* mii1_txd0.rgmii1_td0 */
+			0x12c (PIN_OUTPUT | MUX_MODE7)	/* mii1_txclk.rgmii1_tclk */
+			0x130 (PIN_INPUT | MUX_MODE7)	/* mii1_rxclk.rgmii1_rclk */
+			0x134 (PIN_INPUT | MUX_MODE7)	/* mii1_rxd3.rgmii1_rd3 */
+			0x138 (PIN_INPUT | MUX_MODE7)	/* mii1_rxd2.rgmii1_rd2 */
+			0x13c (PIN_INPUT | MUX_MODE7)	/* mii1_rxd1.rgmii1_rd1 */
+			0x140 (PIN_INPUT | MUX_MODE7)	/* mii1_rxd0.rgmii1_rd0 */
+
+			/* emac1 using RMII2 */
+			0x40 (PIN_OUTPUT | MUX_MODE3)	/* gpmc_a0 mii2_txen.rgmii2_tctl */
+			0x50 (PIN_OUTPUT | MUX_MODE3)	/* gpmc_a4 mii2_txd1.rgmii2_td1 */
+			0x54 (PIN_OUTPUT | MUX_MODE3)	/* gpmc_a5 mii2_txd0.rgmii2_td0 */
+			0x68 (PIN_INPUT | MUX_MODE3)	/* gpmc_a10 mii2_rxd1.rgmii2_rd1 */
+			0x6c (PIN_INPUT | MUX_MODE3)	/* gpmc_a11 mii2_rxd0.rgmii2_rd0 */
+			0x70 (PIN_INPUT | MUX_MODE3)	/* gpmc_wait0 rgmii2_crs_dv_mux0 */
+			0x108 (PIN_INPUT | MUX_MODE1)	/* mii1_col rgmii2_refclk */
+
+			/* TODO - Update this once hardware is fixed, right now it's connected to FRU EEPROM mux select */
+			0x74 (PIN_INPUT_PULLDOWN | MUX_MODE7)	/* gpmc_wpn.rmii2_rxer */
+		>;
+	};
+
+	davinci_mdio_default: davinci_mdio_default {
+		pinctrl-single,pins = <
+			/* MDIO */
+			0x148 (PIN_INPUT_PULLUP | SLEWCTRL_FAST | MUX_MODE0)	/* mdio_data.mdio_data */
+			0x14c (PIN_OUTPUT_PULLUP | MUX_MODE0)			/* mdio_clk.mdio_clk */
+		>;
+	};
+
+	davinci_mdio_sleep: davinci_mdio_sleep {
+		pinctrl-single,pins = <
+			/* MDIO reset value */
+			0x148 (PIN_INPUT_PULLDOWN | MUX_MODE7)
+			0x14c (PIN_INPUT_PULLDOWN | MUX_MODE7)
+		>;
+	};
+
+	usb1_pins: usb1_pins {
+		pinctrl-single,pins = <
+			0x2c0 (PIN_OUTPUT_PULLDOWN | MUX_MODE0) /* usb0_drvvbus.usb0_drvvbus */
+		>;
+	};
+
+	usb2_pins: usb2_pins {
+		pinctrl-single,pins = <
+			0x2c4 (PIN_OUTPUT_PULLDOWN | MUX_MODE0) /* usb0_drvvbus.usb0_drvvbus */
+		>;
+	};
+
+	gpio0_pins: gpio0_pins {
+		pinctrl-single,pins = <
+			/* No connect */
+			0x164 (PIN_OUTPUT_PULLDOWN | MUX_MODE7)	/* ecap0_in_pwm0_out	gpio0[7] */
+
+			/* SYSBOOT_12 */
+			0xd0  (PIN_INPUT | MUX_MODE7)		/* lcd_data12,		gpio0[8] */
+			/* SYSBOOT_13 */
+			0xd4  (PIN_INPUT | MUX_MODE7)		/* lcd_data13,		gpio0[9] */
+
+			/* No connect */
+			0xd8  (PIN_INPUT | MUX_MODE7)		/* lcd_data14,		gpio0[10] */
+			0xdc  (PIN_INPUT | MUX_MODE7)		/* lcd_data15,		gpio0[11] */
+			0x20  (PIN_OUTPUT_PULLDOWN | MUX_MODE7)	/* gpmc_ad8		gpio0[22] */
+
+			/* PSU_LEFT_PWRGD */
+			0x24  (PIN_INPUT_PULLUP | MUX_MODE7)	/* gpmc_ad9		gpio0[23] */
+
+			/* PSU_RIGHT_PWRGD */
+			0x28  (PIN_INPUT_PULLUP | MUX_MODE7)	/* gpmc_ad10		gpio0[26] */
+
+			/* SPI_HOST_MUX_EN, leave as PD for Host owns until gpio driver loads */
+			0x2c  (PIN_OUTPUT_PULLDOWN | MUX_MODE7)	/* gpmc_ad11		gpio0[27] */
+
+			/* BMC_PWRBTN_OUT_N, leave as PU until gpio driver loads */
+			0x144 (PIN_INPUT_PULLUP | MUX_MODE7)	/* rmii1_refclk		gpio0[29] */
+
+/* TODO - Need a new home for HOST_FRU_EEPROM_MUX_SEL since we need to default rmii2_rxer on this pin */
+#if 0
+			0x74  (PIN_OUTPUT | MUX_MODE7)		/* gpmc_wpn		gpio0[31] */
+#endif
+		>;
+	};
+
+	gpio1_pins: gpio1_pins {
+		pinctrl-single,pins = <
+		/* HOST_PLTRST_N */
+			0x30 (PIN_INPUT | MUX_MODE7 ) 		/* gpmc_ad12,		gpio1[12] */
+		/* HOST_S45_N */
+			0x34 (PIN_INPUT | MUX_MODE7 ) 		/* gpmc_ad13,		gpio1[13] */
+		/* GPIO_HOST_1, unused currently */
+			0x38 (PIN_INPUT_PULLDOWN | MUX_MODE7 ) 	/* gpmc_ad14,		gpio1[14] */
+		/* HOST_S3_N */
+			0x3c (PIN_INPUT | MUX_MODE7 ) 		/* gpmc_ad15,		gpio1[15] */
+
+		/* No connect */
+			0x44 (PIN_INPUT_PULLDOWN | MUX_MODE7 )	/* gpmc_a1,		gpio1[17] */
+			0x48 (PIN_INPUT_PULLDOWN | MUX_MODE7 )	/* gpmc_a2,		gpio1[18] */
+			0x4c (PIN_INPUT_PULLDOWN | MUX_MODE7 )	/* gpmc_a3,		gpio1[19] */
+
+		/*
+		 * BMC_UART_MUX_SEL, leave as PD for Host owns until gpio driver loads
+		 * 0 = BMC connected to FP, host UART -> BMC SoL UART
+		 * 1 = Host UART -> FP, BMC SoL UART disconnected
+		 */
+			0x58 (PIN_INPUT_PULLDOWN | MUX_MODE7 )		/* gpmc_a6,		gpio1[22] */
+
+		/*
+		 * RS232_CABLE_DETECTED
+		 * 0 = no cable
+		 * 1 = cable attached
+		 */
+			0x5c (PIN_INPUT | MUX_MODE7 )		/* gpmc_a7,		gpio1[23] */
+
+		/* FP_RSTBTN_N */
+			0x60 (PIN_INPUT | MUX_MODE7 )		/* gpmc_a8,		gpio1[24] */
+
+		/* FP_PWRBTN_N */
+			0x64 (PIN_INPUT | MUX_MODE7 )		/* gpmc_a9,		gpio1[25] */
+
+		/* HOST_ERROR_N */
+			0x7c (PIN_INPUT | MUX_MODE7 )		/* gpmc_csn0,		gpio1[29] */
+
+
+		>;
+	};
+
+	gpio2_pins: gpio2_pins {
+		pinctrl-single,pins = <
+		/* GPIO_HOST_0 */
+			0x88 (PIN_INPUT_PULLDOWN | MUX_MODE7)	/* gpmc_csn3,		gpio2[0] */
+
+		/* HOST_PROCHOT_N */
+			0x8c (PIN_INPUT | MUX_MODE7)		/* gpmc_clk,		gpio2[1] */
+
+		/* HOST_THERMTRIP_N */
+			0x90 (PIN_INPUT | MUX_MODE7)		/* gpmc_advn_ale,	gpio2[2] */
+
+		/* DYING_GASP_N */
+			0x98 (PIN_INPUT | MUX_MODE7)		/* gpmc_wen,		gpio2[4] */
+
+		/* SYSBOOT[11:0] */
+			0xa0 (PIN_INPUT | MUX_MODE7)		/* lcd_data0,		gpio2[6] */
+			0xa4 (PIN_INPUT | MUX_MODE7)		/* lcd_data1,		gpio2[7] */
+			0xa8 (PIN_INPUT | MUX_MODE7)		/* lcd_data2,		gpio2[8] */
+			0xac (PIN_INPUT | MUX_MODE7)		/* lcd_data3,		gpio2[9] */
+			0xb0 (PIN_INPUT | MUX_MODE7)		/* lcd_data4,		gpio2[10] */
+			0xb4 (PIN_INPUT | MUX_MODE7)		/* lcd_data5,		gpio2[11] */
+			0xb8 (PIN_INPUT | MUX_MODE7)		/* lcd_data6,		gpio2[12] */
+			0xbc (PIN_INPUT | MUX_MODE7)		/* lcd_data7,		gpio2[13] */
+			0xc0 (PIN_INPUT | MUX_MODE7)		/* lcd_data8,		gpio2[14] */
+			0xc4 (PIN_INPUT | MUX_MODE7)		/* lcd_data9,		gpio2[15] */
+			0xc8 (PIN_INPUT | MUX_MODE7)		/* lcd_data10,		gpio2[16] */
+			0xcc (PIN_INPUT | MUX_MODE7)		/* lcd_data11,		gpio2[17] */
+
+		/*
+		 * BMC_FP_BUTTON_OVERRIDE
+		 * 0 = passthrough button to MB
+		 * 1 = BMC_*BTN_OUTN drives button to MB
+		 */
+			0xe4 (PIN_INPUT_PULLDOWN | MUX_MODE7)	/* lcd_hsync,		gpio2[23] */
+
+		/* TESTPOINT_SPARE */
+			0xe8 (PIN_INPUT_PULLDOWN | MUX_MODE7)	/* lcd_pclk,		gpio2[24] */
+
+		/* BMC_RSTBTN_OUT_N, leave as PU until gpio driver loads */
+			0xec (PIN_INPUT_PULLUP | MUX_MODE7 )	/* lcd_ac_bias_en,gpio2[25] */
+
+			0x94 (PIN_OUTPUT | MUX_MODE7 )		/* gpmc_oen_ren,	gpio2[3] */
+		>;
+	};
+
+	gpio3_pins: gpio3_pins {
+		pinctrl-single,pins = <
+		/* No connect */
+			0x10c (PIN_OUTPUT_PULLDOWN | MUX_MODE7)	/* mii1_crs,		gpio3[1] */
+			0x110 (PIN_OUTPUT_PULLDOWN | MUX_MODE7)	/* mii1_rxerr,		gpio3[2] */
+			0x190 (PIN_OUTPUT_PULLDOWN | MUX_MODE7)	/* mcasp0_aclkx,	gpio3[14] */
+			0x198 (PIN_OUTPUT_PULLDOWN | MUX_MODE7)	/* mcasp0_axr0,		gpio3[16] */
+			0x19c (PIN_OUTPUT_PULLDOWN | MUX_MODE7)	/* mcasp0_ahclkr,	gpio3[17] */
+			0x1a0 (PIN_OUTPUT_PULLDOWN | MUX_MODE7)	/* mcasp0_aclkr,	gpio3[18] */
+			0x1a4 (PIN_OUTPUT_PULLDOWN | MUX_MODE7)	/* mcasp0_fsr,		gpio3[19] */
+			0x1a8 (PIN_OUTPUT_PULLDOWN | MUX_MODE7)	/* mcasp0_axr1,		gpio3[20] */
+#if 0
+			0x1ac (PIN_OUTPUT | MUX_MODE7 )			/* mcasp0_ahclkx,	gpio3[21] */
+#endif
+		>;
+	};
+
+	gpio_led_pins: pinmux_gpio_led_pins {
+		pinctrl-single,pins = <
+		/* LED_BMC_BOT_GRN_N */
+			0x78 (PIN_INPUT_PULLUP | MUX_MODE7 )	/* gpmc_be1n,		gpio1[28] */
+
+		/* LED_BMC_BOT_BLU_N */
+			0xe0 (PIN_INPUT_PULLUP | MUX_MODE7 )	/* lcd_vsync,		gpio2[22] */
+
+		/* LED_BMC_BOT_RED_N */
+			0x9c (PIN_INPUT_PULLUP | MUX_MODE7 )	/* gpmc_be0n_cle,	gpio2[5] */
+		>;
+	};
+#if 0
+	misc_pins: misc_pins {
+		pinctrl-single,pins = <
+			0x1f8 (PIN_INPUT | MUX_MODE0 )		/* rtc_porz,		RTC_porz */
+			0x204 (PIN_INPUT | MUX_MODE0 )		/* enz_kaldo_1p8v,	ENZ_KALDO_1P8V */
+			0x1f4 (PIN_OUTPUT_PULLUP | MUX_MODE0 )	/* pmic_power_en,	PMIC_POWER_EN */
+			0x1b8 (PIN_INPUT | MUX_MODE0 )		/* nresetin_out,	nRESETIN_OUT */
+			0x1c0 (PIN_INPUT | MUX_MODE0 )		/* nnmi,		nNMI */
+			0x200 (PIN_INPUT_PULLDOWN | MUX_MODE0 )	/* ext_wakeup,		EXT_WAKEUP */
+			0x1dc (PIN_INPUT | MUX_MODE0 )		/* tck,			TCK */
+			0x1d4 (PIN_INPUT | MUX_MODE0 )		/* tdi,			TDI */
+			0x1d8 (PIN_OUTPUT | MUX_MODE0 )		/* tdo,			TDO */
+			0x1d0 (PIN_INPUT | MUX_MODE0 )		/* tms,			TMS */
+			0x1e0 (PIN_INPUT_PULLUP| MUX_MODE0 )	/* ntrst,		nTRST */
+			0x1e4 (PIN_INPUT_PULLUP| MUX_MODE0 )	/* emu0,		EMU0 */
+			0x1e8 (PIN_INPUT_PULLUP| MUX_MODE0 )	/* emu1,		EMU1 */
+		>;
+	};
+#endif
+	/*
+	 * mmc1 is the 4bit SD card interface, SDCD and SDWP are not connected to the SD cage
+	 *
+	 * Note: mmc1 from am33xx.dtsi is mmc0 in all other documentation.  Sigh.
+	 */
+	mmc1_pins: pinmux_mmc1_pins {
+		pinctrl-single,pins = <
+			0xf0 (PIN_INPUT | MUX_MODE0)	/* mmc0_dat0.mmc0_dat0 */
+			0xf4 (PIN_INPUT | MUX_MODE0)	/* mmc0_dat1.mmc0_dat1 */
+			0xf8 (PIN_INPUT | MUX_MODE0)	/* mmc0_dat2.mmc0_dat2 */
+			0xfc (PIN_INPUT | MUX_MODE0)	/* mmc0_dat3.mmc0_dat3 */
+			0x100 (PIN_INPUT | MUX_MODE0)	/* mmc0_clk.mmc0_clk */
+			0x104 (PIN_INPUT | MUX_MODE0)	/* mmc0_cmd.mmc0_cmd */
+#if 1
+			0x194 (PIN_INPUT_PULLDOWN | MUX_MODE7)	/* mcasp0_fsx mmc1_sdcd_mux1 */
+#endif
+		>;
+	};
+
+	/*
+	 * mmc2 is the 8bit eMMC interface, it's 3.3V only, pull ups on board
+	 *
+	 * Note: mmc2 from am33xx.dtsi is mmc1 in all other documentation.  Sigh.
+	 */
+	mmc2_pins: pinmux_mmc2_pins {
+		pinctrl-single,pins = <
+			0x0 (PIN_INPUT | MUX_MODE1)	/* gpmc_ad0.gpmc_ad0 mmc1_dat0_mux2 */
+			0x4 (PIN_INPUT | MUX_MODE1)	/* gpmc_ad1.gpmc_ad1 mmc1_dat1_mux2 */
+			0x8 (PIN_INPUT | MUX_MODE1)	/* gpmc_ad2.gpmc_ad2 mmc1_dat2_mux2 */
+			0xc (PIN_INPUT | MUX_MODE1)	/* gpmc_ad3.gpmc_ad3 mmc1_dat3_mux2 */
+			0x10 (PIN_INPUT | MUX_MODE1)	/* gpmc_ad4.gpmc_ad4 mmc1_dat4_mux2 */
+			0x14 (PIN_INPUT | MUX_MODE1)	/* gpmc_ad5.gpmc_ad5 mmc1_dat5_mux2 */
+			0x18 (PIN_INPUT | MUX_MODE1)	/* gpmc_ad6.gpmc_ad6 mmc1_dat6_mux2 */
+			0x1c (PIN_INPUT | MUX_MODE1)	/* gpmc_ad7.gpmc_ad7 mmc1_dat7_mux2 */
+			0x80 (PIN_INPUT | MUX_MODE2)	/* gpmc_csn1 mmc1_clk_mux0 */
+			0x84 (PIN_INPUT | MUX_MODE2)	/* gpmc_csn2 mmc1_cmd_mux0 */
+#if 0
+			0x194 (PIN_INPUT_PULLUP | MUX_MODE4)	/* mcasp0_fsx mmc1_sdcd_mux1 */
+#endif
+		>;
+	};
+
+	spi0_pins: pinmux_spi0_pins {
+		pinctrl-single,pins = <
+			0x150 (PIN_INPUT | MUX_MODE0 )		/* spi0_sclk,		spi0_sclk */
+			0x154 (PIN_INPUT | MUX_MODE0 )		/* spi0_d0,		spi0_d0 */
+			0x158 (PIN_OUTPUT | MUX_MODE0 )		/* spi0_d1,		spi0_d1 */
+			0x15c (PIN_OUTPUT | MUX_MODE0 )		/* spi0_cs0,		spi0_cs0 */
+			0x160 (PIN_INPUT | MUX_MODE0)	/* spi0_cs1,		gpio0[6] */
+		>;
+	};
+
+};
+
+&gpio0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&gpio0_pins>;
+
+	gpio-line-names =
+		"", /*  0 */
+		"", /*  1 */
+		"", /*  2 */
+		"", /*  3 */
+		"", /*  4 */
+		"", /*  5 */
+		"", /*  6 */
+		"", /*  7 */
+		"", /*  8 */
+		"", /*  9 */
+		"", /* 10 */
+		"", /* 11 */
+		"", /* 12 */
+		"", /* 13 */
+		"", /* 14 */
+		"", /* 15 */
+		"", /* 16 */
+		"", /* 17 */
+		"", /* 18 */
+		"SMB_PECI_DATA", /* 19 */
+		"", /* 20 */
+		"", /* 21 */
+		"", /* 22 */
+		"PSU_LEFT_PWRGD", /* 23 */
+		"", /* 24 */
+		"", /* 25 */
+		"PSU_RIGHT_PWRGD", /* 26 */
+		"SPI_HOST_MUX_EN", /* 27 */
+		"", /* 28 */
+		"BMC_PWRBTN_OUT_N", /* 29 */
+		"", /* 30 */
+		"HOST_FRU_EEPROM_MUX_SEL"; /* 31 */
+};
+
+&gpio1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&gpio1_pins>;
+
+	gpio-line-names =
+		"", /*  0 */
+		"", /*  1 */
+		"", /*  2 */
+		"", /*  3 */
+		"", /*  4 */
+		"", /*  5 */
+		"", /*  6 */
+		"", /*  7 */
+		"", /*  8 */
+		"", /*  9 */
+		"", /* 10 */
+		"", /* 11 */
+		"HOST_PLTRST_N", /* 12 */
+		"HOST_S45_N", /* 13 */
+		"GPIO_HOST_1", /* 14 */
+		"HOST_S3_N", /* 15 */
+		"", /* 16 */
+		"", /* 17 */
+		"", /* 18 */
+		"", /* 19 */
+		"", /* 20 */
+		"", /* 21 */
+		"BMC_UAR_MUX_SEL", /* 22 */
+		"RS232_CABLE_DETECTED", /* 23 */
+		"FP_RSTBTN_N", /* 24 */
+		"FP_PWRBTN_N", /* 25 */
+		"", /* 26 */
+		"", /* 27 */
+		"LED_BMC_BOT_GRN_N", /* 28 */
+		"HOST_ERROR_N", /* 29 */
+		"", /* 30 */
+		""; /* 31 */
+};
+
+&gpio2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&gpio2_pins>;
+
+	gpio-line-names =
+		"GPIO_HOST_0", /*  0 */
+		"HOST_PROCHOT_N", /*  1 */
+		"HOST_THERMTRIP_N", /*  2 */
+		"W_DIABLE_WWAN_N", /*  3 */
+		"DYING_GASP_N", /*  4 */
+		"LED_BMC_BOT_RED_N", /*  5 */
+		"", /*  6 */
+		"", /*  7 */
+		"SYSBOOT_SD_N", /*  8 */
+		"", /*  9 */
+		"", /* 10 */
+		"", /* 11 */
+		"", /* 12 */
+		"", /* 13 */
+		"", /* 14 */
+		"", /* 15 */
+		"", /* 16 */
+		"", /* 17 */
+		"", /* 18 */
+		"", /* 19 */
+		"", /* 20 */
+		"", /* 21 */
+		"LED_BMC_BOT_BLU_N", /* 22 */
+		"BMC_FP_BUTTON_OVERRIDE", /* 23 */
+		"TESTPOINT_SPARE", /* 24 */
+		"BMC_RSTBTN_OUT_N", /* 25 */
+		"", /* 26 */
+		"", /* 27 */
+		"", /* 28 */
+		"", /* 29 */
+		"", /* 30 */
+		""; /* 31 */
+};
+
+&gpio3 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&gpio3_pins>;
+
+	gpio-line-names =
+		"", /*  0 */
+		"", /*  1 */
+		"", /*  2 */
+		"", /*  3 */
+		"", /*  4 */
+		"", /*  5 */
+		"", /*  6 */
+		"", /*  7 */
+		"", /*  8 */
+		"", /*  9 */
+		"", /* 10 */
+		"", /* 11 */
+		"", /* 12 */
+		"", /* 13 */
+		"", /* 14 */
+		"", /* 15 */
+		"", /* 16 */
+		"", /* 17 */
+		"", /* 18 */
+		"", /* 19 */
+		"", /* 20 */
+		"SMB_PECI_CLK", /* 21 */
+		"", /* 22 */
+		"", /* 23 */
+		"", /* 24 */
+		"", /* 25 */
+		"", /* 26 */
+		"", /* 27 */
+		"", /* 28 */
+		"", /* 29 */
+		"", /* 30 */
+		""; /* 31 */
+};
+
+&uart0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&uart0_pins>;
+
+	status = "okay";
+};
+
+&uart1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&uart1_pins>;
+
+	status = "okay";
+};
+
+&i2c0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&i2c0_pins>;
+
+	status = "okay";
+	clock-frequency = <400000>;
+
+	bmc_fru: eeprom@50 {
+		compatible = "atmel,24c02";
+		reg = <0x50>;
+		pagesize = <16>;
+		size = <256>;
+	};
+
+	bmc_rtc: rtc@69 {
+		compatible = "atmel,max31341";
+		reg = <0x69>;
+	};
+
+	bmc_psd: psd@34 {
+		compatible = "ti,ucd90160";
+		reg = <0x34>;
+	};
+
+	/*
+	 * EMC2300 triple fan controller
+	 *
+	 * Probably need this patch in the kernel unless u-boot changes default mode
+	 * https://www.spinics.net/lists/lm-sensors/msg33203.html
+	 */
+	/**
+	*fan_ctl: lm85@5c {
+	*	 compatible = "smsc,emc6d103s";
+	*	 reg = <0x5c>;
+	*};
+	*/
+
+
+/*Use this fan node to reslove the issue that XS fan control i2c adr is conflict to S/M/L fan controler i2c adr like below adt7475 and emc2300 node*/
+/*Use the new compatible = "silc_fan" to make the kernel can probe fan_controller_0x2e*/
+/*Add "silc_fan" i2c_ids to emc2300.c  and adt7475.c in kernel */
+/*Depend on diffrent machine model ,system will load diffrent driver .See S35is_ipmi script*/
+/*fan controller for ubmc xs/s/m/l system*/
+	fan_controller_0x2e:silc_fan@2e {
+		compatible = "silc_fan";
+		reg = <0x2e>;
+		/*pwm-polarity = <1>;*/
+	};
+	
+
+
+/*
+	fan_controller: adt7475@2e {
+		compatible = "adi,adt7475";
+		reg = <0x2e>;
+		pwm-polarity = <1>;
+	};
+	emc2300: emc2300@2E {
+                compatible = "smsc,emc2300";
+                reg = <0x2E>;
+                #address-cells = <1>;
+                #size-cells = <0>;
+    };
+*/
+	
+
+
+	/* This is the FRU on the motherboard, the FRU_EEPROM_MUX_SEL must be set to see this device */
+	mb_fru: eeprom@56 {
+		compatible = "atmel,24c02";
+		reg = <0x56>;
+		pagesize = <16>;
+		size = <256>;
+	};
+
+	/* 8ch ADC for monitoring the MB voltage rails */
+
+	pac1014a: pac1014a@4a {
+		compatible = "pac1014a";
+		reg = <0x4a>;
+	};
+
+	ads7830: ads7830@48 {
+		compatible = "ti,ads7830";
+		reg = <0x48>;
+	};
+
+	/*gpio expender for uBMC large platform*/
+	pca9538: pca9538@72 {
+		compatible = "nxp,pca9538";
+		reg = <0x72>;
+	};
+};
+
+/* I2C2 is slaved to SMB_HOST from the Denverton processor */
+&i2c2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&i2c2_pins>;
+
+	status = "okay";
+	clock-frequency = <400000>;
+};
+
+&usb {
+	status = "okay";
+};
+
+&usb_ctrl_mod {
+	status = "okay";
+};
+
+&usb0_phy {
+	status = "okay";
+};
+
+&usb1_phy {
+	status = "okay";
+};
+
+&usb0 {
+	status = "okay";
+	dr_mode = "host";
+};
+
+&usb1 {
+	status = "okay";
+	dr_mode = "peripheral";
+};
+
+&cppi41dma  {
+	status = "okay";
+};
+
+&elm {
+	status = "okay";
+};
+
+&mac {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&cpsw_default>;
+	pinctrl-1 = <&cpsw_sleep>;
+	dual_emac = <1>;
+	slave_ncsi = <1>;
+	status = "okay";
+};
+
+&davinci_mdio {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&davinci_mdio_default>;
+	pinctrl-1 = <&davinci_mdio_sleep>;
+	status = "okay";
+};
+
+
+
+/*
+ * emac0 is RGMII interface to port 0 of the Marvell Peridot switch
+ *
+ * The TI part requires external delay of the clk relative to the data lines
+ *
+ * For receive (input to the AM3352) the waveform must look like:
+ *           _____       _
+ * RCLK    _/     \_____/
+ *         ____ _____ ____
+ * RD/RCTL ____X_____X____
+ *
+ *
+ * For transmit (output from the AM3352) the waveform looks like:
+ *           _____       _
+ * TCLK    _/     \_____/
+ *         _ _____ _____ _
+ * TD/TCTL _X_____X_____X_
+ *
+ */
+&cpsw_emac0 {
+	phy-mode = "rgmii-id";
+	dual_emac_res_vlan = <1>;
+	fixed-link {
+		   speed = <1000>;
+		   full-duplex;
+	};
+};
+
+/* emac1 is RMII NC-SI interface to the i210, external 50MHz refclk on H16 (MII1_COL) */
+&cpsw_emac1 {
+	phy-mode = "rmii";
+	dual_emac_res_vlan = <2>;
+	rmii-clock-ext;
+	fixed-link {
+		   speed = <100>;
+		   full-duplex;
+	};
+};
+
+&mmc1 {
+	status = "okay";
+	bus-width = <4>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&mmc1_pins>;
+	cd-gpios = <&gpio3 15 GPIO_ACTIVE_LOW>;
+	disable-wp;
+	max-frequency = <96000000>;
+	vmmc-supply = <&vmmc_reg>;
+	vqmmc-supply = <&vmmc_reg>;
+	no-1-8-v;
+	cap-sd-highspeed;
+	no-sdio;
+	no-mmc;
+};
+
+&mmc2 {
+	status = "okay";
+	bus-width = <8>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&mmc2_pins>;
+	disable-wp;
+	max-frequency = <96000000>;
+	vmmc-supply = <&vmmc_reg>;
+	vqmmc-supply = <&vmmc_reg>;
+	no-1-8-v;
+	cap-mmc-highspeed;
+	no-sdio;
+	no-sd;
+	non-removable;
+};
+
+/*
+ * SPI0 is connected to a W25Q128FV or equivalent SPI flash
+ *
+ * The SPI_HOST_MUX_EN gpio (0,27) must be driven high for this to work
+ */
+&spi0 {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&spi0_pins>;
+
+	/* BIOS SPI flash */
+	flash: w25q128@0 {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		label = "BIOS";
+		compatible = "winbond,w25q128", "jedec,spi-nor";
+		linux,modalias = "m25p80","w25q128";
+		reg = <0>;
+		/* Limit to 25MHz, there are a number of muxes on the bus */
+		spi-max-frequency = <25000000>;
+		m25p,fast-read;
+		partition@0000000 { reg = <0x00000000 0x00800000>; label = "host_bios_local"; };
+	    partition@0800000 { reg = <0x00800000 0x00800000>; label = "host_bios_coreboot"; };
+
+	};
+	tpm_tis_spi: slb9670@1 {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		compatible = "infineon,slb9670";
+		linux,modalias = "tpm_tis_spi";
+		reg = <1>;
+		/* Limit to 25MHz, there are a number of muxes on the bus */
+		spi-max-frequency = <25000000>;
+	};
+};
+
+&sham {
+	status = "okay";
+};
+
+&aes {
+	status = "okay";
+};
+
