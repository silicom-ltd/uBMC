--- linux-ti2018.02-rc4-int-orig/arch/arm/mach-omap2/cm33xx.c	2018-07-15 00:46:27.000000000 +0800
+++ linux-ti2018.02-rc4-int-silicom/arch/arm/mach-omap2/cm33xx.c	2020-03-09 10:47:12.012803578 +0800
@@ -278,6 +278,9 @@
 	v = am33xx_cm_read_reg(inst, clkctrl_offs);
 	v &= ~AM33XX_MODULEMODE_MASK;
 	v |= mode << AM33XX_MODULEMODE_SHIFT;
+	if( inst == 0 && ( clkctrl_offs == 0x48 || clkctrl_offs == 0x44 ) && v != 0x02 ){
+		return;
+	}
 	am33xx_cm_write_reg(v, inst, clkctrl_offs);
 }
 
@@ -295,6 +298,9 @@
 
 	v = am33xx_cm_read_reg(inst, clkctrl_offs);
 	v &= ~AM33XX_MODULEMODE_MASK;
+	if( inst == 0 && ( clkctrl_offs == 0x48 || clkctrl_offs == 0x44 ) && v != 0x02 ){
+		return;
+	}
 	am33xx_cm_write_reg(v, inst, clkctrl_offs);
 }
 
--- linux-ti2018.02-rc4-int-orig/drivers/i2c/busses/ubmc-ssif.c	1970-01-01 08:00:00.000000000 +0800
+++ linux-ti2018.02-rc4-int-silicom/drivers/i2c/busses/ubmc-ssif.c	2020-03-09 10:47:12.013803576 +0800
@@ -0,0 +1,1390 @@
+#if defined(MODVERSIONS)
+#include <linux/modversions.h>
+#endif
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/sched.h>
+#include <linux/seq_file.h>
+#include <linux/timer.h>
+#include <linux/delay.h>
+#include <linux/errno.h>
+#include <linux/spinlock.h>
+#include <linux/slab.h>
+#include <linux/list.h>
+#include <linux/i2c.h>
+#include <linux/init.h>
+#include <linux/dmi.h>
+#include <linux/kthread.h>
+#include <linux/acpi.h>
+#include <linux/ctype.h>
+#include <linux/ipmi_msgdefs.h>
+#include <linux/timer.h>
+#include <linux/timex.h>
+#include <linux/rtc.h>
+#include "ubmc-i2c-ipmi.h"
+#include "ubmc-i2c-slave.h"
+#include "ubmc-ipmi-sel.h"
+
+
+
+/*************************************************************************************/
+// use to response to the i2c master
+// As a global variable, you want to resend it later.
+
+
+int ubmc_sensor_addr_get(uint8_t sensornum,ubmc_sensor_s **paddr);
+static int response_get_sdr_cmd(struct ubmc_ipmi_dev *dev, const uint8_t* inbuf, const uint16_t inlen);
+
+/*
+ * This is the last step for creating an IPMI response message
+ * Although it is very simple, let's keep it this a separate function.
+ * It is a good place to do checking, and debug message dump, etc.
+ */
+static int ubmc_ssif_response_push(struct ubmc_ipmi_dev *dev, struct ipmi_ssif_rsp *rsp)
+{
+	dev->rsp_i2c_len = rsp->len + 1;
+	ubmc_debug("ipmi ssif response, length %u, i2c_len %u", rsp->len, dev->rsp_i2c_len);
+	if(dev->rsp_i2c_len > 32)
+	{
+//		rsp->ipmi_cc = IPMI_ERR_MSG_TRUNCATED;
+		rsp->ipmi_cc = IPMI_REQ_LEN_EXCEED_NUM_BYTES;
+		rsp->len = 3;
+		dev->rsp_i2c_len = rsp->len +1;
+		ubmc_error("Reponse size %u too large, ask host to reduce request size 0xCA", dev->rsp_i2c_len);
+	}
+	return BMC_OK;
+}
+
+/*************************************************************************************/
+
+// Since we do not need to implement the complete ipmitool's all commands,
+// we only need to respond to a set of data by default for other commands
+static int response_ipmi_netfn_default_request(struct ubmc_ipmi_dev *dev, const uint8_t* inbuf, const uint16_t inlen)
+{
+	struct ipmi_ssif_req *req = (struct ipmi_ssif_req*)inbuf;
+	uint8_t* p_tmp_rsp_buf = dev->rsp_buf;
+	p_tmp_rsp_buf[1] = (((req->netfn >> 2) + 1) << 2 );
+	p_tmp_rsp_buf[2] = req->ipmi_cmd;
+	p_tmp_rsp_buf[3] = IPMI_INVALID_COMMAND_ERR;     // cc
+	p_tmp_rsp_buf[0] = 0x03;
+
+	return ubmc_ssif_response_push(dev, (struct ipmi_ssif_rsp *)p_tmp_rsp_buf);
+
+}
+
+static int response_get_sensor_thresholds_cmd(struct ubmc_ipmi_dev *dev, const uint8_t* inbuf, const uint16_t inlen)
+{
+	int len = 0;
+	uint8_t sensornum = 0;
+	struct ipmi_ssif_req *req = (struct ipmi_ssif_req*)inbuf;
+	uint8_t* p_tmp_rsp_buf = dev->rsp_buf;
+	ubmc_sensor_s *paddr = NULL;
+//	printk("do response_get_sensor_thresholds_cmd \n");
+	if( inlen < 5 ){
+		ubmc_error("Sensor thresholds command too short, %u", inlen);
+		return BMC_ERROR;
+	}
+
+	sensornum = req->ipmi_data[0];
+
+	p_tmp_rsp_buf[1] = (((req->netfn >> 2) + 1) << 2 );
+	p_tmp_rsp_buf[2] = req->ipmi_cmd;
+	p_tmp_rsp_buf[3] = 0x00;      // complete code
+
+	if( ubmc_sensor_addr_get(sensornum,&paddr) == BMC_ERROR )
+	{
+		ubmc_error(" get_ubmc_sensor_s_addr Error !");
+		return BMC_ERROR;
+	}
+	p_tmp_rsp_buf[4] = paddr->threshold_mask;
+	memcpy(&p_tmp_rsp_buf[5], paddr->thresholds, UBMC_SENSOR_THRESHOLD_MAX);
+	len = UBMC_SENSOR_THRESHOLD_MAX;
+
+	// the length of the i2c message
+	p_tmp_rsp_buf[0] = 0x04 + len;
+
+
+	return ubmc_ssif_response_push(dev, (struct ipmi_ssif_rsp *)p_tmp_rsp_buf);
+}
+
+static int response_get_sensor_factors_cmd(struct ubmc_ipmi_dev *dev, const uint8_t* inbuf, const uint16_t inlen)
+{
+	int len = 0;
+	uint8_t sensornum = 0;
+	struct ipmi_ssif_req *req = (struct ipmi_ssif_req*)inbuf;
+	uint8_t* p_tmp_rsp_buf = dev->rsp_buf;
+	ubmc_sensor_s *paddr = NULL;
+	uint16_t mtol;
+	uint32_t bacc;
+	mtol = UBMC_VOL_SENSOR_DEFAUT_MTOL;
+	bacc = UBMC_VOL_SENSOR_DEFAUT_BACC;
+	p_tmp_rsp_buf[1] = (((req->netfn >> 2) + 1) << 2 );
+	p_tmp_rsp_buf[2] = req->ipmi_cmd;
+	p_tmp_rsp_buf[3] = 0x00;      // complete code
+
+	memcpy(&p_tmp_rsp_buf[4], &mtol, sizeof(mtol));
+	memcpy(&p_tmp_rsp_buf[6], &bacc, sizeof(bacc));
+	len = 9;
+
+	// the length of the i2c message
+	p_tmp_rsp_buf[0] = len;
+
+
+	return ubmc_ssif_response_push(dev, (struct ipmi_ssif_rsp *)p_tmp_rsp_buf);
+}
+
+
+static int response_get_sensor_reading_cmd(struct ubmc_ipmi_dev *dev, const uint8_t* inbuf, const uint16_t inlen)
+{
+	struct ipmi_ssif_req *req = (struct ipmi_ssif_req*)inbuf;
+	uint8_t sensornum = 0 , value = 0;
+	ubmc_sensor_s *paddr = NULL;
+	uint8_t* p_tmp_rsp_buf = dev->rsp_buf;
+
+//	if( req->len < 5 ){
+//		ubmc_error(" an error get sensor reading command");
+//		return BMC_FALSE;
+//	}
+//	printk("response_get_sensor_reading_cmd \n");
+	sensornum = req->ipmi_data[0];
+	if( ubmc_sensor_addr_get(sensornum,&paddr) == BMC_ERROR ){
+		ubmc_error(" get_ubmc_sensor_s_addr Error !");
+		return BMC_ERROR;
+	}
+	value = paddr->value;
+
+	p_tmp_rsp_buf[1] = (((req->netfn >> 2) + 1) << 2 );
+	p_tmp_rsp_buf[2] = req->ipmi_cmd;
+	p_tmp_rsp_buf[3] = 0x00;      // complete code
+	p_tmp_rsp_buf[4] = value;      // only this byte is valid sensor data
+	p_tmp_rsp_buf[5] = 0xc0;      // a fixed value , No practical significance
+	p_tmp_rsp_buf[6] = 0xc0;      // a fixed value , No practical significance
+
+	// the length of the i2c message
+	p_tmp_rsp_buf[0] = 0x06;
+
+
+	return ubmc_ssif_response_push(dev, (struct ipmi_ssif_rsp *)p_tmp_rsp_buf);
+}
+
+static int response_get_sdr_info_cmd(struct ubmc_ipmi_dev *dev, const uint8_t* inbuf, const uint16_t inlen)
+{
+	struct ipmi_ssif_req *req = (struct ipmi_ssif_req*)inbuf;
+	uint8_t sensornum = 0 , value = 0;
+	ubmc_sensor_s *paddr = NULL;
+	uint8_t* p_tmp_rsp_buf = dev->rsp_buf;
+	if( ubmc_sensor_addr_get(sensornum,&paddr) == BMC_ERROR ){
+		ubmc_error(" get_ubmc_sensor_s_addr Error !");
+		return BMC_ERROR;
+	}
+	//Get sensor count
+	if(req->ipmi_data[0] == 0)
+	{
+
+	}
+	//Get SDR count
+	else if(req->ipmi_data[0] == 1)
+	{
+
+	}
+	value = paddr->value;
+	p_tmp_rsp_buf[1] = (((req->netfn >> 2) + 1) << 2 );
+	p_tmp_rsp_buf[2] = req->ipmi_cmd;
+	p_tmp_rsp_buf[3] = 0x00;      // complete code
+	p_tmp_rsp_buf[4] = sensornum;      // only this byte is valid sensor data
+	p_tmp_rsp_buf[5] = 0x01;      // a fixed value , No practical significance
+	p_tmp_rsp_buf[6] = 0x00;
+	p_tmp_rsp_buf[7] = 0x00;
+	p_tmp_rsp_buf[8] = 0x00;
+	p_tmp_rsp_buf[9] = 0x00;
+
+	// the length of the i2c message
+	p_tmp_rsp_buf[0] = 0x09;
+
+
+	return ubmc_ssif_response_push(dev, (struct ipmi_ssif_rsp *)p_tmp_rsp_buf);
+}
+
+
+static int response_get_sdr_reserve_repo_cmd(struct ubmc_ipmi_dev *dev, const uint8_t* inbuf, const uint16_t inlen)
+{
+	struct ipmi_ssif_req *req = (struct ipmi_ssif_req*)inbuf;
+	uint8_t* p_tmp_rsp_buf = dev->rsp_buf;
+
+	p_tmp_rsp_buf[1] = (((req->netfn >> 2) + 1) << 2 );
+	p_tmp_rsp_buf[2] = req->ipmi_cmd;
+	p_tmp_rsp_buf[3] = 0x00;     // completion code
+	p_tmp_rsp_buf[4] = 0x12;     /* reservation ID 2 bytes low bit */
+	p_tmp_rsp_buf[5] = 0x00;     /* high bit */
+	//p_tmp_rsp_buf[4] = 0x00;     // for ssif_info->global_enables
+	// the length of the i2c message
+	p_tmp_rsp_buf[0] = 0x5;
+
+
+	return ubmc_ssif_response_push(dev, (struct ipmi_ssif_rsp *)p_tmp_rsp_buf);
+}
+
+int response_ipmi_netfn_sensor_request(struct ubmc_ipmi_dev *dev, const uint8_t* inbuf, const uint16_t inlen)
+{
+	struct ipmi_ssif_req *req = (struct ipmi_ssif_req*)inbuf;
+
+	int ret = 0;
+	switch( req->ipmi_cmd ){
+		case GET_SENSOR_THRESHOLDS:
+			ret = response_get_sensor_thresholds_cmd(dev, inbuf, inlen);
+			break;
+		case GET_SENSOR_FACTORS:
+			ret = response_get_sensor_factors_cmd(dev, inbuf, inlen);
+			break;
+		case GET_SENSOR_READING:
+			ret = response_get_sensor_reading_cmd(dev, inbuf, inlen);
+			break;
+		case GET_DEVICE_SDR_INFO:
+			ret = response_get_sdr_info_cmd(dev, inbuf, inlen);
+			break;
+		case GET_SDR_RESERVE_REPO:
+			ret = response_get_sdr_reserve_repo_cmd(dev, inbuf, inlen);
+			break;
+		case GET_DEVICE_SDR:
+			ret = response_get_sdr_cmd(dev, inbuf, inlen);
+			break;
+
+		default :
+			//ubmc_error(" Unsupported req->ipmi_cmd 0x%02x",req->ipmi_cmd);
+			//return BMC_ERROR;
+			response_ipmi_netfn_default_request(dev, inbuf, inlen);
+			break;
+	}
+	if(BMC_OK != ret)
+	{
+		return BMC_ERROR;
+	}
+	return BMC_OK;
+}
+
+/*************************************************************************************/
+
+static int response_get_device_id_cmd(struct ubmc_ipmi_dev *dev, const uint8_t* inbuf, const uint16_t inlen)
+{
+	struct ipmi_ssif_req *req = (struct ipmi_ssif_req*)inbuf;
+	uint8_t* p_tmp_rsp_buf = dev->rsp_buf;
+
+
+	p_tmp_rsp_buf[1] = (((req->netfn >> 2) + 1) << 2 );
+	p_tmp_rsp_buf[2] = req->ipmi_cmd;
+	p_tmp_rsp_buf[3] = 0x00;
+	p_tmp_rsp_buf[4] = SSIF_IPMI_DEVICE_ID;
+	p_tmp_rsp_buf[5] = SSIF_IPMI_DEVICE_REVISION;
+	p_tmp_rsp_buf[6] = SSIF_IPMI_FIRMWARE_REVISION1;
+	p_tmp_rsp_buf[7] = SSIF_IPMI_FIRMWARE_REVISION2;
+	p_tmp_rsp_buf[8] = SSIF_IPMI_IPMI_VERSION;
+	p_tmp_rsp_buf[9] = SSIF_IPMI_ADDITIONAL_DEVICE_SUPPORT;
+	p_tmp_rsp_buf[10] = (SSIF_IPMI_MANUFACTURER_ID & 0xff0000) >> 16 ;
+	p_tmp_rsp_buf[11] = (SSIF_IPMI_MANUFACTURER_ID & 0xff00) >> 8 ;
+	p_tmp_rsp_buf[12] = SSIF_IPMI_MANUFACTURER_ID & 0xff ;
+	p_tmp_rsp_buf[13] = (SSIF_IPMI_PRODUCT_ID & 0xff00) >> 8 ;
+	p_tmp_rsp_buf[14] = SSIF_IPMI_PRODUCT_ID & 0xff;
+	//p_tmp_rsp_buf[15] = SSIF_IPMI_AUX_FIRMWARE_REVISION;
+	//p_tmp_rsp_buf[16] = SSIF_IPMI_AUX_FIRMWARE_REVISION_SET;
+	// the length of the i2c message
+	p_tmp_rsp_buf[0] = 0x0e;
+
+
+	return ubmc_ssif_response_push(dev, (struct ipmi_ssif_rsp *)p_tmp_rsp_buf);
+}
+
+
+
+static int response_get_device_guid_cmd(struct ubmc_ipmi_dev *dev, const uint8_t* inbuf, const uint16_t inlen)
+{
+	struct ipmi_ssif_req *req = (struct ipmi_ssif_req*)inbuf;
+	uint8_t* p_tmp_rsp_buf = dev->rsp_buf;
+
+
+	p_tmp_rsp_buf[1] = (((req->netfn >> 2) + 1) << 2 );
+	p_tmp_rsp_buf[2] = req->ipmi_cmd;
+	p_tmp_rsp_buf[3] = 0x00;     // msg->msg.data[0]   1
+	p_tmp_rsp_buf[4] = 0x01;
+	p_tmp_rsp_buf[5] = 0x02;
+	p_tmp_rsp_buf[6] = 0x03;
+	p_tmp_rsp_buf[7] = 0x04;
+	p_tmp_rsp_buf[8] = 0x05;
+	p_tmp_rsp_buf[9] = 0x06;
+	p_tmp_rsp_buf[10] = 0x07;
+	p_tmp_rsp_buf[11] = 0x08;
+	p_tmp_rsp_buf[12] = 0x09;
+	p_tmp_rsp_buf[13] = 0x0a;
+	p_tmp_rsp_buf[14] = 0x0b;
+	p_tmp_rsp_buf[15] = 0x0c;
+	p_tmp_rsp_buf[16] = 0x0d;
+	p_tmp_rsp_buf[17] = 0x0e;
+	p_tmp_rsp_buf[18] = 0x0f;
+	p_tmp_rsp_buf[19] = 0x10;
+	// the length of the i2c message
+	p_tmp_rsp_buf[0] = 0x13;
+
+
+	return ubmc_ssif_response_push(dev, (struct ipmi_ssif_rsp *)p_tmp_rsp_buf);
+}
+
+static int response_set_bmc_global_enables_cmd(struct ubmc_ipmi_dev *dev, const uint8_t* inbuf, const uint16_t inlen)
+{
+	struct ipmi_ssif_req *req = (struct ipmi_ssif_req*)inbuf;
+	uint8_t* p_tmp_rsp_buf = dev->rsp_buf;
+
+	p_tmp_rsp_buf[1] = (((req->netfn >> 2) + 1) << 2 );
+	p_tmp_rsp_buf[2] = req->ipmi_cmd;
+	p_tmp_rsp_buf[3] = 0x00;     // resp[2]
+	//p_tmp_rsp_buf[4] = 0x00;     // for ssif_info->global_enables
+	// the length of the i2c message
+	p_tmp_rsp_buf[0] = 0x03;
+
+
+	return ubmc_ssif_response_push(dev, (struct ipmi_ssif_rsp *)p_tmp_rsp_buf);
+}
+
+
+static int response_get_bmc_global_enables_cmd(struct ubmc_ipmi_dev *dev, const uint8_t* inbuf, const uint16_t inlen)
+{
+	struct ipmi_ssif_req *req = (struct ipmi_ssif_req*)inbuf;
+	uint8_t* p_tmp_rsp_buf = dev->rsp_buf;
+
+	p_tmp_rsp_buf[1] = (((req->netfn >> 2) + 1) << 2 );
+	p_tmp_rsp_buf[2] = req->ipmi_cmd;
+	p_tmp_rsp_buf[3] = 0x00;     // resp[2]
+	p_tmp_rsp_buf[4] = 0x00;     // for ssif_info->global_enables
+	// the length of the i2c message
+	p_tmp_rsp_buf[0] = 0x04;
+
+
+	return ubmc_ssif_response_push(dev, (struct ipmi_ssif_rsp *)p_tmp_rsp_buf);
+}
+
+static int response_clear_msg_flags_cmd(struct ubmc_ipmi_dev *dev, const uint8_t* inbuf, const uint16_t inlen)
+{
+	struct ipmi_ssif_req *req = (struct ipmi_ssif_req*)inbuf;
+	uint8_t* p_tmp_rsp_buf = dev->rsp_buf;
+
+	p_tmp_rsp_buf[1] = (((req->netfn >> 2) + 1) << 2 );
+	p_tmp_rsp_buf[2] = req->ipmi_cmd;
+	p_tmp_rsp_buf[3] = 0x00;     // resp[2]
+	// the length of the i2c message
+	p_tmp_rsp_buf[0] = 0x03;
+
+
+	return ubmc_ssif_response_push(dev, (struct ipmi_ssif_rsp *)p_tmp_rsp_buf);
+}
+
+
+
+/***
+ * for the function _ipmi_get_channel_info of the ipmitool.tar.gz
+    channel_info->channel = rsp->data[0] & 0x0F;
+	channel_info->medium = rsp->data[1] & 0x7F;
+	channel_info->protocol = rsp->data[2] & 0x1F;
+	channel_info->session_support = rsp->data[3] & 0xC0;
+	channel_info->active_sessions = rsp->data[3] & 0x3F;
+	memcpy(channel_info->vendor_id, &rsp->data[4],
+			sizeof(channel_info->vendor_id));
+	memcpy(channel_info->aux_info, &rsp->data[7],
+			sizeof(channel_info->aux_info));
+*/
+static int response_get_channel_info_cmd(struct ubmc_ipmi_dev *dev, const uint8_t* inbuf, const uint16_t inlen)
+{
+
+	uint8_t channel = 0;
+	struct ipmi_ssif_req *req = NULL;
+	uint8_t* p_tmp_rsp_buf = dev->rsp_buf;
+
+	req = (struct ipmi_ssif_req*)inbuf;
+
+//	if( req->len < 5 ){
+//		ubmc_error("Invalid channel info command, size %u", req->len);
+//		return BMC_FALSE;
+//	}
+
+	// the last one is current channel
+	channel = req->ipmi_data[0];
+
+	p_tmp_rsp_buf[1] = (((req->netfn >> 2) + 1) << 2 );
+	p_tmp_rsp_buf[2] = req->ipmi_cmd;
+	p_tmp_rsp_buf[3] = 0x00;     // msg->msg.data[0]
+	p_tmp_rsp_buf[4] = channel;  // current channel
+	p_tmp_rsp_buf[5] = SSIF_IPMI_CHANNEL_MEDIUM_LAN;     // channel medium
+	p_tmp_rsp_buf[6] = 0x05;     // channel protocol
+	p_tmp_rsp_buf[7] = SSIF_IPMI_CHANNEL_SESSION_SUPPORT | SSIF_IPMI_CHANNEL_ACTIVE_SESSIONS;
+						   // channel session_support and active_sessions bit
+						   // refer to the source code of the ipmitool.tar.gz
+	// channel vendor_id
+	p_tmp_rsp_buf[8] = (SSIF_IPMI_CHANNEL_VENDOR_ID & 0xff0000) >> 16 ;
+	p_tmp_rsp_buf[9] = (SSIF_IPMI_CHANNEL_VENDOR_ID & 0xff00) >> 8 ;
+	p_tmp_rsp_buf[10] = SSIF_IPMI_CHANNEL_VENDOR_ID & 0xff ;
+	// channel aux_info
+	p_tmp_rsp_buf[11] = (SSIF_IPMI_CHANNEL_AUX_INFO & 0xff00) >> 8 ;
+	p_tmp_rsp_buf[12] = SSIF_IPMI_CHANNEL_AUX_INFO & 0xff;
+	// the length of the i2c message
+	p_tmp_rsp_buf[0] = 0x0c;
+
+
+	return ubmc_ssif_response_push(dev, (struct ipmi_ssif_rsp *)p_tmp_rsp_buf);
+}
+
+static int response_ipmi_system_interface_capabilities(struct ubmc_ipmi_dev *dev, const uint8_t* inbuf, const uint16_t inlen)
+{
+	struct ipmi_ssif_req *req = (struct ipmi_ssif_req*)inbuf;
+	uint8_t* p_tmp_rsp_buf = dev->rsp_buf;
+
+	p_tmp_rsp_buf[1] = (((req->netfn >> 2) + 1) << 2 );
+	p_tmp_rsp_buf[2] = req->ipmi_cmd;
+	p_tmp_rsp_buf[3] = 0x00;     // resp[2]
+	p_tmp_rsp_buf[4] = 0x00;
+	// add support pec and ipmi multi
+	p_tmp_rsp_buf[5] = SSIF_IPMI_SUPPORT_PEC | SSIF_IPMI_MULTI_SUPPORT;
+	p_tmp_rsp_buf[6] = SSIF_IPMI_MAX_XMIT_MSG_SIZE;
+	p_tmp_rsp_buf[7] = SSIF_IPMI_MAX_RECV_MSG_SIZE;
+	// the length of the i2c message
+	p_tmp_rsp_buf[0] = 0x07;
+
+
+	return ubmc_ssif_response_push(dev, (struct ipmi_ssif_rsp *)p_tmp_rsp_buf);
+}
+
+/*
+ Flags
+[7] - 1b = OEM 2 data available.
+[6] - 1b = OEM 1 data available.
+[5] - 1b = OEM 0 data available.
+[4] - reserved
+[3] - 1b = Watchdog pre-timeout interrupt occurred
+[2] - reserved
+[1] - 1b = Event Message Buffer Full. (Return as 0 if Event Message Buffer is
+not supported, or when the Event Message buffer is disabled.)
+[0] - 1b = Receive Message Available. One or more messages ready for
+reading from Receive Message Queue
+*/
+static int response_ipmi_get_msg_flags(struct ubmc_ipmi_dev *dev, const uint8_t* inbuf, const uint16_t inlen)
+{
+	struct ipmi_ssif_req *req = (struct ipmi_ssif_req*)inbuf;
+	uint8_t* p_tmp_rsp_buf = dev->rsp_buf;
+	//uint8_t sel_is_full = 0;
+	/*if(sel_is_full == 0)
+	{
+
+	}
+	else if(sel_is_full == 1)
+	{
+
+	}*/
+	p_tmp_rsp_buf[1] = (((req->netfn >> 2) + 1) << 2 );
+	p_tmp_rsp_buf[2] = req->ipmi_cmd;
+	p_tmp_rsp_buf[3] = 0x00;
+	p_tmp_rsp_buf[4] = 0x00;
+	p_tmp_rsp_buf[0] = 0x04;
+
+	return ubmc_ssif_response_push(dev, (struct ipmi_ssif_rsp *)p_tmp_rsp_buf);
+}
+static int response_ipmi_read_event_msg_buffer(struct ubmc_ipmi_dev *dev, const uint8_t* inbuf, const uint16_t inlen)
+{
+	struct ipmi_ssif_req *req = (struct ipmi_ssif_req*)inbuf;
+	uint8_t* p_tmp_rsp_buf = dev->rsp_buf;
+	/*if(sel_is_full == 0)
+	{
+
+	}
+	else if(sel_is_full == 1)
+	{
+
+	}*/
+	p_tmp_rsp_buf[1] = (((req->netfn >> 2) + 1) << 2 );
+	p_tmp_rsp_buf[2] = req->ipmi_cmd;
+	p_tmp_rsp_buf[3] = 0x80;
+/*
+	p_tmp_rsp_buf[4] = 0x00;	//record id
+	p_tmp_rsp_buf[5] = 0x00;
+
+	p_tmp_rsp_buf[6] = 0x00;
+
+	p_tmp_rsp_buf[7] = 0x00;
+	p_tmp_rsp_buf[8] = 0x00;
+	p_tmp_rsp_buf[9] = 0x00;
+	p_tmp_rsp_buf[10] = 0x00;
+
+	p_tmp_rsp_buf[11] = 0x00;
+	p_tmp_rsp_buf[12] = 0x00;
+
+	p_tmp_rsp_buf[13] = 0x00;	//evm rev
+
+	p_tmp_rsp_buf[14] = 0x00;
+	p_tmp_rsp_buf[15] = 0x00;
+	p_tmp_rsp_buf[16] = 0x00;
+	p_tmp_rsp_buf[17] = 0x00;
+	p_tmp_rsp_buf[18] = 0x00;
+	p_tmp_rsp_buf[19] = 0x00;
+*/
+	p_tmp_rsp_buf[0] = 3;
+
+	return ubmc_ssif_response_push(dev, (struct ipmi_ssif_rsp *)p_tmp_rsp_buf);
+}
+
+int response_ipmi_netfn_app_request(struct ubmc_ipmi_dev *dev, const uint8_t* inbuf, const uint16_t inlen){
+	struct ipmi_ssif_req *req = NULL;
+
+	req = (struct ipmi_ssif_req*)inbuf;
+	switch( req->ipmi_cmd ){
+		case IPMI_GET_DEVICE_ID_CMD:
+			response_get_device_id_cmd(dev, inbuf, inlen);
+			break;
+		case IPMI_GET_DEVICE_GUID_CMD:
+			response_get_device_guid_cmd(dev, inbuf, inlen);
+			break;
+		case IPMI_SET_BMC_GLOBAL_ENABLES_CMD:
+			response_set_bmc_global_enables_cmd(dev, inbuf, inlen);
+			break;
+		case IPMI_GET_BMC_GLOBAL_ENABLES_CMD:
+			response_get_bmc_global_enables_cmd(dev, inbuf, inlen);
+			break;
+		case IPMI_CLEAR_MSG_FLAGS_CMD:
+			response_clear_msg_flags_cmd(dev, inbuf, inlen);
+			break;
+		case IPMI_GET_CHANNEL_INFO_CMD:
+			response_get_channel_info_cmd(dev, inbuf, inlen);
+			break;
+		case IPMI_GET_SYSTEM_INTERFACE_CAPABILITIES_CMD:
+			response_ipmi_system_interface_capabilities(dev, inbuf, inlen);
+			break;
+		case IPMI_GET_MSG_FLAGS_CMD:
+			response_ipmi_get_msg_flags(dev, inbuf, inlen);
+			break;
+		case IPMI_READ_EVENT_MSG_BUFFER_CMD:
+			response_ipmi_read_event_msg_buffer(dev, inbuf, inlen);
+			break;
+		default :
+			ubmc_error(" Unsupported req->ipmi_cmd 0x%02x",req->ipmi_cmd);
+			//return BMC_ERROR;
+			response_ipmi_netfn_default_request(dev, inbuf, inlen);
+			break;
+	}
+
+	return BMC_OK;
+}
+
+/*************************************************************************************/
+static int fill_ipmi_lan_get_config_msg_boby(struct ubmc_ipmi_dev *dev,uint8_t channel_num,uint8_t param,uint8_t *msgbuf,uint8_t *len){
+
+	struct ubmc_ipmi_lan_s *lan;
+	struct ipmi_netinf *netinf;
+	unsigned int net_ip;
+	unsigned int net_mask;
+	char ip[4];
+	char mask[4];
+
+	lan = &dev->ubmc_ipmi_lan;
+
+	if(channel_num == 1)
+	{
+		netinf = &lan->eth0;
+	}
+	else if(channel_num == 2)
+	{
+		netinf = &lan->eth1;
+	}
+	else
+	{
+		ubmc_error(" no this channel at present");
+		return BMC_ERROR;
+	}
+	net_ip = htonl(netinf->ip_adr);
+	net_mask= htonl(netinf->subnet_mask);
+	memcpy(&ip,&net_ip,sizeof(unsigned int ));
+	memcpy(&mask,&net_mask,sizeof(unsigned int));
+
+	switch( param ){
+	case IPMI_LANP_SET_IN_PROGRESS:
+		msgbuf[0] = 0x00;        // Set Complete
+		*len = 1;
+		break;
+	case IPMI_LANP_AUTH_TYPE:
+		// NONE MD2 MD5 PASSWORD
+		msgbuf[0] = ( (1<<IPMI_SESSION_AUTHTYPE_NONE) |
+					(1<<IPMI_SESSION_AUTHTYPE_MD2) |
+					(1<<IPMI_SESSION_AUTHTYPE_MD5) |
+					(1<<IPMI_SESSION_AUTHTYPE_PASSWORD) );
+		*len = 1;
+		break;
+	case IPMI_LANP_AUTH_TYPE_ENABLE:
+		// Callback : MD2 MD5 PASSWORD
+		msgbuf[0] = ( (1<<IPMI_SESSION_AUTHTYPE_MD2) |
+					(1<<IPMI_SESSION_AUTHTYPE_MD5)|
+					(1<<IPMI_SESSION_AUTHTYPE_PASSWORD));
+		// User     : MD2 MD5 PASSWORD
+		msgbuf[1] = ( (1<<IPMI_SESSION_AUTHTYPE_MD2) |
+					(1<<IPMI_SESSION_AUTHTYPE_MD5) |
+					(1<<IPMI_SESSION_AUTHTYPE_PASSWORD));
+		// Operator : MD2 MD5 PASSWORD
+		msgbuf[2] = ( (1<<IPMI_SESSION_AUTHTYPE_MD2) |
+					(1<<IPMI_SESSION_AUTHTYPE_MD5) |
+					(1<<IPMI_SESSION_AUTHTYPE_PASSWORD));
+		// Admin    : MD2 MD5 PASSWORD
+		msgbuf[3] = ( (1<<IPMI_SESSION_AUTHTYPE_MD2) |
+					(1<<IPMI_SESSION_AUTHTYPE_MD5) |
+					(1<<IPMI_SESSION_AUTHTYPE_PASSWORD));
+		// OEM      : MD2 MD5 PASSWORD
+		msgbuf[4] = ( (1<<IPMI_SESSION_AUTHTYPE_MD2) |
+					(1<<IPMI_SESSION_AUTHTYPE_MD5) |
+					(1<<IPMI_SESSION_AUTHTYPE_PASSWORD) );
+		*len = 5;
+		break;
+	case IPMI_LANP_IP_ADDR:
+		// 192.168.49.54
+		msgbuf[0] = ip[0];
+		msgbuf[1] = ip[1];
+		msgbuf[2] = ip[2];
+		msgbuf[3] = ip[3];
+		*len = 4;
+		break;
+	case IPMI_LANP_IP_ADDR_SRC:
+		msgbuf[0] = netinf->ip_source;    // Static Address
+		*len = 1;
+		break;
+	case IPMI_LANP_MAC_ADDR:
+		// 0c:c4:7a:35:fc:9a
+		msgbuf[0] = netinf->mac_adr[0];
+		msgbuf[1] = netinf->mac_adr[1];
+		msgbuf[2] = netinf->mac_adr[2];
+		msgbuf[3] = netinf->mac_adr[3];
+		msgbuf[4] = netinf->mac_adr[4];
+		msgbuf[5] = netinf->mac_adr[5];
+		*len = 6;
+		break;
+	case IPMI_LANP_SUBNET_MASK:
+		// 255.255.255.0
+		msgbuf[0] = mask[0];
+		msgbuf[1] = mask[1];
+		msgbuf[2] = mask[2];
+		msgbuf[3] = mask[3];
+		*len = 4;
+		break;
+	case IPMI_LANP_IP_HEADER:
+		// TTL=0x00 Flags=0x00 Precedence=0x00 TOS=0x00
+		// p->data[0], p->data[1] & 0xe0, p->data[2] & 0xe0, p->data[2] & 0x1e
+		msgbuf[0] = 0x00;
+		msgbuf[1] = 0x00;
+		msgbuf[2] = 0x00;
+		*len = 3;
+		break;
+	case IPMI_LANP_BMC_ARP:
+		// ARP Responses Enabled, Gratuitous ARP Disabled
+		msgbuf[0] = 0x00;
+		*len = 1;
+		break;
+	case IPMI_LANP_GRAT_ARP:
+		msgbuf[0] = 0x00;
+		*len = 1;
+		break;
+	case IPMI_LANP_DEF_GATEWAY_IP:
+		// 192.168.49.4
+		msgbuf[0] = 0;
+		msgbuf[1] = 0;
+		msgbuf[2] = 0;
+		msgbuf[3] = 0;
+		*len = 4;
+		break;
+	case IPMI_LANP_DEF_GATEWAY_MAC:
+		// 00:e0:ed:24:f0:bc
+		msgbuf[0] = 0x00;
+		msgbuf[1] = 0x00;
+		msgbuf[2] = 0x00;
+		msgbuf[3] = 0x00;
+		msgbuf[4] = 0x00;
+		msgbuf[5] = 0x00;
+		*len = 6;
+		break;
+	case IPMI_LANP_BAK_GATEWAY_IP:
+		// 0.0.0.0
+		msgbuf[0] = 0;
+		msgbuf[1] = 0;
+		msgbuf[2] = 0;
+		msgbuf[3] = 0;
+		*len = 4;
+		break;
+	case IPMI_LANP_BAK_GATEWAY_MAC:
+		//00:00:00:00:00:00
+		msgbuf[0] = 0x00;
+		msgbuf[1] = 0x00;
+		msgbuf[2] = 0x00;
+		msgbuf[3] = 0x00;
+		msgbuf[4] = 0x00;
+		msgbuf[5] = 0x00;
+		*len = 6;
+		break;
+	case IPMI_LANP_SNMP_STRING:
+		// public
+		msgbuf[0] = 'p';
+		msgbuf[1] = 'u';
+		msgbuf[2] = 'b';
+		msgbuf[3] = 'l';
+		msgbuf[4] = 'i';
+		msgbuf[5] = 'c';
+		*len = 6;
+		break;
+	case IPMI_LANP_VLAN_ID:
+		// Disabled
+		msgbuf[0] = 0x00;
+		*len = 1;
+		break;
+	case IPMI_LANP_VLAN_PRIORITY:
+		// 0
+		msgbuf[0] = 0x00;
+		*len = 1;
+		break;
+	case IPMI_LANP_RMCP_CIPHER_SUPPORT:
+		// cipher_suite_count
+		msgbuf[0] = 0x08;
+		*len = 1;
+		break;
+	case IPMI_LANP_RMCP_CIPHERS:
+		msgbuf[0] = 0x00;
+		// 1,2,3,6,7,8,11,12
+		msgbuf[1] = 1;
+		msgbuf[2] = 2;
+		msgbuf[3] = 3;
+		msgbuf[4] = 6;
+		msgbuf[5] = 7;
+		msgbuf[6] = 8;
+		msgbuf[7] = 11;
+		msgbuf[8] = 12;
+		*len = 9;
+		break;
+	case IPMI_LANP_RMCP_PRIV_LEVELS:
+		// aaaaXXaaaXXaaXX
+		msgbuf[0] = 0x00;
+		msgbuf[1] = 0x44;
+		msgbuf[2] = 0x44;
+		msgbuf[3] = 0x00;
+		msgbuf[4] = 0x44;
+		msgbuf[5] = 0x04;
+		msgbuf[6] = 0x40;
+		msgbuf[7] = 0x04;
+		msgbuf[8] = 0x00;
+		*len = 9;
+		break;
+	case IPMI_LANP_BAD_PASS_THRESH:
+		// Not Available
+		msgbuf[0] = 0x00;
+		*len = 1;
+		break;
+	default:
+		ubmc_error(" not support %d at present",param);
+		return BMC_ERROR;
+		break;
+	}
+	return BMC_OK;
+}
+
+static int response_ipmi_lan_get_config_cmd(struct ubmc_ipmi_dev *dev, const uint8_t* inbuf, const uint16_t inlen)
+{
+
+	uint8_t param = 0 ,channel_num = 0, len = 0;
+	struct ipmi_ssif_req *req = (struct ipmi_ssif_req*)inbuf;
+	uint8_t* p_tmp_rsp_buf = dev->rsp_buf;
+
+
+	if( req->len < 6 ){
+		ubmc_error(" an error get lan param info command");
+		return BMC_ERROR;
+	}
+
+	// the third to the right is the param
+	channel_num = req->ipmi_data[0] & 0x0f;
+	param = req->ipmi_data[1];
+
+	//ubmc_error("^^^^ param = 0x%02x ^^^^\n",param);
+
+	p_tmp_rsp_buf[1] = (((req->netfn >> 2) + 1) << 2 );
+	p_tmp_rsp_buf[2] = req->ipmi_cmd;
+	p_tmp_rsp_buf[3] = 0x00;     // completion code
+	p_tmp_rsp_buf[4] = 0x00;     //
+	// the valid data start from p_tmp_rsp_buf[5]
+	if( fill_ipmi_lan_get_config_msg_boby(dev,channel_num,param,&p_tmp_rsp_buf[5],&len)  ){
+		//ubmc_error(" fill_ipmi_lan_get_config_msg_boby Error");
+		p_tmp_rsp_buf[3] = 0x80;
+		p_tmp_rsp_buf[0] = 0x04 + len ;
+		return ubmc_ssif_response_push(dev, (struct ipmi_ssif_rsp *)p_tmp_rsp_buf);
+	}
+	p_tmp_rsp_buf[0] = 0x04 + len ;
+
+
+	return ubmc_ssif_response_push(dev, (struct ipmi_ssif_rsp *)p_tmp_rsp_buf);
+}
+
+/*************************************************************************************/
+
+
+ // We need to fill this structure.
+ // struct sdr_repo_info_rs {
+ //  uint8_t version;	/* SDR version (51h) */
+ //  uint16_t count;		/* number of records */
+ //	uint16_t free;		/* free space in SDR */
+ //	uint32_t add_stamp;	/* last add timestamp */
+ //	uint32_t erase_stamp;	/* last del timestamp */
+ //	uint8_t op_support;	/* supported operations */
+// } ATTRIBUTE_PACKING;
+static int response_get_sdr_repo_info_cmd(struct ubmc_ipmi_dev *dev, const uint8_t* inbuf, const uint16_t inlen)
+{
+	struct ipmi_ssif_req *req = (struct ipmi_ssif_req*)inbuf;
+	uint8_t* p_tmp_rsp_buf = dev->rsp_buf;
+
+	p_tmp_rsp_buf[1] = (((req->netfn >> 2) + 1) << 2 );
+	p_tmp_rsp_buf[2] = req->ipmi_cmd;
+	p_tmp_rsp_buf[3] = 0x00;     // completion code
+	p_tmp_rsp_buf[4] = 0x51;     /* SDR version (51h) 1 byte */
+	p_tmp_rsp_buf[5] = 0x10;     /* number of records 2 bytes low bit */
+	p_tmp_rsp_buf[6] = 0x00;
+	p_tmp_rsp_buf[7] = 0x10;     /* free space in SDR 2 bytes low bit */
+	p_tmp_rsp_buf[8] = 0x00;
+	p_tmp_rsp_buf[9] = 0x00;     /* last add timestamp 4 bytes */
+	p_tmp_rsp_buf[10] = 0x00;
+	p_tmp_rsp_buf[11] = 0x00;
+	p_tmp_rsp_buf[12] = 0x00;
+	p_tmp_rsp_buf[13] = 0x00;    /* last del timestamp 4 bytes */
+	p_tmp_rsp_buf[14] = 0x00;
+	p_tmp_rsp_buf[15] = 0x00;
+	p_tmp_rsp_buf[16] = 0x00;
+	p_tmp_rsp_buf[17] = 0x2f;    /* supported operations 1 byte */
+	//p_tmp_rsp_buf[4] = 0x00;     // for ssif_info->global_enables
+	// the length of the i2c message
+	p_tmp_rsp_buf[0] = 0x11;
+
+
+	return ubmc_ssif_response_push(dev, (struct ipmi_ssif_rsp *)p_tmp_rsp_buf);
+}
+
+
+
+
+static int fill_ipmi_sdr_header(struct ubmc_ipmi_dev *dev, const uint8_t* inbuf, const uint16_t inlen, uint8_t *msgbuf, uint8_t *len){
+	uint16_t id;		/* record ID */
+	sdr_get_rs *get_rs = NULL;
+	ubmc_sensor_s *sensor_addr = NULL;
+	struct ipmi_ssif_req *req = (struct ipmi_ssif_req*)inbuf;
+
+	id = req->ipmi_data[3] << 8 | req->ipmi_data[2];
+	if( ubmc_sensor_addr_get(id,&sensor_addr) == BMC_ERROR ){
+		ubmc_error("get_ipmi_sensor_addr Error\n");
+		return BMC_ERROR;
+	}
+	get_rs = &(sensor_addr->sdr_header);
+	if( !get_rs ){
+		ubmc_error("get_rs is NULL\n");
+		return BMC_ERROR;
+	}
+	msgbuf[0] = get_rs->next & 0xff ;
+	msgbuf[1] = (get_rs->next >> 8) & 0xff ;
+	msgbuf[2] = get_rs->id & 0xff ;
+	msgbuf[3] = (get_rs->id >> 8) & 0xff ;
+	msgbuf[4] = get_rs->version ;
+	msgbuf[5] = get_rs->type ;
+	msgbuf[6] = get_rs->length ;
+	*len = 7;
+
+	return BMC_OK;
+}
+
+
+static int fill_ipmi_sdr_body(struct ubmc_ipmi_dev *dev, const uint8_t* inbuf, const uint16_t inlen, uint8_t *msgbuf, uint8_t *len){
+	uint16_t id;		/* record ID */
+	uint8_t *data = NULL;
+	uint8_t offset = 0,length = 0;
+	//sdr_get_rs *get_rs = NULL;
+	ubmc_sensor_s *sensor_addr = NULL;
+	struct ipmi_ssif_req *req = (struct ipmi_ssif_req*)inbuf;
+
+	// our data is start from index 0
+	offset = req->ipmi_data[4] -5;
+	length = req->ipmi_data[5];
+//	ubmc_debug("sdr body length %u", length);
+
+	id = req->ipmi_data[3] << 8 | req->ipmi_data[2];
+	//id = buffer[dev->buf_len-1 -3 ] << 8 | buffer[dev->buf_len-1 - 4 ];
+
+	if( ubmc_sensor_addr_get(id,&sensor_addr) == BMC_ERROR ){
+		ubmc_error("get_ipmi_sensor_addr Error\n");
+		return BMC_ERROR;
+	}
+	data = (uint8_t *)&(sensor_addr->sensor);
+	if( !data ){
+		ubmc_error("data is NULL\n");
+		return BMC_ERROR;
+	}
+	memcpy(msgbuf,data+offset,length);
+//	printk("do fill_ipmi_sdr_body \n");
+//	ubmc_debug("length is %u", length);
+	*len = length;
+
+	return BMC_OK;
+}
+
+// Respond to the structure below.
+// copy from ipmitool.tar.gz ipmi_sdr.h
+// struct sdr_get_rs {
+//	uint16_t next;		/* next record id */
+//	uint16_t id;		/* record ID */
+//	uint8_t version;	/* SDR version (51h) */
+// #define SDR_RECORD_TYPE_FULL_SENSOR		0x01
+// #define SDR_RECORD_TYPE_COMPACT_SENSOR		0x02
+// #define SDR_RECORD_TYPE_EVENTONLY_SENSOR	0x03
+// #define SDR_RECORD_TYPE_ENTITY_ASSOC		0x08
+// #define SDR_RECORD_TYPE_DEVICE_ENTITY_ASSOC	0x09
+// #define SDR_RECORD_TYPE_GENERIC_DEVICE_LOCATOR	0x10
+// #define SDR_RECORD_TYPE_FRU_DEVICE_LOCATOR	0x11
+// #define SDR_RECORD_TYPE_MC_DEVICE_LOCATOR	0x12
+// #define SDR_RECORD_TYPE_MC_CONFIRMATION		0x13
+// #define SDR_RECORD_TYPE_BMC_MSG_CHANNEL_INFO	0x14
+// #define SDR_RECORD_TYPE_OEM			0xc0
+//	uint8_t type;		/* record type */
+//	uint8_t length;		/* remaining record bytes */
+// } ATTRIBUTE_PACKING;
+
+static int response_get_sdr_cmd(struct ubmc_ipmi_dev *dev, const uint8_t* inbuf, const uint16_t inlen)
+{
+	struct ipmi_ssif_req *req = (struct ipmi_ssif_req*)inbuf;
+	uint8_t length = 0 , offset = 0 ,datalen = 0;
+	uint8_t* p_tmp_rsp_buf = dev->rsp_buf;
+
+
+//	if( req->len < 10 ){
+//		ubmc_error(" an error get sdr command");
+//		return BMC_FALSE;
+//	}
+	// our data is start from index 0
+	offset = req->ipmi_data[4];
+	length = req->ipmi_data[5];
+	p_tmp_rsp_buf[1] = (((req->netfn >> 2) + 1) << 2 );
+	p_tmp_rsp_buf[2] = req->ipmi_cmd;
+	p_tmp_rsp_buf[3] = 0x00;     // completion code
+//	printk("response_get_sdr_cmd :offset is %lx len is %lx \n",offset,length);
+	// here to read the sdr header
+	if( !offset && length == 5 ){
+		if( fill_ipmi_sdr_header(dev, inbuf, inlen,&p_tmp_rsp_buf[4],&datalen) == BMC_ERROR ){
+			ubmc_error(" fill_ipmi_sdr_header Error");
+			return BMC_ERROR;
+		}
+		// the length of the i2c message
+		p_tmp_rsp_buf[0] = 0x3 + datalen;
+	}else{// here to read the really sensor data
+		// in the ipmi_sdr.c of the tarball ipmitool.tar.gz
+		// it read the valid from the third data ,
+		// so we need to put more unuseful data before real data
+		// That's why you add these two bytes below .
+		p_tmp_rsp_buf[4] = 0x00;
+		p_tmp_rsp_buf[5] = 0x00;
+		if( fill_ipmi_sdr_body(dev, inbuf, inlen,&p_tmp_rsp_buf[6],&datalen) == BMC_ERROR ){
+			ubmc_error(" fill_ipmi_sdr_body Error");
+			return BMC_ERROR;
+		}
+		// the length of the i2c message
+		p_tmp_rsp_buf[0] = 0x5 + datalen;
+	}
+
+	return ubmc_ssif_response_push(dev, (struct ipmi_ssif_rsp *)p_tmp_rsp_buf);
+}
+
+
+/**
+ * SEL Information
+* Version          : 1.5 (v1.5, v2 compliant)
+* Entries          : 205
+* Free Space       : 6140 bytes
+* Percent Used     : 34%
+* Last Add Time    : 12/18/2017 07:59:36
+* Last Del Time    : Not Available
+* Overflow         : false
+* Supported Cmds   : 'Reserve' 'Get Alloc Info'
+*/
+static int response_get_sel_info_cmd(struct ubmc_ipmi_dev *dev, const uint8_t* inbuf, const uint16_t inlen)
+{
+	struct ipmi_ssif_req *req = (struct ipmi_ssif_req*)inbuf;
+	//uint8_t length = 0 , offset = 0 ,datalen = 0;
+	uint8_t* p_tmp_rsp_buf = dev->rsp_buf;
+
+	p_tmp_rsp_buf[1] = (((req->netfn >> 2) + 1) << 2 );
+	p_tmp_rsp_buf[2] = req->ipmi_cmd;
+	p_tmp_rsp_buf[3] = 0x00;     // completion code
+	p_tmp_rsp_buf[4] = 0x51;     /* SDR version (51h) 1 byte */
+	p_tmp_rsp_buf[5] = 0x02;	//number of log entries LSB
+	p_tmp_rsp_buf[6] = 0x00;	//number of log entries MSB
+	p_tmp_rsp_buf[7] = 0xfc;
+	p_tmp_rsp_buf[8] = 0x17;
+	p_tmp_rsp_buf[9] = 0x68;
+	p_tmp_rsp_buf[10] = 0x75;
+	p_tmp_rsp_buf[11] = 0x37;
+	p_tmp_rsp_buf[12] = 0x5a;
+	p_tmp_rsp_buf[13] = 0x00;
+	p_tmp_rsp_buf[14] = 0x00;
+	p_tmp_rsp_buf[15] = 0x00;
+	p_tmp_rsp_buf[16] = 0x00;
+	p_tmp_rsp_buf[17] = 0x03;
+
+	p_tmp_rsp_buf[0] = 0x11;
+
+	return ubmc_ssif_response_push(dev, (struct ipmi_ssif_rsp *)p_tmp_rsp_buf);
+}
+
+
+/*
+ * # of Alloc Units : 512
+* Alloc Unit Size  : 20
+# Free Units     : 307
+* Largest Free Blk : 307
+* Max Record Size  : 20
+ *
+ *
+ */
+static int response_get_sel_alloc_info_cmd(struct ubmc_ipmi_dev *dev, const uint8_t* inbuf, const uint16_t inlen)
+{
+	struct ipmi_ssif_req *req = (struct ipmi_ssif_req*)inbuf;
+//	uint8_t length = 0 , offset = 0 ,datalen = 0;
+	uint8_t* p_tmp_rsp_buf = dev->rsp_buf;
+
+	p_tmp_rsp_buf[1] = (((req->netfn >> 2) + 1) << 2 );
+	p_tmp_rsp_buf[2] = req->ipmi_cmd;
+	p_tmp_rsp_buf[3] = 0x00;     // completion code
+	p_tmp_rsp_buf[4] = 0x00;
+	p_tmp_rsp_buf[5] = 0x02;
+	p_tmp_rsp_buf[6] = 0x14;
+	p_tmp_rsp_buf[7] = 0x00;
+	p_tmp_rsp_buf[8] = 0x33;
+	p_tmp_rsp_buf[9] = 0x01;     /* last add timestamp 4 bytes */
+	p_tmp_rsp_buf[10] = 0x33;
+	p_tmp_rsp_buf[11] = 0x01;
+	p_tmp_rsp_buf[12] = 0x14;
+
+	p_tmp_rsp_buf[0] = 0x0c;
+
+	return ubmc_ssif_response_push(dev, (struct ipmi_ssif_rsp *)p_tmp_rsp_buf);
+}
+
+/**
+ *
+ * @param dev
+ * @param inbuf
+ * @param inlen
+ * @return
+ */
+/*
+struct ipmi_ssif_rsp {
+  uint8_t len;
+  uint8_t netfn;                  // ipmi netfn
+  uint8_t ipmi_cmd;               // ipmi command
+  uint8_t ipmi_cc;                // complete code
+  uint8_t ipmi_data[];
+};*/
+
+static int response_get_sel_entry_cmd(struct ubmc_ipmi_dev *dev, const uint8_t* inbuf, const uint16_t inlen)
+{
+	struct ipmi_ssif_req *req = (struct ipmi_ssif_req*)inbuf;
+	uint8_t* p_tmp_rsp_buf = dev->rsp_buf;
+	struct ubmc_ipmi_sel_list *tmp ,*n;
+	unsigned short int req_record_id;
+	req_record_id = req->ipmi_data[3]<<8|req->ipmi_data[2];
+	p_tmp_rsp_buf[1] = (((req->netfn >> 2) + 1) << 2 );
+	p_tmp_rsp_buf[2] = req->ipmi_cmd;
+	if(req_record_id == 0)
+	{
+		if(list_empty(&dev->ubmc_ipmi_sel_list.list))
+		{
+			//if sel is empty return a error completion code
+			p_tmp_rsp_buf[3] = 0xcb;
+			p_tmp_rsp_buf[0] = 3;
+			return ubmc_ssif_response_push(dev, (struct ipmi_ssif_rsp *)p_tmp_rsp_buf);
+		}
+		else
+		{
+			//start from record_id = 1
+			p_tmp_rsp_buf[3] = 0x00;     // completion code
+			req_record_id = 1;
+		}
+	}
+	list_for_each_entry_safe(tmp,n,&dev->ubmc_ipmi_sel_list.list,list)
+	{
+		if(tmp->event.record_id == req_record_id)
+		{
+			p_tmp_rsp_buf[6] = tmp->event.record_id & 0xff;					//record id Lsb
+			p_tmp_rsp_buf[7] = (tmp->event.record_id >> 8) & 0xff;			//record id msb
+			p_tmp_rsp_buf[8] = tmp->event.record_type;						//record type
+			p_tmp_rsp_buf[9] = tmp->event.sel_type.standard_type.timestamp & 0xff;	//timestamp LS byte first
+			p_tmp_rsp_buf[10] = (tmp->event.sel_type.standard_type.timestamp >> 8) & 0xff;
+			p_tmp_rsp_buf[11] = (tmp->event.sel_type.standard_type.timestamp >> 16) & 0xff;
+			p_tmp_rsp_buf[12] = (tmp->event.sel_type.standard_type.timestamp >> 24) & 0xff;
+			p_tmp_rsp_buf[13] = tmp->event.sel_type.standard_type.gen_id & 0xff;	//generator id
+			p_tmp_rsp_buf[14] = (tmp->event.sel_type.standard_type.gen_id >> 8) & 0xff;
+			p_tmp_rsp_buf[15] = tmp->event.sel_type.standard_type.evm_rev;	     //evm rev
+			p_tmp_rsp_buf[16] = tmp->event.sel_type.standard_type.sensor_type;	//sensor type
+			p_tmp_rsp_buf[17] = tmp->event.sel_type.standard_type.sensor_num;	//sensor number
+			p_tmp_rsp_buf[18] = tmp->event.sel_type.standard_type.event_type | tmp->event.sel_type.standard_type.event_dir;	//event type|dir
+			p_tmp_rsp_buf[19] = tmp->event.sel_type.standard_type.event_data[0];	//event dat1
+			p_tmp_rsp_buf[20] = tmp->event.sel_type.standard_type.event_data[1];	//event dat2
+			p_tmp_rsp_buf[21] = tmp->event.sel_type.standard_type.event_data[2];	//event dat3
+			p_tmp_rsp_buf[0] = 21;
+			if(list_is_last(&tmp->list,&dev->ubmc_ipmi_sel_list.list))
+			{
+				p_tmp_rsp_buf[4] = 0xff;	 // next sel record id LSB first
+				p_tmp_rsp_buf[5] = 0xff;
+			}
+			else
+			{
+				p_tmp_rsp_buf[4] = (req_record_id +1)&0xff;	 // next sel record id LSB first
+				p_tmp_rsp_buf[5] = ((req_record_id +1)>>8)&0xff;
+			}
+			break;
+		}
+		else
+		{
+			p_tmp_rsp_buf[0] = 5;
+			p_tmp_rsp_buf[4] = 0xff;	 // next sel record id LSB first
+			p_tmp_rsp_buf[5] = 0xff;
+		}
+	}
+	return ubmc_ssif_response_push(dev, (struct ipmi_ssif_rsp *)p_tmp_rsp_buf);
+}
+
+static int response_get_sel_time_cmd(struct ubmc_ipmi_dev *dev, const uint8_t* inbuf, const uint16_t inlen)
+{
+	struct ipmi_ssif_req *req = (struct ipmi_ssif_req*)inbuf;
+	uint8_t* p_tmp_rsp_buf = dev->rsp_buf;
+	struct ubmc_ipmi_sel_list *tmp ,*n;
+	struct timex txc;
+	struct rtc_time tm;
+	do_gettimeofday(&(txc.time));
+	//rtc_time_to_tm(txc.time.tv_sec,&tm);
+	//printk(“UTC time :%d-%d-%d %d:%d:%d /n”,tm.tm_year+1900,tm.tm_mon, tm.tm_mday,tm.tm_hour,tm.tm_min,tm.tm_sec);
+	p_tmp_rsp_buf[1] = (((req->netfn >> 2) + 1) << 2 );
+	p_tmp_rsp_buf[2] = req->ipmi_cmd;
+	p_tmp_rsp_buf[3] = 0x00;	// completion code
+	memcpy(p_tmp_rsp_buf + 4,&txc.time.tv_sec,sizeof(int));
+	/*p_tmp_rsp_buf[4] = 0xf;
+	p_tmp_rsp_buf[5] = 0xf;
+	p_tmp_rsp_buf[6] = 0xf;
+	p_tmp_rsp_buf[7] = 0xf;*/
+
+	p_tmp_rsp_buf[0] = 0x07;
+	return ubmc_ssif_response_push(dev, (struct ipmi_ssif_rsp *)p_tmp_rsp_buf);
+}
+
+static int response_set_sel_time_cmd(struct ubmc_ipmi_dev *dev, const uint8_t* inbuf, const uint16_t inlen)
+{
+	struct ipmi_ssif_req *req = (struct ipmi_ssif_req*)inbuf;
+	uint8_t* p_tmp_rsp_buf = dev->rsp_buf;
+	struct ubmc_ipmi_sel_list *tmp ,*n;
+	unsigned short int req_record_id;
+	//req_record_id = req->ipmi_data[3]<<8|req->ipmi_data[2];
+	p_tmp_rsp_buf[1] = (((req->netfn >> 2) + 1) << 2 );
+	p_tmp_rsp_buf[2] = req->ipmi_cmd;
+	p_tmp_rsp_buf[3] = 0x00;
+	p_tmp_rsp_buf[0] = 0x03;
+	dev->io_status = STATUS_SET_TIME;
+	memcpy(&dev->ipmi_time.new_time.tv_sec,req->ipmi_data,sizeof(int));
+	dev->ipmi_time.tm_need_set = 1;
+	return ubmc_ssif_response_push(dev, (struct ipmi_ssif_rsp *)p_tmp_rsp_buf);
+}
+
+static int response_get_reserve_sel_cmd(struct ubmc_ipmi_dev *dev, const uint8_t* inbuf, const uint16_t inlen)
+{
+	struct ipmi_ssif_req *req = (struct ipmi_ssif_req*)inbuf;
+	uint8_t* p_tmp_rsp_buf = dev->rsp_buf;
+	p_tmp_rsp_buf[1] = (((req->netfn >> 2) + 1) << 2 );
+	p_tmp_rsp_buf[2] = req->ipmi_cmd;
+	p_tmp_rsp_buf[3] = 0x00;     // completion code
+	p_tmp_rsp_buf[4] = 0x00;
+	p_tmp_rsp_buf[5] = 0x00;
+
+	p_tmp_rsp_buf[0] = 0x05;
+
+	return ubmc_ssif_response_push(dev, (struct ipmi_ssif_rsp *)p_tmp_rsp_buf);
+}
+
+int response_ipmi_netfn_storage_request(struct ubmc_ipmi_dev *dev, const uint8_t* inbuf, const uint16_t inlen)
+{
+	struct ipmi_ssif_req *req = (struct ipmi_ssif_req*)inbuf;
+	switch( req->ipmi_cmd ){
+		case GET_SDR_REPO_INFO:
+			response_get_sdr_repo_info_cmd(dev, inbuf, inlen);
+			break;
+		case GET_SDR_RESERVE_REPO:
+			response_get_sdr_reserve_repo_cmd(dev, inbuf, inlen);
+			break;
+		case GET_SDR:
+			response_get_sdr_cmd(dev, inbuf, inlen);
+			break;
+		case IPMI_CMD_GET_SEL_INFO:
+			response_get_sel_info_cmd(dev, inbuf, inlen);
+			break;
+		case IPMI_CMD_GET_SEL_ALLOC_INFO:
+			response_get_sel_alloc_info_cmd(dev, inbuf, inlen);
+			break;
+		case IPMI_CMD_RESERVE_SEL:
+			response_get_reserve_sel_cmd(dev, inbuf, inlen);
+			break;
+		case IPMI_CMD_GET_SEL_ENTRY:
+			response_get_sel_entry_cmd(dev, inbuf, inlen);
+			break;
+		case IPMI_CMD_GET_SEL_TIME:
+			response_get_sel_time_cmd(dev, inbuf, inlen);
+			break;
+		case IPMI_CMD_SET_SEL_TIME:
+			response_set_sel_time_cmd(dev, inbuf, inlen);
+			break;
+		default :
+			ubmc_error(" Unsupported req->ipmi_cmd 0x%02x",req->ipmi_cmd);
+			//return BMC_ERROR;
+			response_ipmi_netfn_default_request(dev, inbuf, inlen);
+			break;
+	}
+
+	return BMC_OK;
+}
+
+/*************************************************************************************/
+
+int response_ipmi_netfn_transport_request(struct ubmc_ipmi_dev *dev, const uint8_t* inbuf, const uint16_t inlen)
+{
+	struct ipmi_ssif_req *req = (struct ipmi_ssif_req*)inbuf;
+	switch( req->ipmi_cmd ){
+		case IPMI_LAN_GET_CONFIG_CMD:
+			response_ipmi_lan_get_config_cmd(dev, inbuf, inlen);
+			break;
+		default :
+			ubmc_error(" Unsupported req->ipmi_cmd 0x%02x",req->ipmi_cmd);
+			//return BMC_ERROR;
+			response_ipmi_netfn_default_request(dev, inbuf, inlen);
+			break;
+	}
+
+	return BMC_OK;
+}
+
+
+static int response_get_picmg_properties_cmd(struct ubmc_ipmi_dev *dev, const uint8_t* inbuf, const uint16_t inlen)
+{
+	struct ipmi_ssif_req *req = (struct ipmi_ssif_req*)inbuf;
+	uint8_t* p_tmp_rsp_buf = dev->rsp_buf;
+	p_tmp_rsp_buf[1] = (((req->netfn >> 2) + 1) << 2 );
+	p_tmp_rsp_buf[2] = req->ipmi_cmd;
+	p_tmp_rsp_buf[3] = 0x00;     // rsp->data[0]
+	p_tmp_rsp_buf[4] = 0x02;
+	p_tmp_rsp_buf[5] = 0x02;
+	p_tmp_rsp_buf[6] = 0x03;
+	p_tmp_rsp_buf[7] = 0x00;
+	//p_tmp_rsp_buf[4] = 0x00;     // for ssif_info->global_enables
+	// the length of the i2c message
+	p_tmp_rsp_buf[0] = 0x07;
+
+	return ubmc_ssif_response_push(dev, (struct ipmi_ssif_rsp *)p_tmp_rsp_buf);
+}
+
+static int response_ipmi_netfn_picmg_request(struct ubmc_ipmi_dev *dev, const uint8_t* inbuf, const uint16_t inlen)
+{
+	struct ipmi_ssif_req *req = (struct ipmi_ssif_req*)inbuf;
+	switch( req->ipmi_cmd ){
+		case PICMG_GET_PICMG_PROPERTIES_CMD:
+			response_get_picmg_properties_cmd(dev, inbuf, inlen);
+			break;
+		default :
+			ubmc_error(" Unsupported req->ipmi_cmd 0x%02x",req->ipmi_cmd);
+			//return BMC_ERROR;
+			response_ipmi_netfn_default_request(dev, inbuf, inlen);
+			break;
+	}
+
+	return BMC_OK;
+}
+
+char* ubmc_ipmi_get_netfn_name(uint8_t netfn)
+{
+	switch(netfn)
+	{
+	case IPMI_NETFN_CHASSIS	:
+		return "CHASSIS";
+	case IPMI_NETFN_BRIDGE	:
+		return "BRIDGE";
+	case IPMI_NETFN_SE	:
+		return "SE";
+	case IPMI_NETFN_APP	:
+		return "APP";
+	case IPMI_NETFN_FIRMWARE	:
+		return "FIRMWARE";
+	case IPMI_NETFN_STORAGE	:
+		return "STORAGE";
+	case IPMI_NETFN_TRANSPORT	:
+		return "TRANSPORT";
+	case IPMI_NETFN_PICMG	:
+		return "PICMG";
+	case IPMI_NETFN_OEM	:
+		return "OEM";
+	case IPMI_NETFN_ISOL	:
+		return "ISOL";
+	case IPMI_NETFN_TSOL	:
+		return "TSOL";
+	default:
+		return "Unknown";
+	}
+}
+
+int ubmc_ssif_parse_i2c_slave_msg(struct ubmc_ipmi_dev *dev, const uint8_t* inbuf, const uint16_t inlen, uint8_t* outbuf, uint16_t* p_out_len)
+{
+	struct ipmi_ssif_req *req = (struct ipmi_ssif_req*)inbuf;
+	uint8_t netfn;
+	int ret = 0;
+	if( req->smb_cmd != SSIF_IPMI_REQUEST ){
+		ubmc_error("req->smb_cmd 0x%02x", req->smb_cmd);
+		return BMC_ERROR;
+	}
+
+	// to check the i2c message length
+	if( (req->len + 2) > inlen ){
+		ubmc_error(" it's not a complete message");
+		return BMC_ERROR;
+	}
+
+	//reset response length
+	memset(dev->rsp_buf,0,sizeof(dev->rsp_buf));
+	dev->rsp_i2c_len = 0;
+	netfn = req->netfn>>2;
+	ubmc_debug(" netfn %9s[0x%02x] cmdid 0x%02x len %u",ubmc_ipmi_get_netfn_name(netfn), netfn,req->ipmi_cmd, req->len);
+	switch( netfn )
+	{
+		case IPMI_NETFN_SE:
+			ret = response_ipmi_netfn_sensor_request(dev, inbuf, inlen);
+			break;
+		case IPMI_NETFN_APP_REQUEST:
+			ret = response_ipmi_netfn_app_request(dev, inbuf, inlen);
+			break;
+		case IPMI_NETFN_STORAGE:
+			ret = response_ipmi_netfn_storage_request(dev, inbuf, inlen);
+			break;
+		case IPMI_NETFN_TRANSPORT:
+			ret = response_ipmi_netfn_transport_request(dev, inbuf, inlen);
+			break;
+		case IPMI_NETFN_PICMG:
+			ret = response_ipmi_netfn_picmg_request(dev, inbuf, inlen);
+			break;
+		default:
+			ubmc_error(" Unsupported req->netfn %s 0x%02x",ubmc_ipmi_get_netfn_name(netfn), netfn);
+			//return BMC_ERROR;
+			ret = response_ipmi_netfn_default_request(dev, inbuf, inlen);
+			break;
+	}
+	if(dev->rsp_i2c_len>1)
+	{
+		memcpy(outbuf, dev->rsp_buf, dev->rsp_i2c_len);
+		*p_out_len = dev->rsp_i2c_len;
+	}
+	else
+	{
+		ubmc_debug(" netfn 0x%02x cmdid 0x%02x not handled",req->netfn,req->ipmi_cmd);
+		ret = BMC_ERROR;
+	}
+	return ret;
+}
+
+
--- linux-ti2018.02-rc4-int-orig/drivers/i2c/busses/ubmc-ipmi.c	1970-01-01 08:00:00.000000000 +0800
+++ linux-ti2018.02-rc4-int-silicom/drivers/i2c/busses/ubmc-ipmi.c	2020-03-09 10:47:12.013803576 +0800
@@ -0,0 +1,843 @@
+#include <linux/mm.h>
+#include <linux/i2c.h>
+#include <linux/init.h>
+#include <linux/list.h>
+#include <linux/mm_types.h>
+#include <linux/module.h>
+#include <linux/spinlock.h>
+#include <linux/sysfs.h>
+#include <linux/wait.h>
+#include <linux/slab.h>
+#include <linux/uaccess.h>
+#include <linux/mm_types.h>
+#include <linux/interrupt.h>
+#include <linux/mm.h>
+#include <linux/io.h>
+#include <linux/seq_file.h>
+#include <linux/proc_fs.h>
+
+#include "ubmc-i2c-ipmi.h"
+#include "ubmc-i2c-slave.h"
+//#include "ubmc-muxdump.h"
+//#include "ubmc-spi-reg.h"
+#include "ubmc-ipmi-sel.h"
+struct ubmc_ipmi_dev g_ubmc_ipmi_pdev;
+//static struct proc_dir_entry *root_umbc_dir;
+
+/*
+ *
+ * If on the bus the Single Block Write looks like:
+ *
+ * | Slave addr (wr) | CMD = 0x02 | Length | NetFn (6) | LUN | IPMI CMD |
+ * | IPMI Data[x] | [PEC] |
+ *
+ * Then the contents of buf are everything but the slave addr
+ */
+int ubmc_i2c_slave_ssif_req_handle(struct ubmc_ipmi_dev *dev, const uint8_t* inbuf, const uint16_t inlen,
+		uint8_t* outbuf, uint16_t* p_outlen)
+{
+	if(ubmc_debug_enable)
+		print_hex_dump(KERN_DEBUG, "SSIF MSG RX:", DUMP_PREFIX_OFFSET, 16, 1, inbuf, inlen, false);
+	// Check for retran
+	if( inlen == 1 && inbuf[0] == SSIF_IPMI_RESPONSE ){
+		// indicate that we should send it again to the i2c master (host) .
+		// i2c_client should have the old data still.
+		ubmc_error("Restransmit Last Response");
+		*p_outlen = dev->rsp_len_last;
+		return BMC_OK;
+	}
+
+	// This is the request command from host ( command + data) , Indicate that
+	// we should parse it and prepare the Reply data .
+	if( ubmc_ssif_parse_i2c_slave_msg(dev, inbuf, inlen, outbuf, p_outlen) == BMC_ERROR )
+	{
+		return BMC_ERROR;
+	}
+	//safe length for retransmit;
+	dev->rsp_len_last = *p_outlen;
+
+	return BMC_OK;
+}
+
+
+/************************************************************
+ * all the ipmi sensors of the ubmc platform
+	TEMP_VECPE_CPU   | 41 degrees C      | ok
+	TEMP_VECPE_AMB1  | 37 degrees C      | ok
+	TEMP_INLET       | 28 degrees C      | ok
+	TEMP_UBMC_AMB1   | 41 degrees C      | ok
+	FAN1_TACH        | 5800 RPM          | ok
+	FAN2_TACH        | 5400 RPM          | ok
+	FAN1_TACH        | 5700 RPM          | ok
+	V5A_SCALED       | 4.96 Volts        | ok
+	V3P3_SCALED      | 3.16 Volts        | ok
+	VCCSRAM_SCALED   | #.## Volts        | ok
+	VCCP_SCALED      | #.## Volts        | ok
+	V1P05_SCALED     | 1.05 Volts        | ok
+	VDDQ_SCALED      | #.## Volts        | ok
+	VNN_SCALED       | #.## Volts        | ok
+	V1P8_SCALED      | 1.80 Volts        | ok
+**/
+// remember that the id must  be same with the index of the array .
+// This next id must be same with the id of the below line .
+/*static ubmc_sensor_s ubmc_sensors[] = {
+	UBMC_SENSOR_SEGMENT("TEMP_HOST_CPU" ,UBMC_SENSOR_TEMP,0x00,0x0001,0x0000,UBMC_TEMP_SENSOR_DEFAUT_THRESHOLDS),
+	UBMC_SENSOR_SEGMENT("TEMP_HOST_PCB" ,UBMC_SENSOR_TEMP,0x01,0x0002,0x0001,UBMC_TEMP_SENSOR_DEFAUT_THRESHOLDS),
+	UBMC_SENSOR_SEGMENT("TEMP_INLET_AMB",UBMC_SENSOR_TEMP,0x02,0x0003,0x0002,UBMC_TEMP_SENSOR_DEFAUT_THRESHOLDS),
+	UBMC_SENSOR_SEGMENT("FAN1_TACH"     ,UBMC_SENSOR_FAN ,0x03,0x0004,0x0003,UBMC_FAN_SENSOR_DEFAUT_THRESHOLDS ),
+	UBMC_SENSOR_SEGMENT("FAN2_TACH"     ,UBMC_SENSOR_FAN ,0x04,0x0005,0x0004,UBMC_FAN_SENSOR_DEFAUT_THRESHOLDS ),
+	UBMC_SENSOR_SEGMENT("5V"            ,UBMC_SENSOR_VOL ,0x05,0x0006,0x0005,UBMC_VOL_SENSOR_DEFAUT_THRESHOLDS ),
+	UBMC_SENSOR_SEGMENT("3.3V"          ,UBMC_SENSOR_VOL ,0x06,0x0007,0x0006,UBMC_VOL_SENSOR_DEFAUT_THRESHOLDS ),
+	UBMC_SENSOR_SEGMENT("CPU_VCCSRAM"   ,UBMC_SENSOR_VOL ,0x07,0x0008,0x0007,UBMC_VOL_SENSOR_DEFAUT_THRESHOLDS ),
+	UBMC_SENSOR_SEGMENT("CPU_VCCP"      ,UBMC_SENSOR_VOL ,0x08,0x0009,0x0008,UBMC_VOL_SENSOR_DEFAUT_THRESHOLDS ),
+	UBMC_SENSOR_SEGMENT("1.05V"         ,UBMC_SENSOR_VOL ,0x09,0x000a,0x0009,UBMC_VOL_SENSOR_DEFAUT_THRESHOLDS ),
+	UBMC_SENSOR_SEGMENT("MEM_VDDQ"      ,UBMC_SENSOR_VOL ,0x0a,0x000b,0x000a,UBMC_VOL_SENSOR_DEFAUT_THRESHOLDS ),
+	UBMC_SENSOR_SEGMENT("CPU_VNN"       ,UBMC_SENSOR_VOL ,0x0b,0x000c,0x000b,UBMC_VOL_SENSOR_DEFAUT_THRESHOLDS ),
+	// the next id of the last must be 0xffff
+	UBMC_SENSOR_SEGMENT("1.8V"          ,UBMC_SENSOR_VOL ,0x0c,0xffff,0x000c,UBMC_VOL_SENSOR_DEFAUT_THRESHOLDS ),
+};
+*/
+static ubmc_sensor_s ubmc_xsmall_sensors[] = {
+	UBMC_SENSOR_SEGMENT("TEMP_HOST_CPU" 	,UBMC_SENSOR_TEMP,0x00,0x0001,0x0000,UBMC_TEMP_HOST_CPU_THRESHOLDS,0x33),
+	UBMC_SENSOR_SEGMENT("TEMP_HOST_PCB" 	,UBMC_SENSOR_TEMP,0x01,0x0002,0x0001,UBMC_TEMP_HOST_PCB_THRESHOLDS,0x33),
+	UBMC_SENSOR_SEGMENT("TEMP_INLET_AMB"	,UBMC_SENSOR_TEMP,0x02,0x0003,0x0002,UBMC_TEMP_INLET_AMB_THRESHOLDS,0x33),
+	UBMC_SENSOR_SEGMENT("FAN1_TACH"     	,UBMC_SENSOR_FAN ,0x03,0x0004,0x0003,UBMC_FAN1_TACH_THRESHOLDS ,0x33),
+//	UBMC_SENSOR_SEGMENT("FAN2_TACH"     	,UBMC_SENSOR_FAN ,0x04,0x0005,0x0004,UBMC_FAN2_TACH_THRESHOLDS ,0x33),
+	UBMC_SENSOR_SEGMENT("CPU_BRD 5V"    	,UBMC_SENSOR_VOL ,0x04,0x0005,0x0004,VOLT_5_0_THRESHOLDS ,0x21),
+	UBMC_SENSOR_SEGMENT("CPU_BRD 3.3V"      ,UBMC_SENSOR_VOL ,0x05,0x0006,0x0005,VOLT_3_3_THRESHOLDS ,0x21),
+	UBMC_SENSOR_SEGMENT("CPU_BRD VCCSRAM"   ,UBMC_SENSOR_VOL ,0x06,0x0007,0x0006,VCCSRAM_THRESHOLDS ,0x21),
+	UBMC_SENSOR_SEGMENT("CPU_BRD VCCP"      ,UBMC_SENSOR_VOL ,0x07,0x0008,0x0007,VCCP_THRESHOLDS ,0x21),
+	UBMC_SENSOR_SEGMENT("CPU_BRD 1.05V"     ,UBMC_SENSOR_VOL ,0x08,0x0009,0x0008,VOLT_1_0_5_THRESHOLDS ,0x21),
+	UBMC_SENSOR_SEGMENT("CPU_BRD MEMVDDQ"   ,UBMC_SENSOR_VOL ,0x09,0x000a,0x0009,MEM_VDDQ_THRESHOLDS ,0x21),
+	UBMC_SENSOR_SEGMENT("CPU_BRD VNN"       ,UBMC_SENSOR_VOL ,0x0a,0x000b,0x000a,CPU_VNN_THRESHOLDS ,0x21),
+	// the next id of the last must be 0xffff
+	UBMC_SENSOR_SEGMENT("CPU_BRD 1.8V"      ,UBMC_SENSOR_VOL ,0x0b,0xffff,0x000b,VOLT_1_8_THRESHOLDS ,0x21),
+};
+
+
+static ubmc_sensor_s ubmc_s_m_sensors[] = {
+	UBMC_SENSOR_SEGMENT("TEMP_HOST_CPU" ,UBMC_SENSOR_TEMP,0x00,0x0001,0x0000,UBMC_TEMP_HOST_CPU_THRESHOLDS,0x33),
+	UBMC_SENSOR_SEGMENT("TEMP_HOST_PCB" ,UBMC_SENSOR_TEMP,0x01,0x0002,0x0001,UBMC_TEMP_HOST_PCB_THRESHOLDS,0x33),
+	UBMC_SENSOR_SEGMENT("TEMP_INLET_AMB",UBMC_SENSOR_TEMP,0x02,0x0003,0x0002,UBMC_TEMP_INLET_AMB_THRESHOLDS,0x33),
+
+	UBMC_SENSOR_SEGMENT("FAN1_TACH"     ,UBMC_SENSOR_FAN ,0x03,0x0004,0x0003,UBMC_FAN1_TACH_THRESHOLDS ,0x33),
+	UBMC_SENSOR_SEGMENT("FAN2_TACH"     ,UBMC_SENSOR_FAN ,0x04,0x0005,0x0004,UBMC_FAN2_TACH_THRESHOLDS ,0x33),
+	UBMC_SENSOR_SEGMENT("FAN3_TACH"     ,UBMC_SENSOR_FAN ,0x05,0x0006,0x0005,UBMC_FAN2_TACH_THRESHOLDS ,0x33),
+
+	UBMC_SENSOR_SEGMENT("CPU_BRD 5V"    ,UBMC_SENSOR_VOL ,0x06,0x0007,0x0006,VOLT_5_0_THRESHOLDS ,0x21),
+	UBMC_SENSOR_SEGMENT("CPU_BRD 3.3V"  ,UBMC_SENSOR_VOL ,0x07,0x0008,0x0007,VOLT_3_3_THRESHOLDS ,0x21),
+	UBMC_SENSOR_SEGMENT("CPU_BRD VCCSRAM",UBMC_SENSOR_VOL ,0x08,0x0009,0x0008,VCCSRAM_THRESHOLDS ,0x21),
+	UBMC_SENSOR_SEGMENT("CPU_BRD VCCP"   ,UBMC_SENSOR_VOL ,0x09,0x000a,0x0009,VCCP_THRESHOLDS ,0x21),
+	UBMC_SENSOR_SEGMENT("CPU_BRD 1.05V"  ,UBMC_SENSOR_VOL ,0x0a,0x000b,0x000a,VOLT_1_0_5_THRESHOLDS ,0x21),
+	UBMC_SENSOR_SEGMENT("CPU_BRD MEMVDDQ",UBMC_SENSOR_VOL ,0x0b,0x000c,0x000b,MEM_VDDQ_THRESHOLDS ,0x21),
+	UBMC_SENSOR_SEGMENT("CPU_BRD VNN"    ,UBMC_SENSOR_VOL ,0x0c,0x000d,0x000c,CPU_VNN_THRESHOLDS ,0x21),
+	UBMC_SENSOR_SEGMENT("CPU_BRD 1.8V"   ,UBMC_SENSOR_VOL ,0x0d,0x000e,0x000d,VOLT_1_8_THRESHOLDS ,0x21),
+
+	UBMC_SENSOR_SEGMENT("IO_BRD 5V"      ,UBMC_SENSOR_VOL ,0x0e,0x000f,0x000e,L_VOLT_5_0_THRESHOLDS ,0x21),
+	UBMC_SENSOR_SEGMENT("IO_BRD VCC3V3"  ,UBMC_SENSOR_VOL ,0x0f,0x0010,0x000f,L_VOLT_3_3_THRESHOLDS ,0x21),
+	UBMC_SENSOR_SEGMENT("IO_BRD VDD1V8"  ,UBMC_SENSOR_VOL ,0x10,0x0011,0x0010,L_VOLT_1_8_THRESHOLDS ,0x21),
+	UBMC_SENSOR_SEGMENT("IO_BRD VDD1V5"  ,UBMC_SENSOR_VOL ,0x11,0x0012,0x0011,L_VOLT_1_5_THRESHOLDS ,0x21),
+	UBMC_SENSOR_SEGMENT("IO_BRD VDD1V0"  ,UBMC_SENSOR_VOL ,0x12,0x0013,0x0012,L_VOLT_1_0_THRESHOLDS ,0x21),
+	UBMC_SENSOR_SEGMENT("IO_BRD VDD1V0A" ,UBMC_SENSOR_VOL ,0x13,0x0014,0x0013,L_VOLT_1_0_THRESHOLDS ,0x21),
+	UBMC_SENSOR_SEGMENT("IO_BRD V3P3A"   ,UBMC_SENSOR_VOL ,0x14,0x0015,0x0014,L_VOLT2_3_3_THRESHOLDS ,0x21),
+	UBMC_SENSOR_SEGMENT("IO_BRD V1P1"    ,UBMC_SENSOR_VOL ,0x15,0x0016,0x0015,L_VOLT_1_1_THRESHOLDS ,0x21),
+	UBMC_SENSOR_SEGMENT("IO_BRD RTC_BAT" ,UBMC_SENSOR_VOL ,0x16,0x0017,0x0016,L_VOLT_3_3_THRESHOLDS ,0x21),
+	// the next id of the last must be 0xffff
+	UBMC_SENSOR_SEGMENT("IO_BRD V5TO12A" ,UBMC_SENSOR_VOL ,0x17,0xffff,0x0017,L_VOLT_3_3_THRESHOLDS ,0x21),
+};
+
+/*
+static ubmc_sensor_s ubmc_large_sensors[] = {
+	UBMC_SENSOR_SEGMENT("TEMP_HOST_CPU" ,UBMC_SENSOR_TEMP,0x00,0x0001,0x0000,UBMC_TEMP_HOST_CPU_THRESHOLDS,0x33),
+	UBMC_SENSOR_SEGMENT("TEMP_HOST_PCB" ,UBMC_SENSOR_TEMP,0x01,0x0002,0x0001,UBMC_TEMP_HOST_PCB_THRESHOLDS,0x33),
+	UBMC_SENSOR_SEGMENT("TEMP_INLET_AMB",UBMC_SENSOR_TEMP,0x02,0x0003,0x0002,UBMC_TEMP_INLET_AMB_THRESHOLDS,0x33),
+
+	UBMC_SENSOR_SEGMENT("FAN1_TACH"     ,UBMC_SENSOR_FAN ,0x03,0x0004,0x0003,UBMC_FAN1_TACH_THRESHOLDS ,0x33),
+	UBMC_SENSOR_SEGMENT("FAN2_TACH"     ,UBMC_SENSOR_FAN ,0x04,0x0005,0x0004,UBMC_FAN2_TACH_THRESHOLDS ,0x33),
+	UBMC_SENSOR_SEGMENT("FAN3_TACH"     ,UBMC_SENSOR_FAN ,0x05,0x0006,0x0005,UBMC_FAN2_TACH_THRESHOLDS ,0x33),
+
+	UBMC_SENSOR_SEGMENT("CPU_BRD 5V"    ,UBMC_SENSOR_VOL ,0x06,0x0007,0x0006,VOLT_5_0_THRESHOLDS ,0x21),
+	UBMC_SENSOR_SEGMENT("CPU_BRD 3.3V"  ,UBMC_SENSOR_VOL ,0x07,0x0008,0x0007,VOLT_3_3_THRESHOLDS ,0x21),
+	UBMC_SENSOR_SEGMENT("CPU_BRD VCCSRAM",UBMC_SENSOR_VOL ,0x08,0x0009,0x0008,VCCSRAM_THRESHOLDS ,0x21),
+	UBMC_SENSOR_SEGMENT("CPU_BRD VCCP"   ,UBMC_SENSOR_VOL ,0x09,0x000a,0x0009,VCCP_THRESHOLDS ,0x21),
+	UBMC_SENSOR_SEGMENT("CPU_BRD 1.05V"  ,UBMC_SENSOR_VOL ,0x0a,0x000b,0x000a,VOLT_1_0_5_THRESHOLDS ,0x21),
+	UBMC_SENSOR_SEGMENT("CPU_BRD MEMVDDQ",UBMC_SENSOR_VOL ,0x0b,0x000c,0x000b,MEM_VDDQ_THRESHOLDS ,0x21),
+	UBMC_SENSOR_SEGMENT("CPU_BRD VNN"    ,UBMC_SENSOR_VOL ,0x0c,0x000d,0x000c,CPU_VNN_THRESHOLDS ,0x21),
+	UBMC_SENSOR_SEGMENT("CPU_BRD 1.8V"   ,UBMC_SENSOR_VOL ,0x0d,0x000e,0x000d,VOLT_1_8_THRESHOLDS ,0x21),
+
+	UBMC_SENSOR_SEGMENT("IO_BRD 12V"           ,UBMC_SENSOR_VOL ,0x0e,0x000f,0x000e,L_VOLT_12_THRESHOLDS ,0x21),
+	UBMC_SENSOR_SEGMENT("IO_BRD 5V"            ,UBMC_SENSOR_VOL ,0x0f,0x0010,0x000f,L_VOLT_5_0_THRESHOLDS ,0x21),
+	UBMC_SENSOR_SEGMENT("IO_BRD VDD3V3"        ,UBMC_SENSOR_VOL ,0x10,0x0011,0x0010,L_VOLT_3_3_THRESHOLDS ,0x21),
+	UBMC_SENSOR_SEGMENT("IO_BRD VDD1V0D"       ,UBMC_SENSOR_VOL ,0x11,0x0012,0x0011,L_VOLT_1_0_THRESHOLDS ,0x21),
+	UBMC_SENSOR_SEGMENT("IO_BRD VDD1V0A"       ,UBMC_SENSOR_VOL ,0x12,0x0013,0x0012,L_VOLT_1_0_THRESHOLDS ,0x21),
+	UBMC_SENSOR_SEGMENT("IO_BRD VDD1V8"        ,UBMC_SENSOR_VOL ,0x13,0x0014,0x0013,L_VOLT_1_8_THRESHOLDS ,0x21),
+	UBMC_SENSOR_SEGMENT("IO_BRD TVDD1P25"      ,UBMC_SENSOR_VOL ,0x14,0x0015,0x0014,L_VOLT_1_0_THRESHOLDS ,0x21),
+	UBMC_SENSOR_SEGMENT("IO_BRD 1V0_PHY"        ,UBMC_SENSOR_VOL ,0x15,0x0016,0x0015,L_VOLT_1_0_THRESHOLDS ,0x21),
+	UBMC_SENSOR_SEGMENT("IO_BRD V1P35"          ,UBMC_SENSOR_VOL ,0x16,0x0017,0x0016,L_VOLT_1_35_THRESHOLDS ,0x21),
+	UBMC_SENSOR_SEGMENT("IO_BRD DDR_VTT"        ,UBMC_SENSOR_VOL ,0x17,0x0018,0x0017,L_VOLT_VTT_DDR3_THRESHOLDS ,0x21),
+	UBMC_SENSOR_SEGMENT("IO_BRD V1P8"           ,UBMC_SENSOR_VOL ,0x18,0x0019,0x0018,L_VOLT_1_8_THRESHOLDS ,0x21),
+	UBMC_SENSOR_SEGMENT("IO_BRD V1P1"           ,UBMC_SENSOR_VOL ,0x19,0x001a,0x0019,L_VOLT_1_1_THRESHOLDS ,0x21),
+	UBMC_SENSOR_SEGMENT("IO_BRD V3P3A"          ,UBMC_SENSOR_VOL ,0x1a,0x001b,0x001a,L_VOLT2_3_3_THRESHOLDS ,0x21),
+	// the next id of the last must be 0xffff
+	UBMC_SENSOR_SEGMENT("IO_BRD VDD_1V5"        ,UBMC_SENSOR_VOL ,0x1b,0x001c,0x001b,L_VOLT_1_5_THRESHOLDS ,0x21),
+	UBMC_SENSOR_SEGMENT("Power Supply1"        ,UBMC_SENSOR_VOL ,0x1c,0x001d,0x001c,L_VOLT_1_5_THRESHOLDS ,0x21),
+	UBMC_SENSOR_SEGMENT("Power Supply1"        ,UBMC_SENSOR_VOL ,0x1d,0xffff,0x001d,L_VOLT_1_5_THRESHOLDS ,0x21),
+
+};*/
+
+
+static ubmc_sensor_s ubmc_large_sensors[] = {
+	UBMC_SENSOR_SEGMENT("TEMP_HOST_CPU" 		,UBMC_SENSOR_TEMP,0x00,0x0001,0x0000,UBMC_TEMP_HOST_CPU_THRESHOLDS,0x33),
+	UBMC_SENSOR_SEGMENT("TEMP_HOST_PCB" 		,UBMC_SENSOR_TEMP,0x01,0x0002,0x0001,UBMC_TEMP_HOST_PCB_THRESHOLDS,0x33),
+	UBMC_SENSOR_SEGMENT("TEMP_INLET_AMB"		,UBMC_SENSOR_TEMP,0x02,0x0003,0x0002,UBMC_TEMP_INLET_AMB_THRESHOLDS,0x33),
+	UBMC_SENSOR_SEGMENT("PS1_TEMP" 				,UBMC_SENSOR_TEMP,0x03,0x0004,0x0003,UBMC_TEMP_HOST_PCB_THRESHOLDS,0x33),
+	UBMC_SENSOR_SEGMENT("PS2_TEMP"				,UBMC_SENSOR_TEMP,0x04,0x0005,0x0004,UBMC_TEMP_INLET_AMB_THRESHOLDS,0x33),
+	UBMC_SENSOR_SEGMENT("PS3_TEMP"				,UBMC_SENSOR_TEMP,0x05,0x0006,0x0005,UBMC_TEMP_INLET_AMB_THRESHOLDS,0x33),
+
+	UBMC_SENSOR_SEGMENT("FAN1_TACH"     		,UBMC_SENSOR_FAN ,0x06,0x0007,0x0006,UBMC_FAN1_TACH_THRESHOLDS ,0x33),
+	UBMC_SENSOR_SEGMENT("FAN2_TACH"     		,UBMC_SENSOR_FAN ,0x07,0x0008,0x0007,UBMC_FAN2_TACH_THRESHOLDS ,0x33),
+	UBMC_SENSOR_SEGMENT("FAN3_TACH"     		,UBMC_SENSOR_FAN ,0x08,0x0009,0x0008,UBMC_FAN2_TACH_THRESHOLDS ,0x33),
+	UBMC_SENSOR_SEGMENT("PS1_FAN_TACH"  		,UBMC_SENSOR_FAN ,0x09,0x000a,0x0009,UBMC_FAN2_TACH_THRESHOLDS ,0x33),
+	UBMC_SENSOR_SEGMENT("PS2_FAN_TACH"  		,UBMC_SENSOR_FAN ,0x0a,0x000b,0x000a,UBMC_FAN2_TACH_THRESHOLDS ,0x33),
+
+	UBMC_SENSOR_SEGMENT("CPU_BRD 5V"    		,UBMC_SENSOR_VOL ,0x0b,0x000c,0x000b,VOLT_5_0_THRESHOLDS ,0x21),
+	UBMC_SENSOR_SEGMENT("CPU_BRD 3.3V"  		,UBMC_SENSOR_VOL ,0x0c,0x000d,0x000c,VOLT_3_3_THRESHOLDS ,0x21),
+	UBMC_SENSOR_SEGMENT("CPU_BRD VCCSRAM"		,UBMC_SENSOR_VOL ,0x0d,0x000e,0x000d,VCCSRAM_THRESHOLDS ,0x21),
+	UBMC_SENSOR_SEGMENT("CPU_BRD VCCP"   		,UBMC_SENSOR_VOL ,0x0e,0x000f,0x000e,VCCP_THRESHOLDS ,0x21),
+	UBMC_SENSOR_SEGMENT("CPU_BRD 1.05V"  		,UBMC_SENSOR_VOL ,0x0f,0x0010,0x000f,VOLT_1_0_5_THRESHOLDS ,0x21),
+	UBMC_SENSOR_SEGMENT("CPU_BRD MEMVDDQ"		,UBMC_SENSOR_VOL ,0x10,0x0011,0x0010,MEM_VDDQ_THRESHOLDS ,0x21),
+	UBMC_SENSOR_SEGMENT("CPU_BRD VNN"    		,UBMC_SENSOR_VOL ,0x11,0x0012,0x0011,CPU_VNN_THRESHOLDS ,0x21),
+	UBMC_SENSOR_SEGMENT("CPU_BRD 1.8V"  		,UBMC_SENSOR_VOL ,0x12,0x0013,0x0012,VOLT_1_8_THRESHOLDS ,0x21),
+
+	UBMC_SENSOR_SEGMENT("IO_BRD 12V"           ,UBMC_SENSOR_VOL ,0x13,0x0014,0x0013,L_VOLT_12_THRESHOLDS ,0x21),
+	UBMC_SENSOR_SEGMENT("IO_BRD 5V"            ,UBMC_SENSOR_VOL ,0x14,0x0015,0x0014,L_VOLT_5_0_THRESHOLDS ,0x21),
+	UBMC_SENSOR_SEGMENT("IO_BRD VDD3V3"        ,UBMC_SENSOR_VOL ,0x15,0x0016,0x0015,L_VOLT_3_3_THRESHOLDS ,0x21),
+	UBMC_SENSOR_SEGMENT("IO_BRD VDD1V0D"       ,UBMC_SENSOR_VOL ,0x16,0x0017,0x0016,L_VOLT_1_0_THRESHOLDS ,0x21),
+	UBMC_SENSOR_SEGMENT("IO_BRD VDD1V0A"       ,UBMC_SENSOR_VOL ,0x17,0x0018,0x0017,L_VOLT_1_0_THRESHOLDS ,0x21),
+	UBMC_SENSOR_SEGMENT("IO_BRD VDD1V8"        ,UBMC_SENSOR_VOL ,0x18,0x0019,0x0018,L_VOLT_1_8_THRESHOLDS ,0x21),
+	UBMC_SENSOR_SEGMENT("IO_BRD TVDD1P25"      ,UBMC_SENSOR_VOL ,0x19,0x001a,0x0019,L_VOLT_1_0_THRESHOLDS ,0x21),
+	UBMC_SENSOR_SEGMENT("IO_BRD 1V0_PHY"        ,UBMC_SENSOR_VOL ,0x1a,0x001b,0x001a,L_VOLT_1_0_THRESHOLDS ,0x21),
+	UBMC_SENSOR_SEGMENT("IO_BRD V1P35"          ,UBMC_SENSOR_VOL ,0x1b,0x001c,0x001b,L_VOLT_1_35_THRESHOLDS ,0x21),
+	UBMC_SENSOR_SEGMENT("IO_BRD DDR_VTT"        ,UBMC_SENSOR_VOL ,0x1c,0x001d,0x001c,L_VOLT_VTT_DDR3_THRESHOLDS ,0x21),
+	UBMC_SENSOR_SEGMENT("IO_BRD V1P8"           ,UBMC_SENSOR_VOL ,0x1d,0x001e,0x001d,L_VOLT_1_8_THRESHOLDS ,0x21),
+	UBMC_SENSOR_SEGMENT("IO_BRD V1P1"           ,UBMC_SENSOR_VOL ,0x1e,0x001f,0x001e,L_VOLT_1_1_THRESHOLDS ,0x21),
+	UBMC_SENSOR_SEGMENT("IO_BRD V3P3A"          ,UBMC_SENSOR_VOL ,0x1f,0x0020,0x001f,L_VOLT2_3_3_THRESHOLDS ,0x21),
+	// the next id of the last must be 0xffff
+	UBMC_SENSOR_SEGMENT("IO_BRD VDD_1V5"        ,UBMC_SENSOR_VOL ,0x20,0x0021,0x0020,L_VOLT_1_5_THRESHOLDS ,0x21),
+	UBMC_SENSOR_SEGMENT("PS1_V54"        		,UBMC_SENSOR_VOL ,0x21,0x0022,0x0021,L_VOLT_54_THRESHOLDS ,0x21),
+	UBMC_SENSOR_SEGMENT("PS2_V54"        		,UBMC_SENSOR_VOL ,0x22,0x0023,0x0022,L_VOLT_54_THRESHOLDS ,0x21),
+	UBMC_SENSOR_SEGMENT("PS3_V12"       	    ,UBMC_SENSOR_VOL ,0x23,0xffff,0x0023,L_VOLT_12_THRESHOLDS ,0x21),
+
+};
+
+int ubmc_sensor_addr_get(uint8_t sensornum,ubmc_sensor_s **paddr);
+
+
+
+// init ubmc temperature type sensor segments
+// I just set the values for some special fields, and everything else is the default.
+// i get the default value by testing the 'ipmitool sdr' command on the psensor->cmn ibm server.
+static int  ubmc_ipmi_sdr_record_temp_init(ubmc_sensor_s *ptr,uint8_t sensornum,const char *pidstring)
+{
+	sdr_get_rs *pheader = NULL;
+	sdr_record_full_sensor *psensor = NULL;
+	if( !ptr || !pidstring ){
+		return BMC_ERROR;
+	}
+	pheader = &ptr->sdr_header;
+	psensor = &ptr->sensor;
+
+	psensor->cmn.keys.owner_id = 0x20;
+	psensor->cmn.keys.lun = 0x00;
+	psensor->cmn.keys.channel = 0x00;
+	// the sensor_num will be use as parameter , when the host send
+	// IPMI_NETFN_SE nefn and GET_SENSOR_READING request to us
+	// our sensors' data are get from the shared memory( between kernel and userspace )
+	// So we determine  this sensornum should be self-increasing from 0x0000 .
+	// Then it's convenient to get this data from the shared memory .
+	psensor->cmn.keys.sensor_num = sensornum;
+	psensor->cmn.entity.id = 0x03;
+	psensor->cmn.entity.instance = 0x01;
+	psensor->cmn.entity.logical = 0x00;
+	psensor->cmn.sensor.init.sensor_scan = 0x01;
+	psensor->cmn.sensor.init.event_gen = 0x01;
+	psensor->cmn.sensor.init.type = 0x01;
+	psensor->cmn.sensor.init.hysteresis = 0x01;
+	psensor->cmn.sensor.init.thresholds = 0x01;
+	psensor->cmn.sensor.init.events = 0x01;
+	psensor->cmn.sensor.init.scanning = 0x01;
+	psensor->cmn.sensor.capabilities.event_msg = 0x00;
+	psensor->cmn.sensor.capabilities.threshold = 0x02;
+	psensor->cmn.sensor.capabilities.hysteresis = 0x02;
+	psensor->cmn.sensor.capabilities.rearm = 0x01;
+	psensor->cmn.sensor.capabilities.ignore = 0x00;
+	psensor->cmn.sensor.type = 0x01;
+	psensor->cmn.event_type = 0x01;
+	psensor->cmn.mask.type.discrete.assert_event = 0x7200;
+	psensor->cmn.mask.type.discrete.deassert_event = 0x7200;
+	psensor->cmn.mask.type.discrete.read = 0x3f3f;
+	psensor->cmn.unit.pct = 0x0000;
+	psensor->cmn.unit.modifier = 0x0000;
+	psensor->cmn.unit.rate = 0x0000;
+	psensor->cmn.unit.analog = 0x0002;
+	// the psensor->cmn.unit.type.base determine the sensor data's unit .
+	// The details of the calculation can be seen in ipmitool.tar.gz
+	psensor->cmn.unit.type.base = 0x0001;
+	psensor->cmn.unit.type.modifier = 0x0000;
+	// the next three is use to calculate the result to display by 'ipmitool sdr'
+	// The details of the calculation can be seen in ipmitool.tar.gz
+	psensor->linearization = 0x00;
+	psensor->mtol = UBMC_TEMP_SENSOR_DEFAUT_MTOL;
+	psensor->bacc = UBMC_TEMP_SENSOR_DEFAUT_BACC;
+	psensor->analog_flag.nominal_read = 0x01;
+	psensor->analog_flag.normal_max = 0x01;
+	psensor->analog_flag.normal_min = 0x01;
+	psensor->nominal_read = 0x28;
+	psensor->normal_max = 0x59;
+	psensor->normal_min = 0xfc;
+	psensor->sensor_max = 0x7f;
+	psensor->sensor_min = 0x80;
+	psensor->threshold.lower.non_recover = ptr->thresholds[0];
+	psensor->threshold.lower.critical = ptr->thresholds[1];
+	psensor->threshold.lower.non_critical = ptr->thresholds[2];
+	psensor->threshold.upper.non_critical = ptr->thresholds[3];
+	psensor->threshold.upper.critical = ptr->thresholds[4];
+	psensor->threshold.upper.non_recover = ptr->thresholds[5];
+	psensor->threshold.hysteresis.positive = 0x02;
+	psensor->threshold.hysteresis.negative = 0x02;
+	psensor->oem = 0x00;
+	psensor->id_code = 0xc0 | strlen(pidstring);
+	// it will be display in the 'ipmitool sdr' command .
+	strcpy(psensor->id_string,pidstring);
+	// the 16 is the maximum of the psensor->id_string segment .
+	pheader->length = sizeof(sdr_record_full_sensor) - (16 - strlen(pidstring));
+
+	return BMC_OK;
+}
+
+
+
+// init ubmc voltage type sensor segments
+// I just set the values for some special fields, and everything else is the default.
+// i get the default value by testing the 'ipmitool sdr' command on the psensor->cmn ibm server.
+static int  ubmc_ipmi_sdr_record_voltage_init(ubmc_sensor_s *ptr,uint8_t sensornum,const char *pidstring)
+{
+	sdr_get_rs *pheader = NULL;
+	sdr_record_full_sensor *psensor = NULL;
+	if( !ptr || !pidstring ){
+		return BMC_ERROR;
+	}
+	pheader = &ptr->sdr_header;
+	psensor = &ptr->sensor;
+
+	psensor->cmn.keys.owner_id = 0x20;
+	psensor->cmn.keys.lun = 0x00;
+	psensor->cmn.keys.channel = 0x00;
+	// the sensor_num will be use as parameter , when the host send
+	// IPMI_NETFN_SE nefn and GET_SENSOR_READING request to us
+	// our sensors' data are get from the shared memory( between kernel and userspace )
+	// So we determine  this sensornum should be self-increasing from 0x0000 .
+	// Then it's convenient to get this data from the shared memory .
+	psensor->cmn.keys.sensor_num = sensornum;
+	psensor->cmn.entity.id = 0x20;
+	psensor->cmn.entity.instance = 0x01;
+	psensor->cmn.entity.logical = 0x00;
+	psensor->cmn.sensor.init.sensor_scan = 0x01;
+	psensor->cmn.sensor.init.event_gen = 0x00;
+	psensor->cmn.sensor.init.type = 0x01;
+	psensor->cmn.sensor.init.hysteresis = 0x01;
+	psensor->cmn.sensor.init.thresholds = 0x01;
+	psensor->cmn.sensor.init.events = 0x01;
+	psensor->cmn.sensor.init.scanning = 0x01;
+	psensor->cmn.sensor.init.__reserved = 0x00;
+	psensor->cmn.sensor.capabilities.event_msg = 0x00;
+	psensor->cmn.sensor.capabilities.threshold = 0x02;
+	psensor->cmn.sensor.capabilities.hysteresis = 0x02;
+	psensor->cmn.sensor.capabilities.rearm = 0x01;
+	psensor->cmn.sensor.capabilities.ignore = 0x00;
+	psensor->cmn.sensor.type = 0x02;
+	psensor->cmn.event_type = 0x01;
+	psensor->cmn.mask.type.discrete.assert_event = 0x7a14;
+	psensor->cmn.mask.type.discrete.deassert_event = 0x7a14;
+	psensor->cmn.mask.type.discrete.read = 0x3f3f;
+	psensor->cmn.unit.pct = 0x0000;
+	psensor->cmn.unit.modifier = 0x0000;
+	psensor->cmn.unit.rate = 0x0000;
+	psensor->cmn.unit.analog = 0x0002;
+	// the psensor->cmn.unit.type.base determine the sensor data's unit .
+	// The details of the calculation can be seen in ipmitool.tar.gz
+	psensor->cmn.unit.type.base = 0x0004;
+	psensor->cmn.unit.type.modifier = 0x0000;
+	// the next three is use to calculate the result to display by 'ipmitool sdr'
+	// The details of the calculation can be seen in ipmitool.tar.gz
+	psensor->linearization = 0x00;
+	psensor->mtol = UBMC_VOL_SENSOR_DEFAUT_MTOL;
+	psensor->bacc = UBMC_VOL_SENSOR_DEFAUT_BACC;
+	psensor->analog_flag.nominal_read = 0x01;
+	psensor->analog_flag.normal_max = 0x01;
+	psensor->analog_flag.normal_min = 0x01;
+	psensor->nominal_read = 0x7d;
+	psensor->normal_max = 0x8d;
+	psensor->normal_min = 0x6c;
+	psensor->sensor_max = 0xff;
+	psensor->sensor_min = 0x00;
+	psensor->threshold.lower.non_recover = ptr->thresholds[0];
+	psensor->threshold.lower.critical = ptr->thresholds[1];
+	psensor->threshold.lower.non_critical = ptr->thresholds[2];
+	psensor->threshold.upper.non_critical = ptr->thresholds[3];
+	psensor->threshold.upper.critical = ptr->thresholds[4];
+	psensor->threshold.upper.non_recover = ptr->thresholds[5];
+	psensor->threshold.hysteresis.positive = 0x01;
+	psensor->threshold.hysteresis.negative = 0x01;
+	psensor->oem = 0x00;
+	psensor->id_code = 0xc0 | strlen(pidstring);
+	// it will be display in the 'ipmitool sdr' command .
+	strcpy(psensor->id_string,pidstring);
+	// the 16 is the maximum of the psensor->id_string segment .
+	pheader->length = sizeof(sdr_record_full_sensor) - (16 - strlen(pidstring));
+
+	return BMC_OK;
+}
+
+
+// init ubmc fan type sensor segments
+// I just set the values for some special fields, and everything else is the default.
+// i get the default value by testing the 'ipmitool sdr' command on the psensor->cmn ibm server.
+static int  ubmc_ipmi_sdr_record_fan_init(ubmc_sensor_s *ptr,uint8_t sensornum,const char *pidstring)
+{
+	sdr_get_rs *pheader = NULL;
+	sdr_record_full_sensor *psensor = NULL;
+	if( !ptr || !pidstring ){
+		return BMC_ERROR;
+	}
+	pheader = &ptr->sdr_header;
+	psensor = &ptr->sensor;
+
+	psensor->cmn.keys.owner_id = 0x20;
+	psensor->cmn.keys.lun = 0x00;
+	psensor->cmn.keys.channel = 0x00;
+	// the sensor_num will be use as parameter , when the host send
+	// IPMI_NETFN_SE nefn and GET_SENSOR_READING request to us
+	// our sensors' data are get from the shared memory( between kernel and userspace )
+	// So we determine  this sensornum should be self-increasing from 0x0000 .
+	// Then it's convenient to get this data from the shared memory .
+	psensor->cmn.keys.sensor_num = sensornum;
+	psensor->cmn.entity.id = 0x1d;
+	psensor->cmn.entity.instance = 0x03;
+	psensor->cmn.entity.logical = 0x00;
+	psensor->cmn.sensor.init.sensor_scan = 0x01;
+	psensor->cmn.sensor.init.event_gen = 0x00;
+	psensor->cmn.sensor.init.type = 0x01;
+	psensor->cmn.sensor.init.hysteresis = 0x01;
+	psensor->cmn.sensor.init.thresholds = 0x01;
+	psensor->cmn.sensor.init.events = 0x01;
+	psensor->cmn.sensor.init.scanning = 0x01;
+	psensor->cmn.sensor.init.__reserved = 0x00;
+	psensor->cmn.sensor.capabilities.event_msg = 0x00;
+	psensor->cmn.sensor.capabilities.threshold = 0x02;
+	psensor->cmn.sensor.capabilities.hysteresis = 0x02;
+	psensor->cmn.sensor.capabilities.rearm = 0x01;
+	psensor->cmn.sensor.capabilities.ignore = 0x00;
+	psensor->cmn.sensor.type = 0x04;
+	psensor->cmn.event_type = 0x01;
+	psensor->cmn.mask.type.discrete.assert_event = 0x7a14;
+	psensor->cmn.mask.type.discrete.deassert_event = 0x7a14;
+	psensor->cmn.mask.type.discrete.read = 0x3f3f;
+	psensor->cmn.unit.pct = 0x0000;
+	psensor->cmn.unit.modifier = 0x0000;
+	psensor->cmn.unit.rate = 0x0000;
+	psensor->cmn.unit.analog = 0x0002;
+	// the psensor->cmn.unit.type.base determine the sensor data's unit .
+	// The details of the calculation can be seen in ipmitool.tar.gz
+	psensor->cmn.unit.type.base = 0x0012;
+	psensor->cmn.unit.type.modifier = 0x0000;
+	// the next three is use to calculate the result to display by 'ipmitool sdr'
+	// The details of the calculation can be seen in ipmitool.tar.gz
+	psensor->linearization = 0x00;
+	psensor->mtol = UBMC_FAN_SENSOR_DEFAUT_MTOL;
+	psensor->bacc = UBMC_FAN_SENSOR_DEFAUT_BACC;
+	psensor->analog_flag.nominal_read = 0x01;
+	psensor->analog_flag.normal_max = 0x01;
+	psensor->analog_flag.normal_min = 0x01;
+	psensor->nominal_read = 0x80;
+	psensor->normal_max = 0xaa;
+	psensor->normal_min = 0x14;
+	psensor->sensor_max = 0xff;
+	psensor->sensor_min = 0x00;
+	psensor->threshold.lower.non_recover = ptr->thresholds[0];
+	psensor->threshold.lower.critical = ptr->thresholds[1];
+	psensor->threshold.lower.non_critical = ptr->thresholds[2];
+	psensor->threshold.upper.non_critical = ptr->thresholds[3];
+	psensor->threshold.upper.critical = ptr->thresholds[4];
+	psensor->threshold.upper.non_recover = ptr->thresholds[5];
+	psensor->threshold.hysteresis.positive = 0x01;
+	psensor->threshold.hysteresis.negative = 0x01;
+	psensor->oem = 0x00;
+	psensor->id_code = 0xc0 | strlen(pidstring);
+	// it will be display in the 'ipmitool sdr' command .
+	strcpy(psensor->id_string,pidstring);
+	// the 16 is the maximum of the psensor->id_string segment .
+	pheader->length = sizeof(sdr_record_full_sensor) - (16 - strlen(pidstring));
+
+	return BMC_OK;
+}
+
+/***
+ * init ubmc sensors record
+ * */
+static int ubmc_ipmi_sdr_record_init(ubmc_sensor_s *psensor,uint8_t sensornum)
+{
+	switch( psensor->type )
+	{
+	case UBMC_SENSOR_TEMP:
+		if( ubmc_ipmi_sdr_record_temp_init(psensor,sensornum,psensor->name) == BMC_ERROR ){
+			ubmc_error("init_ubmc_temp_sensor_sdr_record Error");
+			return BMC_ERROR;
+		}
+		break;
+	case UBMC_SENSOR_VOL:
+		if( ubmc_ipmi_sdr_record_voltage_init(psensor,sensornum,psensor->name) == BMC_ERROR ){
+			ubmc_error("init_ubmc_vol_sensor_sdr_record Error");
+			return BMC_ERROR;
+		}
+		break;
+	case UBMC_SENSOR_FAN:
+		if( ubmc_ipmi_sdr_record_fan_init(psensor,sensornum,psensor->name) == BMC_ERROR ){
+			ubmc_error("init_ubmc_fan_sensor_sdr_record Error");
+			return BMC_ERROR;
+		}
+		break;
+	default:
+		ubmc_error("Error ptr->type : %d",psensor->type);
+		return BMC_ERROR;
+		break;
+	}
+
+	return BMC_OK;
+}
+
+
+// fill ubmc sensors into the shared memory
+int umbc_ipmi_init_shm_sensor_fill_all(ubmc_device_type_t type)
+{
+	uint8_t i = 0;
+	uint8_t sensor_size;
+	struct ubmc_ipmi_dev* p_dev = &g_ubmc_ipmi_pdev;
+	void *p_tmp;
+	ubmc_sensor_s *pbase = (ubmc_sensor_s *)p_dev->sensor_state_base;
+	ubmc_sensor_s *ubmc_sensors;
+	if(p_dev->device_type == XSMALL)
+	{
+		ubmc_sensors = ubmc_xsmall_sensors;
+		sensor_size = IPMI_SDR_SERSOR_MAX(ubmc_xsmall_sensors);
+	}
+	else if(p_dev->device_type == SMALL || p_dev->device_type == MIDDLE)
+	{
+		ubmc_sensors = ubmc_s_m_sensors;
+		sensor_size = IPMI_SDR_SERSOR_MAX(ubmc_s_m_sensors);
+	}
+	else if(p_dev->device_type == LARGE)
+	{
+		ubmc_sensors = ubmc_large_sensors;
+		sensor_size = IPMI_SDR_SERSOR_MAX(ubmc_large_sensors);
+	}
+	//printk("sensor_size is %d size is %d \n",sensor_size,sizeof(ubmc_large_sensors));
+
+	for(i=0;i<sensor_size;++i)
+	{
+		ubmc_sensor_s *p = &ubmc_sensors[i];
+		// before memcopy , init ubmc sensor sdr record
+		if( ubmc_ipmi_sdr_record_init(p,i) == BMC_ERROR )
+		{
+			ubmc_error("Can't initialize sensor record index %u",i);
+			return BMC_ERROR;
+		}
+		memcpy(pbase,p,sizeof(ubmc_sensor_s));
+		pbase++;
+	}
+	return BMC_OK;
+}
+
+
+int ubmc_sensor_addr_get(uint8_t sensornum,ubmc_sensor_s **paddr)
+{
+	struct ubmc_ipmi_dev* p_dev = &g_ubmc_ipmi_pdev;
+	ubmc_sensor_s *pbase = (ubmc_sensor_s *)p_dev->sensor_state_base;
+
+	if( !pbase ){
+		return BMC_ERROR;
+	}
+
+	*paddr = pbase + sensornum;
+	return BMC_OK;
+}
+
+
+static int ubmc_ipmi_dev_open(struct inode *inode,struct file *filp)
+{
+	filp->private_data = &g_ubmc_ipmi_pdev;
+	return 0;
+}
+
+
+static int ubmc_ipmi_dev_close(struct inode *inode,struct file *filp)
+{
+	filp->private_data = NULL;
+	return 0;
+}
+
+
+static int ubmc_ipmi_dev_mmap(struct file *filp, struct vm_area_struct *vma){
+	unsigned long phys;
+	struct ubmc_ipmi_dev *dev = (struct ubmc_ipmi_dev *)filp->private_data;
+
+	if( !dev ){
+		return -1;
+	}
+	phys = virt_to_phys(dev->sensor_state_base);
+	if(remap_pfn_range(vma,
+			vma->vm_start,
+			phys >> PAGE_SHIFT,
+			vma->vm_end - vma->vm_start,
+			vma->vm_page_prot))
+		return -1;
+
+	return 0;
+}
+
+#define IOCTL_INIT_SHM_DEVICE_TYPE_CMD 0X001
+
+#define IOCTL_ADD_SEL_NODE_CMD 0X100
+#define IOCTL_CLR_SEL_LIST_CMD 0X101
+#define IOCTL_SET_SEL_ENTRY_MAXNUM_CMD 0X102
+#define SEL_ENTRY_MAXNUM_DEFAULT 200
+
+//ipmi lan
+#define IOCTL_LAN_INIT_CMD	0X201
+#define IOCTL_LAN_UPDATE_CMD	0X202
+
+//check status command
+#define IOCTL_GET_STATUS_CMD	0X301
+#define IOCTL_GET_TIME_STATUS_CMD	0X302
+#define IOCTL_GET_SET_TIME_CMD	0X303
+
+static long ubmc_ipmi_dev_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+{
+
+	unsigned long ret = 0;
+
+	//printk("ioctl, cmd=0x%02x, arg=0x%02lx\n",cmd, arg);
+	struct ubmc_ipmi_sel_list sel_node;
+	struct ubmc_ipmi_dev *dev = (struct ubmc_ipmi_dev *)file->private_data;
+	switch (cmd)
+	{
+		case IOCTL_INIT_SHM_DEVICE_TYPE_CMD:
+		{
+			ubmc_device_type_t type;
+			ret = copy_from_user(&type,(unsigned long __user *)arg,sizeof(ubmc_device_type_t));
+			dev->device_type = type;
+			dev->sensor_state_base = kzalloc(PAGE_SIZE*2,GFP_KERNEL);
+			if ( !dev->sensor_state_base )
+				return -ENOMEM;
+			SetPageReserved(virt_to_page(dev->sensor_state_base));
+			//SetPageReserved(virt_to_page(dev->sensor_state_base) + 1);
+			// fill all the ubmc sensor states into the shared memory
+			if( umbc_ipmi_init_shm_sensor_fill_all(dev->device_type) == BMC_ERROR )
+			{
+				ubmc_error("Failed to fill ubmc sensor into shm\n");
+				return BMC_ERROR;
+			}
+			return 1;
+		}
+		case IOCTL_ADD_SEL_NODE_CMD:
+		{
+
+			ret = copy_from_user(&sel_node.event,(unsigned long __user *)arg,sizeof(struct sel_event_record));
+			if(sel_node.event.record_id > dev->ubmc_ipmi_sel_list.sel_entry_max_num)
+			{
+				sel_node.event.record_id = dev->ubmc_ipmi_sel_list.sel_entry_max_num;
+				ubmc_ipmi_del_then_add_node(&dev->ubmc_ipmi_sel_list,&sel_node);
+			}
+			else
+			{
+				ubmc_ipmi_add_sel_node(&dev->ubmc_ipmi_sel_list,&sel_node);
+			}
+
+			return 1;
+		}
+		case IOCTL_CLR_SEL_LIST_CMD:
+		{
+			ubmc_ipmi_sel_list_del(&dev->ubmc_ipmi_sel_list);
+			ubmc_ipmi_sel_list_init(&dev->ubmc_ipmi_sel_list,SEL_ENTRY_MAXNUM_DEFAULT);
+			return 1;
+		}
+		case IOCTL_SET_SEL_ENTRY_MAXNUM_CMD:
+		{
+			unsigned int maxnum;
+			ret = copy_from_user(&maxnum,(unsigned long __user *)arg,sizeof(unsigned int));
+			ubmc_ipmi_set_sel_maxnum(&dev->ubmc_ipmi_sel_list , maxnum);
+			return 1;
+		}
+		case IOCTL_LAN_INIT_CMD:
+		{
+			struct ubmc_ipmi_lan_s lan;
+			ret = copy_from_user(&lan,(unsigned long __user *)arg,sizeof(struct ubmc_ipmi_lan_s));
+			memcpy(&dev->ubmc_ipmi_lan,&lan,sizeof(struct ubmc_ipmi_lan_s));
+			//prt_lan_info(&dev->ubmc_ipmi_lan);
+			return 1;
+		}
+		case IOCTL_LAN_UPDATE_CMD:
+		{
+			struct ipmi_netinf netinf ;
+			ret = copy_from_user(&netinf,(unsigned long __user *)arg,sizeof(struct ipmi_netinf));
+			if(netinf.id == 1)
+			{
+				memcpy(&dev->ubmc_ipmi_lan.eth0,&netinf,sizeof(struct ipmi_netinf));
+				//prt_netinf_info(&dev->ubmc_ipmi_lan.eth0);
+			}
+			else if(netinf.id == 2)
+			{
+				memcpy(&dev->ubmc_ipmi_lan.eth1,&netinf,sizeof(struct ipmi_netinf));
+				//prt_netinf_info(&dev->ubmc_ipmi_lan.eth1);
+			}
+			else
+			{
+				return -ENXIO;
+			}
+			return 1;
+		}
+		case IOCTL_GET_STATUS_CMD:
+		{
+			//copy_to_user(void __user *to, const void *from, unsigned long n)
+			int status;
+			ret = copy_to_user((unsigned long __user *)arg,&dev->io_status,sizeof(int));
+			dev->io_status = 0; //clear the io status
+			return 1;
+		}
+		case IOCTL_GET_TIME_STATUS_CMD:
+		{
+			//copy_to_user(void __user *to, const void *from, unsigned long n)
+			int status;
+			ret = copy_to_user((unsigned long __user *)arg,&dev->io_status,sizeof(int));
+			dev->io_status = 0; //clear the io status
+			return 1;
+		}
+		case IOCTL_GET_SET_TIME_CMD:
+		{
+			//copy_to_user(void __user *to, const void *from, unsigned long n)
+			ret = copy_to_user((unsigned long __user *)arg,&dev->ipmi_time,sizeof(struct ubmc_ipmi_time));
+			dev->ipmi_time.tm_need_set = 0; //clear the io status
+			return 1;
+		}
+		default:
+			/* NOTE:  returning a fault code here could cause trouble
+			 * in buggy userspace code.  Some old kernel bugs returned
+			 * zero in this case, and userspace code might accidentally
+			 * have depended on that bug.
+			 */
+			return -ENOTTY;
+		}
+
+	return 0;
+}
+static struct file_operations ubmc_ipmi_fops = {
+	.owner = THIS_MODULE,
+	.unlocked_ioctl	= ubmc_ipmi_dev_ioctl,
+	.open = ubmc_ipmi_dev_open,
+	.release = ubmc_ipmi_dev_close,
+	.mmap = ubmc_ipmi_dev_mmap,
+};
+
+unsigned int ubmc_debug_enable = 0;
+module_param(ubmc_debug_enable, uint, S_IRUGO);
+MODULE_PARM_DESC(ubmc_debug_enable, "Ubmc debug switch (1 = default)");
+
+
+extern void init_mem(void );
+
+
+static int __init ubmc_ipmi_init(void)
+{
+	int rc = 0;
+	struct ubmc_ipmi_dev *p_dev = &g_ubmc_ipmi_pdev;
+
+	memset(p_dev, 0, sizeof(*p_dev));
+/*
+	p_dev->sensor_state_base = kzalloc(PAGE_SIZE,GFP_KERNEL);
+	if ( !p_dev->sensor_state_base )
+		return -ENOMEM;
+	SetPageReserved(virt_to_page(p_dev->sensor_state_base));
+
+	// fill all the ubmc sensor states into the shared memory
+	if( umbc_ipmi_init_shm_sensor_fill_all() == BMC_ERROR ){
+		ubmc_error("Failed to fill ubmc sensor into shm\n");
+		return BMC_ERROR;
+	}
+*/
+	rc = ubmc_i2c_slave_init();
+	if(rc!= 0)
+		return rc;
+
+	rc = register_chrdev(0, BMC_DEV_NAME, &ubmc_ipmi_fops);
+	if(rc < 0)
+	{
+		ubmc_error("Failed to register chrdev");
+		return rc;
+	}
+	p_dev->major = rc;
+
+	p_dev->ubmc_class = class_create(THIS_MODULE, BMC_DEV_NAME);
+	if(p_dev->ubmc_class < 0)
+	{
+		ubmc_error("Failed to register class %s", BMC_DEV_NAME);
+		return rc;
+	}
+
+	p_dev->ubmc_device = device_create(p_dev->ubmc_class, NULL, MKDEV(p_dev->major, 0),
+		NULL, BMC_DEV_NAME);
+	if(p_dev->ubmc_device ==NULL)
+	{
+		ubmc_error("Failed to register ubmc device");
+		return rc;
+	}
+	//root_umbc_dir = proc_mkdir("ubmc",NULL);
+	//init_ubmc_pinmux_proc(root_umbc_dir);
+	//init_ubmc_spi_reg(root_umbc_dir);
+	//for test
+	ubmc_ipmi_sel_list_init(&p_dev->ubmc_ipmi_sel_list ,SEL_ENTRY_MAXNUM_DEFAULT);
+	return 0;
+
+}
+
+static void __exit ubmc_ipmi_exit(void)
+{
+	struct ubmc_ipmi_dev* p_dev = &g_ubmc_ipmi_pdev;
+
+	ubmc_i2c_slave_deinit();
+
+	if(p_dev->major)
+		unregister_chrdev(p_dev->major, BMC_DEV_NAME);
+	if( p_dev->ubmc_device )
+		device_unregister(p_dev->ubmc_device);
+	if( p_dev->ubmc_class )
+		class_destroy(p_dev->ubmc_class);
+	ClearPageReserved(virt_to_page(p_dev->sensor_state_base));
+	if( p_dev->sensor_state_base )
+		kfree(p_dev->sensor_state_base);
+	
+	memset(p_dev, 0, sizeof(*p_dev));
+	//exit_ubmc_pinmux_proc(root_umbc_dir);
+	//exit_spi_reg(root_umbc_dir);
+	//remove_proc_entry("ubmc",NULL);
+
+}
+
+
+module_init(ubmc_ipmi_init);
+module_exit(ubmc_ipmi_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Silicom Ltd.");
+MODULE_DESCRIPTION("Silicom uBMC SSIF");
+MODULE_LICENSE("GPL");
+
--- linux-ti2018.02-rc4-int-orig/drivers/i2c/busses/ubmc-i2c-slave.c	1970-01-01 08:00:00.000000000 +0800
+++ linux-ti2018.02-rc4-int-silicom/drivers/i2c/busses/ubmc-i2c-slave.c	2020-03-09 10:47:12.013803576 +0800
@@ -0,0 +1,57 @@
+/*
+ * ubmc-i2c-slave.c
+ *
+ *  Created on: May 22, 2018
+ *      Author: jeff_zheng
+ */
+
+#include <linux/mm.h>
+#include <linux/i2c.h>
+#include <linux/init.h>
+#include <linux/list.h>
+#include <linux/mm_types.h>
+#include <linux/module.h>
+#include <linux/spinlock.h>
+#include <linux/sysfs.h>
+#include <linux/wait.h>
+#include <linux/slab.h>
+#include <linux/uaccess.h>
+#include <linux/mm_types.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/delay.h>
+#include "ubmc-i2c-ipmi.h"
+#include "ubmc-i2c-slave.h"
+
+
+struct ubmc_i2c_slave_dev g_ubmc_i2c_slave_dev;
+/*This should be a callback */
+int ubmc_i2c_slave_init(void)
+{
+	int rc;
+	struct ubmc_i2c_slave_dev* p_dev = &g_ubmc_i2c_slave_dev;
+	unsigned int isr;
+	memset(p_dev, 0, sizeof(*p_dev));
+#ifdef CONFIG_I2C_PXA_SLAVE
+	g_ubmc_i2c_slave_dev.ubmc_ipmi_i2c_init = ubmc_pxa_slave_init;
+	g_ubmc_i2c_slave_dev.ubmc_ipmi_i2c_deinit = ubmc_pxa_slave_deinit;
+#else
+	g_ubmc_i2c_slave_dev.ubmc_ipmi_i2c_init = ubmc_omap_slave_init;
+	g_ubmc_i2c_slave_dev.ubmc_ipmi_i2c_deinit = ubmc_omap_slave_deinit;
+#endif
+	rc = g_ubmc_i2c_slave_dev.ubmc_ipmi_i2c_init(p_dev);
+	if(rc)
+	{
+		ubmc_error("%s i2c slave init failed \n",p_dev->name);
+	}
+	return 0;
+}
+
+void ubmc_i2c_slave_deinit(void)
+{
+	struct ubmc_i2c_slave_dev* p_dev = &g_ubmc_i2c_slave_dev;
+
+	g_ubmc_i2c_slave_dev.ubmc_ipmi_i2c_deinit(p_dev);
+
+}
+
--- linux-ti2018.02-rc4-int-orig/drivers/i2c/busses/ubmc-i2c-slave.h	1970-01-01 08:00:00.000000000 +0800
+++ linux-ti2018.02-rc4-int-silicom/drivers/i2c/busses/ubmc-i2c-slave.h	2020-03-09 10:47:12.013803576 +0800
@@ -0,0 +1,61 @@
+/*
+ * ubmc-i2c-slave.h
+ *
+ *  Created on: May 24, 2018
+ *      Author: jeff_zheng
+ */
+
+#ifndef DRIVERS_I2C_BUSSES_UBMC_I2C_SLAVE_H_
+#define DRIVERS_I2C_BUSSES_UBMC_I2C_SLAVE_H_
+
+struct ubmc_i2c_slave_dev {
+	spinlock_t			lock;	    /* IRQ synchronization */
+	void __iomem*		base;		/* virtual */
+	void __iomem*		cm_per_base; /* Clock Module Registers virtual */
+	int					irq;
+//	uint8_t				threshold;
+	uint8_t				fifo_size;	/* use as flag and value
+									* fifo_size==0 implies no fifo
+									* if set, should be trsh+1
+									*/
+	uint16_t	rx_msg_idx;
+
+	uint8_t		tx_msg_idx;
+	uint16_t	tx_msg_len;
+	bool		tx_msg_ready;
+
+	uint8_t		rx_msg_buf[SSIF_RSP_BUF_SIZE+32];
+	uint8_t		tx_msg_buf[SSIF_RSP_BUF_SIZE+32];
+	uint8_t		name[32];
+	uint8_t 	slave_addr;
+/*for pxa register */
+	unsigned int		use_pio :1;
+	unsigned int		fast_mode :1;
+	unsigned int		high_mode:1;
+	void __iomem		*reg_base;
+	void __iomem		*reg_ibmr;
+	void __iomem		*reg_idbr;
+	void __iomem		*reg_icr;
+	void __iomem		*reg_isr;
+	void __iomem		*reg_isar;
+	void __iomem		*reg_rfth;
+	void __iomem		*reg_tfth;
+	void __iomem		*reg_ilcr;
+	void __iomem		*reg_iwcr;
+	uint32_t			fm_mask;
+	uint32_t			hs_mask;
+	/*callback function*/
+	int(*ubmc_ipmi_i2c_init)(void *dev);
+	void(* ubmc_ipmi_i2c_deinit)(void *dev);
+
+};
+
+int ubmc_i2c_slave_init(void);
+void ubmc_i2c_slave_deinit(void);
+
+int ubmc_pxa_slave_init(void *dev);
+int ubmc_omap_slave_init(void *dev);
+void ubmc_pxa_slave_deinit(void *dev);
+void ubmc_omap_slave_deinit(void *dev);
+
+#endif /* DRIVERS_I2C_BUSSES_UBMC_I2C_SLAVE_H_ */
--- linux-ti2018.02-rc4-int-orig/drivers/i2c/busses/Makefile	2018-07-15 00:46:29.000000000 +0800
+++ linux-ti2018.02-rc4-int-silicom/drivers/i2c/busses/Makefile	2020-03-09 10:47:12.013803576 +0800
@@ -76,7 +76,11 @@
 obj-$(CONFIG_I2C_MXS)		+= i2c-mxs.o
 obj-$(CONFIG_I2C_NOMADIK)	+= i2c-nomadik.o
 obj-$(CONFIG_I2C_OCORES)	+= i2c-ocores.o
-obj-$(CONFIG_I2C_OMAP)		+= i2c-omap.o
+#obj-$(CONFIG_I2C_OMAP)		+= i2c-omap.o
+obj-m						+= i2c-omap.o
+ubmc-ipmi-slave-objs := ubmc-ipmi.o ubmc-ssif.o ubmc-i2c-slave.o ubmc-ipmi-sel.o ubmc-ipmi-lan.o ubmc-ipmi-pxa.o ubmc-ipmi-omap.o
+obj-$(CONFIG_I2C_IPMI_UBMC)	+= ubmc-ipmi-slave.o ubmc-muxdump.o
+obj-$(CONFIG_I2C_OMAP)      += i2c-omap.o
 obj-$(CONFIG_I2C_PASEMI)	+= i2c-pasemi.o
 obj-$(CONFIG_I2C_PCA_PLATFORM)	+= i2c-pca-platform.o
 obj-$(CONFIG_I2C_PMCMSP)	+= i2c-pmcmsp.o
--- linux-ti2018.02-rc4-int-orig/drivers/i2c/busses/Kconfig	2018-07-15 00:46:29.000000000 +0800
+++ linux-ti2018.02-rc4-int-silicom/drivers/i2c/busses/Kconfig	2020-03-09 10:47:12.013803576 +0800
@@ -760,7 +760,7 @@
 config I2C_OMAP
 	tristate "OMAP I2C adapter"
 	depends on ARCH_OMAP || ARCH_K3
-	default y if MACH_OMAP_H3 || MACH_OMAP_OSK
+	default m if MACH_OMAP_H3 || MACH_OMAP_OSK
 	help
 	  If you say yes to this option, support will be included for the
 	  I2C interface on the Texas Instruments OMAP1/2 family of processors.
@@ -1326,4 +1326,12 @@
 	  This driver can also be built as a module. If so, the module will be
 	  called i2c-zx2967.
 
+config I2C_IPMI_UBMC
+	tristate "SILICOM IPMI UBMC for SILC"
+	depends on  I2C_OMAP || I2C_PXA
+	default m
+	help 
+		OMAP ubmc ipmi client
+		
+	
 endmenu
--- linux-ti2018.02-rc4-int-orig/drivers/i2c/busses/ubmc-i2c-ipmi.h	1970-01-01 08:00:00.000000000 +0800
+++ linux-ti2018.02-rc4-int-silicom/drivers/i2c/busses/ubmc-i2c-ipmi.h	2020-03-09 10:47:12.014803575 +0800
@@ -0,0 +1,950 @@
+#ifndef __I2C_OMAP_H__
+#define __I2C_OMAP_H__
+
+//#include <linux/platform_device.h>
+#include  "i2c-omap.h"
+#include "ubmc-ipmi-sdr.h"
+#include "ubmc-ipmi-sel.h"
+#include "ubmc-ipmi-lan.h"
+//#define I2C1_START_PHY_ADDR         0x4802a000
+#define I2C1_START_PHY_ADDR         0x4819c000
+
+#define OMAP_CM_PER_BASE            0x44E00000
+//#define CM_PER_I2C2_CLKCTRL         0x48
+#define CM_PER_I2C2_CLKCTRL         0x44
+
+#define OMAP_CM_PER_MEM_SIZE        0x400
+
+#define IORESOURCE_MEM_SIZE         0x1000
+//#define INT_OMAP_I2C_IRQ            163
+#define INT_OMAP_I2C_IRQ            29
+
+#define BMC_DEV_NAME                "bmc_drv"
+
+
+#define BMC_OK                       0
+#define BMC_ERROR                         -1
+
+#ifndef BMC_AGAIN
+#define BMC_AGAIN                         -2
+#endif
+
+
+#define SSIF_REQ_BUF_SIZE           (35)  /* cmd + length + 32 data bytes + PEC */
+#define SSIF_RSP_BUF_SIZE           (34) /* length + 32 data bytes + PEC */
+
+// the maximum number of the sensor
+#define IPMI_SDR_SERSOR_MAX(a)   (sizeof(a)/sizeof(*(a)))
+
+#if 0
+#define IPMI_SENSOR_HEADER_ELEMENT(sensor_name,sensor_type,sdr_next,sdr_id)  \
+	{ \
+		.name = sensor_name, \
+		.type = sensor_type, \
+		.sdr_header = {  \
+			.next = sdr_next, \
+			.id   = sdr_id,   \
+			.version = 0x51, \
+			.type = SDR_RECORD_TYPE_FULL_SENSOR, \
+			.length = 0x01, \
+		}, \
+		.sensor = {} \
+	}
+#endif
+
+// define the defalut threshods for three types sensor
+
+//#define UBMC_TEMP_SENSOR_DEFAUT_THRESHOLDS {0x00,0x00,0x00,0x55,0x5a,0x5a}
+//#define UBMC_VOL_SENSOR_DEFAUT_THRESHOLDS  {0x6c,0x64,0x61,0x8d,0x96,0x98}
+//#define UBMC_FAN_SENSOR_DEFAUT_THRESHOLDS  {0x07,0x05,0x03,0xfd,0xfe,0xff}
+
+/*
+#define UBMC_SENSOR_SEGMENT(sensor_name,sensor_type,sensor_num,sdr_next,sdr_id,sensor_thresholds)  \
+	{ \
+		.name = sensor_name, \
+		.type = sensor_type, \
+		.sensornum = sensor_num, \
+		.value = 0x00, \
+		.thresholds = sensor_thresholds, \
+		.sdr_header = {  \
+			.next = sdr_next, \
+			.id   = sdr_id,   \
+			.version = 0x51, \
+			.type = SDR_RECORD_TYPE_FULL_SENSOR, \
+			.length = 0x01, \
+		}, \
+		.sensor = {}, \
+		.__reserved = {},\
+	}
+*/
+#define UBMC_SENSOR_SEGMENT(sensor_name,sensor_type,sensor_num,sdr_next,sdr_id,sensor_thresholds,mask)  \
+	{ \
+		.name = sensor_name, \
+		.type = sensor_type, \
+		.sensornum = sensor_num, \
+		.value = 0x00, \
+		.thresholds = sensor_thresholds, \
+		.sdr_header = {  \
+			.next = sdr_next, \
+			.id   = sdr_id,   \
+			.version = 0x51, \
+			.type = SDR_RECORD_TYPE_FULL_SENSOR, \
+			.length = 0x01, \
+		}, \
+		.sensor = {}, \
+		.threshold_mask = mask,\
+		.__reserved = {},\
+	}
+
+/**
+(Name)             (Reading)    (Units)     (Status)(LNR)       (LCR)       (UCR)      (UNR)
+TEMP_HOST_CPU    | 41.000     | degrees C  | ok    | 0         | 4         | 87       | 91
+TEMP_HOST_PCB    | 37.000     | degrees C  | ok    | 0         | 4         | 87       | 91
+TEMP_INLET_AMB   | 28.000     | degrees C  | ok    | 0         | 4         | 40       | 44
+FAN1_TACH        | 5800.000   | RPM        | ok    | 800       | 1000      | 9000     | 10000
+FAN2_TACH        | 5400.000   | RPM        | ok    | 800       | 1000      | 9000     | 10000
+5V               | 4.960      | Volts      | ok    | 4.500     | na        | na       | 5.500
+3.3V             | 3.160      | Volts      | ok    | 2.756     | na        | na       | 3.845
+CPU_VCCSRAM      | 1.150      | Volts      | ok    | 0.750     | na        | na       | 1.200
+CPU_VCCP         | 1.150      | Volts      | ok    | 0.520     | na        | na       | 1.240
+1.05V            | 1.051      | Volts      | ok    | 1.024     | na        | na       | 1.076
+MEM_VDDQ         | 1.200      | Volts      | ok    | 1.162     | na        | na       | 1.260
+CPU_VNN          | 1.050      | Volts      | ok    | 0.650     | na        | na       | 1.240
+1.8V             | 1.800      | Volts      | ok    | 0.504     | na        | na       | 1.93
+*/
+
+#define UBMC_IPMI_N_A 0
+//TEMP_HOST_CPU limit
+#define TEMP_HOST_CPU_LNR 0
+#define TEMP_HOST_CPU_LCR 4
+#define TEMP_HOST_CPU_LNC UBMC_IPMI_N_A
+#define TEMP_HOST_CPU_UNC UBMC_IPMI_N_A
+#define TEMP_HOST_CPU_UCR 87
+#define TEMP_HOST_CPU_UNR 91
+
+//TEMP_HOST_PCB limit
+#define TEMP_HOST_PCB_LNR 0
+#define TEMP_HOST_PCB_LCR 4
+#define TEMP_HOST_PCB_LNC UBMC_IPMI_N_A
+#define TEMP_HOST_PCB_UNC UBMC_IPMI_N_A
+#define TEMP_HOST_PCB_UCR 87
+#define TEMP_HOST_PCB_UNR 91
+
+//TEMP_INLET_AMB limit
+#define TEMP_INLET_AMB_LNR 0
+#define TEMP_INLET_AMB_LCR 4
+#define TEMP_INLET_AMB_LNC UBMC_IPMI_N_A
+#define TEMP_INLET_AMB_UNC UBMC_IPMI_N_A
+#define TEMP_INLET_AMB_UCR 40
+#define TEMP_INLET_AMB_UNR 44
+
+//FAN1_TACH limit
+#define FAN1_TACH_LNR 8	//800
+#define FAN1_TACH_LCR 10	//1000
+#define FAN1_TACH_LNC UBMC_IPMI_N_A
+#define FAN1_TACH_UNC UBMC_IPMI_N_A
+#define FAN1_TACH_UCR 90	//9000
+#define FAN1_TACH_UNR 100	//10000
+
+//FAN2_TACH limit
+#define FAN2_TACH_LNR  8	//800
+#define FAN2_TACH_LCR 10	//1000
+#define FAN2_TACH_LNC UBMC_IPMI_N_A
+#define FAN2_TACH_UNC UBMC_IPMI_N_A
+#define FAN2_TACH_UCR 90	//9000
+#define FAN2_TACH_UNR 100	//10000
+
+
+
+//5V limit
+#define VOLT_5_0_LNR 90//45000
+#define VOLT_5_0_LCR UBMC_IPMI_N_A
+#define VOLT_5_0_LNC UBMC_IPMI_N_A
+#define VOLT_5_0_UNC UBMC_IPMI_N_A
+#define VOLT_5_0_UCR UBMC_IPMI_N_A
+#define VOLT_5_0_UNR 110
+
+//3.3V limit
+#define VOLT_3_3_LNR 91			//2.730
+#define VOLT_3_3_LCR UBMC_IPMI_N_A
+#define VOLT_3_3_LNC UBMC_IPMI_N_A
+#define VOLT_3_3_UNC UBMC_IPMI_N_A
+#define VOLT_3_3_UCR UBMC_IPMI_N_A
+#define VOLT_3_3_UNR 127		//3.845
+
+//CPUVCCSRAM limit
+#define VCCSRAM_LNR 50			//0.750
+#define VCCSRAM_LCR UBMC_IPMI_N_A
+#define VCCSRAM_LNC UBMC_IPMI_N_A
+#define VCCSRAM_UNC UBMC_IPMI_N_A
+#define VCCSRAM_UCR UBMC_IPMI_N_A
+#define VCCSRAM_UNR 80			//1.2
+
+//CPUVCCP limit
+#define VCCP_LNR 34			//0.52
+#define VCCP_LCR UBMC_IPMI_N_A
+#define VCCP_LNC UBMC_IPMI_N_A
+#define VCCP_UNC UBMC_IPMI_N_A
+#define VCCP_UCR UBMC_IPMI_N_A
+#define VCCP_UNR 82			//1.24
+
+//1.05V limit
+#define VOLT_1_0_5_LNR 68		//1.024
+#define VOLT_1_0_5_LCR UBMC_IPMI_N_A
+#define VOLT_1_0_5_LNC UBMC_IPMI_N_A
+#define VOLT_1_0_5_UNC UBMC_IPMI_N_A
+#define VOLT_1_0_5_UCR UBMC_IPMI_N_A
+#define VOLT_1_0_5_UNR 71		//1.067
+
+//1.8V limit
+#define VOLT_1_8_LNR 33		//0.504
+#define VOLT_1_8_LCR UBMC_IPMI_N_A
+#define VOLT_1_8_LNC UBMC_IPMI_N_A
+#define VOLT_1_8_UNC UBMC_IPMI_N_A
+#define VOLT_1_8_UCR UBMC_IPMI_N_A
+#define VOLT_1_8_UNR 127		//1.93
+
+//MEM_VDDQ limit
+#define MEM_VDDQ_LNR 77		//1.162
+#define MEM_VDDQ_LCR UBMC_IPMI_N_A
+#define MEM_VDDQ_LNC UBMC_IPMI_N_A
+#define MEM_VDDQ_UNC UBMC_IPMI_N_A
+#define MEM_VDDQ_UCR UBMC_IPMI_N_A
+#define MEM_VDDQ_UNR 84		//1.262
+
+//CPU VNN limit
+#define CPU_VNN_LNR 43		//0.65
+#define CPU_VNN_LCR UBMC_IPMI_N_A
+#define CPU_VNN_LNC UBMC_IPMI_N_A
+#define CPU_VNN_UNC UBMC_IPMI_N_A
+#define CPU_VNN_UCR UBMC_IPMI_N_A
+#define CPU_VNN_UNR 82		//1.24
+
+
+//for large
+
+//12V limit
+#define L_VOLT_12_LNR 108//
+#define L_VOLT_12_LCR UBMC_IPMI_N_A
+#define L_VOLT_12_LNC UBMC_IPMI_N_A
+#define L_VOLT_12_UNC UBMC_IPMI_N_A
+#define L_VOLT_12_UCR UBMC_IPMI_N_A
+#define L_VOLT_12_UNR 127
+
+//5V limit
+//resolution is 50mv
+#define L_VOLT_5_0_LNR 95//45000 4.5V
+#define L_VOLT_5_0_LCR UBMC_IPMI_N_A
+#define L_VOLT_5_0_LNC UBMC_IPMI_N_A
+#define L_VOLT_5_0_UNC UBMC_IPMI_N_A
+#define L_VOLT_5_0_UCR UBMC_IPMI_N_A
+#define L_VOLT_5_0_UNR 107	//55000 5.5V
+
+//2V limit
+//resolution is 15mv
+#define L_VOLT_1_5_LNR 96		//0.504
+#define L_VOLT_1_5_LCR UBMC_IPMI_N_A
+#define L_VOLT_1_5_LNC UBMC_IPMI_N_A
+#define L_VOLT_1_5_UNC UBMC_IPMI_N_A
+#define L_VOLT_1_5_UCR UBMC_IPMI_N_A
+#define L_VOLT_1_5_UNR 104		//1.93
+
+//3.3V ubmc limit
+//resolution is 30mv
+#define L_VOLT_3_3_LNR 98			//2.950
+#define L_VOLT_3_3_LCR UBMC_IPMI_N_A
+#define L_VOLT_3_3_LNC UBMC_IPMI_N_A
+#define L_VOLT_3_3_UNC UBMC_IPMI_N_A
+#define L_VOLT_3_3_UCR UBMC_IPMI_N_A
+#define L_VOLT_3_3_UNR 121		//3.630
+
+//main 3.3V IO board limit
+//resolution is 30mv
+#define L_VOLT2_3_3_LNR 100			//3.0v
+#define L_VOLT2_3_3_LCR UBMC_IPMI_N_A
+#define L_VOLT2_3_3_LNC UBMC_IPMI_N_A
+#define L_VOLT2_3_3_UNC UBMC_IPMI_N_A
+#define L_VOLT2_3_3_UCR UBMC_IPMI_N_A
+#define L_VOLT2_3_3_UNR 118		//3.55
+
+//1.0V limit
+//resolution is 15mv
+#define L_VOLT_1_0_LNR 64		//965
+#define L_VOLT_1_0_LCR UBMC_IPMI_N_A
+#define L_VOLT_1_0_LNC UBMC_IPMI_N_A
+#define L_VOLT_1_0_UNC UBMC_IPMI_N_A
+#define L_VOLT_1_0_UCR UBMC_IPMI_N_A
+#define L_VOLT_1_0_UNR 69		//1.035
+
+//1.8V limit
+//resolution is 15mv
+#define L_VOLT_1_8_LNR 115		//1.735
+#define L_VOLT_1_8_LCR UBMC_IPMI_N_A
+#define L_VOLT_1_8_LNC UBMC_IPMI_N_A
+#define L_VOLT_1_8_UNC UBMC_IPMI_N_A
+#define L_VOLT_1_8_UCR UBMC_IPMI_N_A
+#define L_VOLT_1_8_UNR 124		//1.865
+
+//1.35V limit
+//resolution is 15mv
+#define L_VOLT_1_35_LNR 85		//1.285
+#define L_VOLT_1_35_LCR UBMC_IPMI_N_A
+#define L_VOLT_1_35_LNC UBMC_IPMI_N_A
+#define L_VOLT_1_35_UNC UBMC_IPMI_N_A
+#define L_VOLT_1_35_UCR UBMC_IPMI_N_A
+#define L_VOLT_1_35_UNR 93		//1.395
+
+//VTT DDR3 limit
+//resolution is 15mv
+#define L_VOLT_VTT_DDR3_LNR 42		//0.630
+#define L_VOLT_VTT_DDR3_LCR UBMC_IPMI_N_A
+#define L_VOLT_VTT_DDR3_LNC UBMC_IPMI_N_A
+#define L_VOLT_VTT_DDR3_UNC UBMC_IPMI_N_A
+#define L_VOLT_VTT_DDR3_UCR UBMC_IPMI_N_A
+#define L_VOLT_VTT_DDR3_UNR 48		//0.725
+
+//1.1V limit
+//resolution is 15mv
+#define L_VOLT_1_1_LNR 70		//1.055
+#define L_VOLT_1_1_LCR UBMC_IPMI_N_A
+#define L_VOLT_1_1_LNC UBMC_IPMI_N_A
+#define L_VOLT_1_1_UNC UBMC_IPMI_N_A
+#define L_VOLT_1_1_UCR UBMC_IPMI_N_A
+#define L_VOLT_1_1_UNR 76		//1.145
+
+//54 limit
+//resolution is 50mv
+#define L_VOLT_54_LNR 103		//51.78
+#define L_VOLT_54_LCR UBMC_IPMI_N_A
+#define L_VOLT_54_LNC UBMC_IPMI_N_A
+#define L_VOLT_54_UNC UBMC_IPMI_N_A
+#define L_VOLT_54_UCR UBMC_IPMI_N_A
+#define L_VOLT_54_UNR 114		//57.23
+
+
+// define the defalut threshods for three types sensor
+#define UBMC_TEMP_HOST_CPU_THRESHOLDS \
+	{TEMP_HOST_CPU_LNR,TEMP_HOST_CPU_LCR,TEMP_HOST_CPU_LNC,TEMP_HOST_CPU_UNC,TEMP_HOST_CPU_UCR,TEMP_HOST_CPU_UNR}
+
+#define UBMC_TEMP_HOST_PCB_THRESHOLDS \
+	{TEMP_HOST_PCB_LNR,TEMP_HOST_PCB_LCR,TEMP_HOST_PCB_LNC,TEMP_HOST_PCB_UNC,TEMP_HOST_PCB_UCR,TEMP_HOST_PCB_UNR}
+
+#define UBMC_TEMP_INLET_AMB_THRESHOLDS \
+	{TEMP_INLET_AMB_LNR,TEMP_INLET_AMB_LCR,TEMP_INLET_AMB_LNC,TEMP_INLET_AMB_UNC,TEMP_INLET_AMB_UCR,TEMP_INLET_AMB_UNR}
+
+#define UBMC_FAN1_TACH_THRESHOLDS  \
+	{FAN1_TACH_LNR,FAN1_TACH_LCR,FAN1_TACH_LNC,FAN1_TACH_UNC,FAN1_TACH_UCR,FAN1_TACH_UNR}
+
+#define UBMC_FAN2_TACH_THRESHOLDS  \
+	{FAN2_TACH_LNR,FAN2_TACH_LCR,FAN2_TACH_LNC,FAN2_TACH_UNC,FAN2_TACH_UCR,FAN2_TACH_UNR}
+
+
+
+#define VOLT_5_0_THRESHOLDS  \
+	{VOLT_5_0_LNR,VOLT_5_0_LCR,VOLT_5_0_LNC,VOLT_5_0_UNC,VOLT_5_0_UCR,VOLT_5_0_UNR}
+
+#define VOLT_3_3_THRESHOLDS  \
+	{VOLT_3_3_LNR,VOLT_3_3_LCR,VOLT_3_3_LNC,VOLT_3_3_UNC,VOLT_3_3_UCR,VOLT_3_3_UNR}
+
+#define VCCSRAM_THRESHOLDS  \
+	{VCCSRAM_LNR,VCCSRAM_LCR,VCCSRAM_LNC,VCCSRAM_UNC,VCCSRAM_UCR,VCCSRAM_UNR}
+
+#define VCCP_THRESHOLDS  \
+	{VCCP_LNR,VCCP_LCR,VCCP_LNC,VCCP_UNC,VCCP_UCR,VCCP_UNR}
+
+#define VOLT_1_0_5_THRESHOLDS  \
+	{VOLT_1_0_5_LNR,VOLT_1_0_5_LCR,VOLT_1_0_5_LNC,VOLT_1_0_5_UNC,VOLT_1_0_5_UCR,VOLT_1_0_5_UNR}
+
+#define VOLT_1_8_THRESHOLDS  \
+	{VOLT_1_8_LNR,VOLT_1_8_LCR,VOLT_1_8_LNC,VOLT_1_8_UNC,VOLT_1_8_UCR,VOLT_1_8_UNR}
+
+#define MEM_VDDQ_THRESHOLDS  \
+	{MEM_VDDQ_LNR,MEM_VDDQ_LCR,MEM_VDDQ_LNC,MEM_VDDQ_UNC,MEM_VDDQ_UCR,MEM_VDDQ_UNR}
+
+#define CPU_VNN_THRESHOLDS  \
+	{CPU_VNN_LNR,CPU_VNN_LCR,CPU_VNN_LNC,CPU_VNN_UNC,CPU_VNN_UCR,CPU_VNN_UNR}
+
+
+//for large thresholds list
+#define L_VOLT_12_THRESHOLDS  \
+	{L_VOLT_12_LNR,L_VOLT_12_LCR,L_VOLT_12_LNC,L_VOLT_12_UNC,L_VOLT_12_UCR,L_VOLT_12_UNR}
+#define L_VOLT_5_0_THRESHOLDS  \
+	{L_VOLT_5_0_LNR,L_VOLT_5_0_LCR,L_VOLT_5_0_LNC,L_VOLT_5_0_UNC,L_VOLT_5_0_UCR,L_VOLT_5_0_UNR}
+#define L_VOLT_1_5_THRESHOLDS  \
+	{L_VOLT_1_5_LNR,L_VOLT_1_5_LCR,L_VOLT_1_5_LNC,L_VOLT_1_5_UNC,L_VOLT_1_5_UCR,L_VOLT_1_5_UNR}
+#define L_VOLT_3_3_THRESHOLDS  \
+	{L_VOLT_3_3_LNR,L_VOLT_3_3_LCR,L_VOLT_3_3_LNC,L_VOLT_3_3_UNC,L_VOLT_3_3_UCR,L_VOLT_3_3_UNR}
+#define L_VOLT2_3_3_THRESHOLDS  \
+	{L_VOLT2_3_3_LNR,L_VOLT2_3_3_LCR,L_VOLT2_3_3_LNC,L_VOLT2_3_3_UNC,L_VOLT2_3_3_UCR,L_VOLT2_3_3_UNR}
+#define L_VOLT_1_0_THRESHOLDS  \
+	{L_VOLT_1_0_LNR,L_VOLT_1_0_LCR,L_VOLT_1_0_LNC,L_VOLT_1_0_UNC,L_VOLT_1_0_UCR,L_VOLT_1_0_UNR}
+#define L_VOLT_1_8_THRESHOLDS  \
+	{L_VOLT_1_8_LNR,L_VOLT_1_8_LCR,L_VOLT_1_8_LNC,L_VOLT_1_8_UNC,L_VOLT_1_8_UCR,L_VOLT_1_8_UNR}
+#define L_VOLT_1_35_THRESHOLDS  \
+	{L_VOLT_1_35_LNR,L_VOLT_1_35_LCR,L_VOLT_1_35_LNC,L_VOLT_1_35_UNC,L_VOLT_1_35_UCR,L_VOLT_1_35_UNR}
+#define L_VOLT_VTT_DDR3_THRESHOLDS  \
+	{L_VOLT_VTT_DDR3_LNR,L_VOLT_VTT_DDR3_LCR,L_VOLT_VTT_DDR3_LNC,L_VOLT_VTT_DDR3_UNC,L_VOLT_VTT_DDR3_UCR,L_VOLT_VTT_DDR3_UNR}
+#define L_VOLT_1_1_THRESHOLDS  \
+	{L_VOLT_1_1_LNR,L_VOLT_1_1_LCR,L_VOLT_1_1_LNC,L_VOLT_1_1_UNC,L_VOLT_1_1_UCR,L_VOLT_1_1_UNR}
+
+#define L_VOLT_54_THRESHOLDS  \
+	{L_VOLT_54_LNR,L_VOLT_54_LCR,L_VOLT_54_LNC,L_VOLT_54_UNC,L_VOLT_54_UCR,L_VOLT_54_UNR}
+#define UBMC_TEMP_SENSOR_DEFAUT_THRESHOLDS {0x00,0x00,0x00,0x55,0x5a,0x5a}
+#define UBMC_VOL_SENSOR_DEFAUT_THRESHOLDS  {0x6c,0x64,0x61,0x8d,0x96,0x98}
+#define UBMC_FAN_SENSOR_DEFAUT_THRESHOLDS  {0x07,0x05,0x03,0xfd,0xfe,0xff}
+
+
+
+
+// the follow two segments are use to calculate the sensor value by 'ipmitool sdr'
+// Because the sensor value has only one byte.
+// The details of the calculation can be seen in ipmitool.tar.gz
+/* M, tolerance */
+#define UBMC_TEMP_SENSOR_DEFAUT_MTOL      0x0001
+/* accuracy, B, Bexp, Rexp */
+#define UBMC_TEMP_SENSOR_DEFAUT_BACC      0x00000000
+
+/* M, tolerance */
+#define UBMC_FAN_SENSOR_DEFAUT_MTOL        0x0064
+/* accuracy, B, Bexp, Rexp */
+#define UBMC_FAN_SENSOR_DEFAUT_BACC        0x00000000
+
+
+/* M, tolerance */
+#define UBMC_VOL_SENSOR_DEFAUT_MTOL         0x64//0x0039
+/* accuracy, B, Bexp, Rexp */
+#define UBMC_VOL_SENSOR_DEFAUT_BACC         0xd0000000//0xd000005b
+
+
+
+#ifdef I2C_DUP
+/*
+ * Version 2 of the I2C peripheral unit has a different register
+ * layout and extra registers.  The ID register in the V2 peripheral
+ * unit on the OMAP4430 reports the same ID as the V1 peripheral
+ * unit on the OMAP3530, so we must inform the driver which IP
+ * version we know it is running on from platform / cpu-specific
+ * code using these constants in the hwmod class definition.
+ */
+
+#define OMAP_I2C_IP_VERSION_1 1
+#define OMAP_I2C_IP_VERSION_2 2
+
+/* struct omap_i2c_bus_platform_data .flags meanings */
+
+#define OMAP_I2C_FLAG_NO_FIFO			BIT(0)
+#define OMAP_I2C_FLAG_SIMPLE_CLOCK		BIT(1)
+#define OMAP_I2C_FLAG_16BIT_DATA_REG		BIT(2)
+#define OMAP_I2C_FLAG_ALWAYS_ARMXOR_CLK	BIT(5)
+#define OMAP_I2C_FLAG_FORCE_19200_INT_CLK	BIT(6)
+/* how the CPU address bus must be translated for I2C unit access */
+#define OMAP_I2C_FLAG_BUS_SHIFT_NONE 0
+#define OMAP_I2C_FLAG_BUS_SHIFT_1		BIT(7)
+#define OMAP_I2C_FLAG_BUS_SHIFT_2		BIT(8)
+#define OMAP_I2C_FLAG_BUS_SHIFT__SHIFT 7
+
+
+#define SLAVE_ARDY_ACK_FLAGS (OMAP_I2C_STAT_ARDY | OMAP_I2C_STAT_BF | \
+			      OMAP_I2C_STAT_NACK | OMAP_I2C_STAT_AL)
+/* I2C Interrupt Enable Register (OMAP_I2C_IE): */
+#define OMAP_I2C_IE_XDR		(1 << 14)	/* TX Buffer drain int enable */
+#define OMAP_I2C_IE_RDR		(1 << 13)	/* RX Buffer drain int enable */
+#define OMAP_I2C_IE_BB		(1 << 12)	/* Bus busy int enable */
+#define OMAP_I2C_IE_ROVR	(1 << 11)	/* Receive overrun int enable */
+#define OMAP_I2C_IE_XUDF	(1 << 10)	/* Transmit underflow int enable */
+#define OMAP_I2C_IE_AAS		(1 << 9)	/* Address as slave int enable */
+#define OMAP_I2C_IE_BF		(1 << 8)	/* Bus free int enable */
+#define OMAP_I2C_IE_AERR	(1 << 7)	/* Access error int enable */
+#define OMAP_I2C_IE_STC		(1 << 6)	/* Start int enable */
+#define OMAP_I2C_IE_GC		(1 << 5)	/* General call int enable */
+#define OMAP_I2C_IE_XRDY	(1 << 4)	/* TX data ready int enable */
+#define OMAP_I2C_IE_RRDY	(1 << 3)	/* RX data ready int enable */
+#define OMAP_I2C_IE_ARDY	(1 << 2)	/* Access ready int enable */
+#define OMAP_I2C_IE_NACK	(1 << 1)	/* No ack interrupt enable */
+#define OMAP_I2C_IE_AL		(1 << 0)	/* Arbitration lost int ena */
+
+/* I2C Status Register (OMAP_I2C_STAT): */
+#define OMAP_I2C_STAT_XDR	(1 << 14)	/* TX Buffer draining */
+#define OMAP_I2C_STAT_RDR	(1 << 13)	/* RX Buffer draining */
+#define OMAP_I2C_STAT_BB	(1 << 12)	/* Bus busy */
+#define OMAP_I2C_STAT_ROVR	(1 << 11)	/* Receive overrun */
+#define OMAP_I2C_STAT_XUDF	(1 << 10)	/* Transmit underflow */
+#define OMAP_I2C_STAT_AAS	(1 << 9)	/* Address as slave */
+#define OMAP_I2C_STAT_BF	(1 << 8)	/* Bus Free */
+#define OMAP_I2C_STAT_XRDY	(1 << 4)	/* Transmit data ready */
+#define OMAP_I2C_STAT_RRDY	(1 << 3)	/* Receive data ready */
+#define OMAP_I2C_STAT_ARDY	(1 << 2)	/* Register access ready */
+#define OMAP_I2C_STAT_NACK	(1 << 1)	/* No ack interrupt enable */
+#define OMAP_I2C_STAT_AL	(1 << 0)	/* Arbitration lost int ena */
+
+/* I2C WE wakeup enable register */
+#define OMAP_I2C_WE_XDR_WE	(1 << 14)	/* TX drain wakup */
+#define OMAP_I2C_WE_RDR_WE	(1 << 13)	/* RX drain wakeup */
+#define OMAP_I2C_WE_AAS_WE	(1 << 9)	/* Address as slave wakeup*/
+#define OMAP_I2C_WE_BF_WE	(1 << 8)	/* Bus free wakeup */
+#define OMAP_I2C_WE_STC_WE	(1 << 6)	/* Start condition wakeup */
+#define OMAP_I2C_WE_GC_WE	(1 << 5)	/* General call wakeup */
+#define OMAP_I2C_WE_DRDY_WE	(1 << 3)	/* TX/RX data ready wakeup */
+#define OMAP_I2C_WE_ARDY_WE	(1 << 2)	/* Reg access ready wakeup */
+#define OMAP_I2C_WE_NACK_WE	(1 << 1)	/* No acknowledgment wakeup */
+#define OMAP_I2C_WE_AL_WE	(1 << 0)	/* Arbitration lost wakeup */
+
+#define OMAP_I2C_WE_ALL		(OMAP_I2C_WE_XDR_WE | OMAP_I2C_WE_RDR_WE | \
+				OMAP_I2C_WE_AAS_WE | OMAP_I2C_WE_BF_WE | \
+				OMAP_I2C_WE_STC_WE | OMAP_I2C_WE_GC_WE | \
+				OMAP_I2C_WE_DRDY_WE | OMAP_I2C_WE_ARDY_WE | \
+				OMAP_I2C_WE_NACK_WE | OMAP_I2C_WE_AL_WE)
+
+/* I2C Buffer Configuration Register (OMAP_I2C_BUF): */
+#define OMAP_I2C_BUF_RDMA_EN	(1 << 15)	/* RX DMA channel enable */
+#define OMAP_I2C_BUF_RXFIF_CLR	(1 << 14)	/* RX FIFO Clear */
+#define OMAP_I2C_BUF_XDMA_EN	(1 << 7)	/* TX DMA channel enable */
+#define OMAP_I2C_BUF_TXFIF_CLR	(1 << 6)	/* TX FIFO Clear */
+
+/* I2C Configuration Register (OMAP_I2C_CON): */
+#define OMAP_I2C_CON_EN		(1 << 15)	/* I2C module enable */
+#define OMAP_I2C_CON_BE		(1 << 14)	/* Big endian mode */
+#define OMAP_I2C_CON_OPMODE_HS	(1 << 12)	/* High Speed support */
+#define OMAP_I2C_CON_STB	(1 << 11)	/* Start byte mode (master) */
+#define OMAP_I2C_CON_MST	(1 << 10)	/* Master/slave mode */
+#define OMAP_I2C_CON_TRX	(1 << 9)	/* TX/RX mode (master only) */
+#define OMAP_I2C_CON_XA		(1 << 8)	/* Expand address */
+#define OMAP_I2C_CON_RM		(1 << 2)	/* Repeat mode (master only) */
+#define OMAP_I2C_CON_STP	(1 << 1)	/* Stop cond (master only) */
+#define OMAP_I2C_CON_STT	(1 << 0)	/* Start condition (master) */
+
+
+/* I2C System Test Register (OMAP_I2C_SYSTEST): */
+#define OMAP_I2C_SYSTEST_ST_EN		(1 << 15)	/* System test enable */
+#define OMAP_I2C_SYSTEST_FREE		(1 << 14)	/* Free running mode */
+#define OMAP_I2C_SYSTEST_TMODE_MASK	(3 << 12)	/* Test mode select */
+#define OMAP_I2C_SYSTEST_TMODE_SHIFT	(12)		/* Test mode select */
+
+
+#endif
+#define OMAP_I2C_SYST_RESET      (1 << 2)
+
+#define IPMI_GET_SYSTEM_INTERFACE_CAPABILITIES_CMD	0x57
+
+#define	SSIF_IPMI_REQUEST			2
+#define	SSIF_IPMI_MULTI_PART_REQUEST_START	6
+#define	SSIF_IPMI_MULTI_PART_REQUEST_MIDDLE	7
+#define	SSIF_IPMI_RESPONSE			3
+#define	SSIF_IPMI_MULTI_PART_RESPONSE_MIDDLE	9
+
+
+#define SSIF_IPMI_DEVICE_ID                    0x01
+#define SSIF_IPMI_DEVICE_REVISION              0x81
+#define SSIF_IPMI_FIRMWARE_REVISION1           0x01
+#define SSIF_IPMI_FIRMWARE_REVISION2           0x02
+#define SSIF_IPMI_IPMI_VERSION                 0x02
+#define SSIF_IPMI_ADDITIONAL_DEVICE_SUPPORT    0x01
+#define SSIF_IPMI_MANUFACTURER_ID              0x010203
+#define SSIF_IPMI_PRODUCT_ID                   0x0304
+#define SSIF_IPMI_AUX_FIRMWARE_REVISION        0x01
+#define SSIF_IPMI_AUX_FIRMWARE_REVISION_SET    0x02
+
+
+#define SSIF_IPMI_SUPPORT_PEC                  (0x1 << 3)
+// to add support SSIF_MULTI_2_PART
+#define SSIF_IPMI_MULTI_SUPPORT                (0x03 << 6)
+#define SSIF_NO_MULTI               			(0x00 << 6)
+#define SSIF_IPMI_MAX_XMIT_MSG_SIZE            0x40
+#define SSIF_IPMI_MAX_RECV_MSG_SIZE            0x40
+
+
+// for IPMI_GET_CHANNEL_INFO_CMD
+#define SSIF_IPMI_CHANNEL_MEDIUM_LAN		0x4
+#define SSIF_IPMI_CHANNEL_SESSION_SUPPORT      0x40
+#define SSIF_IPMI_CHANNEL_ACTIVE_SESSIONS      0x01
+
+#define SSIF_IPMI_CHANNEL_VENDOR_ID            0x010203
+#define SSIF_IPMI_CHANNEL_AUX_INFO             0x0203
+
+
+/**********************************************************/
+/**
+ * copy from ipmitool-1.8.16.tar.gz
+ */
+
+#define IPMI_NETFN_PICMG		0x2C
+
+/* PICMG version */
+#define PICMG_CPCI_MAJOR_VERSION                   1
+#define PICMG_ATCA_MAJOR_VERSION                   2
+#define PICMG_AMC_MAJOR_VERSION                    4
+
+/* PICMG commands */
+#define PICMG_GET_PICMG_PROPERTIES_CMD             0x00
+#define PICMG_GET_ADDRESS_INFO_CMD                 0x01
+#define PICMG_GET_SHELF_ADDRESS_INFO_CMD           0x02
+#define PICMG_SET_SHELF_ADDRESS_INFO_CMD           0x03
+#define PICMG_FRU_CONTROL_CMD                      0x04
+#define PICMG_GET_FRU_LED_PROPERTIES_CMD           0x05
+#define PICMG_GET_LED_COLOR_CAPABILITIES_CMD       0x06
+#define PICMG_SET_FRU_LED_STATE_CMD                0x07
+#define PICMG_GET_FRU_LED_STATE_CMD                0x08
+#define PICMG_SET_IPMB_CMD                         0x09
+#define PICMG_SET_FRU_POLICY_CMD                   0x0A
+#define PICMG_GET_FRU_POLICY_CMD                   0x0B
+#define PICMG_FRU_ACTIVATION_CMD                   0x0C
+#define PICMG_GET_DEVICE_LOCATOR_RECORD_CMD        0x0D
+#define PICMG_SET_PORT_STATE_CMD                   0x0E
+#define PICMG_GET_PORT_STATE_CMD                   0x0F
+#define PICMG_COMPUTE_POWER_PROPERTIES_CMD         0x10
+#define PICMG_SET_POWER_LEVEL_CMD                  0x11
+#define PICMG_GET_POWER_LEVEL_CMD                  0x12
+#define PICMG_RENEGOTIATE_POWER_CMD                0x13
+#define PICMG_GET_FAN_SPEED_PROPERTIES_CMD         0x14
+#define PICMG_SET_FAN_LEVEL_CMD                    0x15
+#define PICMG_GET_FAN_LEVEL_CMD                    0x16
+#define PICMG_BUSED_RESOURCE_CMD                   0x17
+
+
+
+/******************************************************************************/
+// copy from ipmi_constants.h of the ipmitool tarball
+/******************************************************************************/
+
+#define IPMI_SESSION_AUTHTYPE_NONE      0x0
+#define IPMI_SESSION_AUTHTYPE_MD2       0x1
+#define IPMI_SESSION_AUTHTYPE_MD5   	0x2
+#define IPMI_SESSION_AUTHTYPE_KEY	0x4
+#define IPMI_SESSION_AUTHTYPE_PASSWORD	IPMI_SESSION_AUTHTYPE_KEY
+#define IPMI_SESSION_AUTHTYPE_OEM       0x5
+#define IPMI_SESSION_AUTHTYPE_RMCP_PLUS 0x6
+
+
+/******************************************************************************/
+// copy from ipmi_msgdefs.h
+/******************************************************************************/
+/* NetFNs and commands used inside the IPMI stack. */
+
+#define IPMI_NETFN_SENSOR_EVENT_REQUEST		0x04
+#define IPMI_NETFN_SENSOR_EVENT_RESPONSE	0x05
+#define IPMI_GET_EVENT_RECEIVER_CMD	0x01
+
+#define IPMI_NETFN_APP_REQUEST			0x06
+#define IPMI_NETFN_APP_RESPONSE			0x07
+#define IPMI_GET_DEVICE_ID_CMD		0x01
+#define IPMI_COLD_RESET_CMD		0x02
+#define IPMI_WARM_RESET_CMD		0x03
+#define IPMI_CLEAR_MSG_FLAGS_CMD	0x30
+#define IPMI_GET_DEVICE_GUID_CMD	0x08
+#define IPMI_GET_MSG_FLAGS_CMD		0x31
+#define IPMI_SEND_MSG_CMD		0x34
+#define IPMI_GET_MSG_CMD		0x33
+#define IPMI_SET_BMC_GLOBAL_ENABLES_CMD	0x2e
+#define IPMI_GET_BMC_GLOBAL_ENABLES_CMD	0x2f
+#define IPMI_READ_EVENT_MSG_BUFFER_CMD	0x35
+#define IPMI_GET_CHANNEL_INFO_CMD	0x42
+
+
+/* Bit for BMC global enables. */
+#define IPMI_BMC_RCV_MSG_INTR     0x01
+#define IPMI_BMC_EVT_MSG_INTR     0x02
+#define IPMI_BMC_EVT_MSG_BUFF     0x04
+#define IPMI_BMC_SYS_LOG          0x08
+
+#define IPMI_NETFN_STORAGE_REQUEST		0x0a
+#define IPMI_NETFN_STORAGE_RESPONSE		0x0b
+#define IPMI_ADD_SEL_ENTRY_CMD		0x44
+
+#define IPMI_NETFN_FIRMWARE_REQUEST		0x08
+#define IPMI_NETFN_FIRMWARE_RESPONSE		0x09
+
+/* The default slave address */
+#define IPMI_BMC_SLAVE_ADDR	0x20
+
+/* The BT interface on high-end HP systems supports up to 255 bytes in
+ * one transfer.  Its "virtual" BMC supports some commands that are longer
+ * than 128 bytes.  Use the full 256, plus NetFn/LUN, Cmd, cCode, plus
+ * some overhead; it's not worth the effort to dynamically size this based
+ * on the results of the "Get BT Capabilities" command. */
+#define IPMI_MAX_MSG_LENGTH	272	/* multiple of 16 */
+
+#define IPMI_CC_NO_ERROR		0x00
+#define IPMI_NODE_BUSY_ERR		0xc0
+#define IPMI_INVALID_COMMAND_ERR	0xc1
+#define IPMI_TIMEOUT_ERR		0xc3
+#define IPMI_ERR_MSG_TRUNCATED		0xc6
+#define IPMI_REQ_LEN_INVALID_ERR	0xc7
+#define IPMI_REQ_LEN_EXCEEDED_ERR	0xc8
+#define IPMI_REQ_LEN_EXCEED_NUM_BYTES	0xcA
+#define IPMI_NOT_IN_MY_STATE_ERR	0xd5	/* IPMI 2.0 */
+#define IPMI_LOST_ARBITRATION_ERR	0x81
+#define IPMI_BUS_ERR			0x82
+#define IPMI_NAK_ON_WRITE_ERR		0x83
+#define IPMI_ERR_UNSPECIFIED		0xff
+
+#define IPMI_CHANNEL_PROTOCOL_IPMB	1
+#define IPMI_CHANNEL_PROTOCOL_ICMB	2
+#define IPMI_CHANNEL_PROTOCOL_SMBUS	4
+#define IPMI_CHANNEL_PROTOCOL_KCS	5
+#define IPMI_CHANNEL_PROTOCOL_SMIC	6
+#define IPMI_CHANNEL_PROTOCOL_BT10	7
+#define IPMI_CHANNEL_PROTOCOL_BT15	8
+#define IPMI_CHANNEL_PROTOCOL_TMODE	9
+
+#define IPMI_CHANNEL_MEDIUM_IPMB	1
+#define IPMI_CHANNEL_MEDIUM_ICMB10	2
+#define IPMI_CHANNEL_MEDIUM_ICMB09	3
+#define IPMI_CHANNEL_MEDIUM_8023LAN	4
+#define IPMI_CHANNEL_MEDIUM_ASYNC	5
+#define IPMI_CHANNEL_MEDIUM_OTHER_LAN	6
+#define IPMI_CHANNEL_MEDIUM_PCI_SMBUS	7
+#define IPMI_CHANNEL_MEDIUM_SMBUS1	8
+#define IPMI_CHANNEL_MEDIUM_SMBUS2	9
+#define IPMI_CHANNEL_MEDIUM_USB1	10
+#define IPMI_CHANNEL_MEDIUM_USB2	11
+#define IPMI_CHANNEL_MEDIUM_SYSINTF	12
+#define IPMI_CHANNEL_MEDIUM_OEM_MIN	0x60
+#define IPMI_CHANNEL_MEDIUM_OEM_MAX	0x7f
+
+/**********************************************************************************/
+// copy from ipmi.h of the ipmitool tarball
+/**********************************************************************************/
+
+#define IPMI_NETFN_CHASSIS		0x0
+#define IPMI_NETFN_BRIDGE		0x2
+#define IPMI_NETFN_SE			0x4
+#define IPMI_NETFN_APP			0x6
+#define IPMI_NETFN_FIRMWARE		0x8
+#define IPMI_NETFN_STORAGE		0xa
+#define IPMI_NETFN_TRANSPORT	0xc
+#define IPMI_NETFN_PICMG		0x2C
+#define IPMI_NETFN_DCGRP		0x2C
+#define IPMI_NETFN_OEM		0x2E
+#define IPMI_NETFN_ISOL			0x34
+#define IPMI_NETFN_TSOL			0x30
+
+#define IPMI_BMC_SLAVE_ADDR		0x20
+#define IPMI_REMOTE_SWID		0x81
+
+/**********************************************************************************/
+// copy from the ipmi_lanp.h of the ipmitool-1.8.16.tar.gz
+/**********************************************************************************/
+
+#define IPMI_NETFN_TRANSPORT	                   0xc
+#define IPMI_LAN_GET_CONFIG_CMD                    0x02
+
+enum {
+	IPMI_LANP_SET_IN_PROGRESS,
+	IPMI_LANP_AUTH_TYPE,
+	IPMI_LANP_AUTH_TYPE_ENABLE,
+	IPMI_LANP_IP_ADDR,
+	IPMI_LANP_IP_ADDR_SRC,
+	IPMI_LANP_MAC_ADDR,            /* 5 */
+	IPMI_LANP_SUBNET_MASK,
+	IPMI_LANP_IP_HEADER,
+	IPMI_LANP_PRI_RMCP_PORT,
+	IPMI_LANP_SEC_RMCP_PORT,
+	IPMI_LANP_BMC_ARP,             /* 10 */
+	IPMI_LANP_GRAT_ARP,
+	IPMI_LANP_DEF_GATEWAY_IP,
+	IPMI_LANP_DEF_GATEWAY_MAC,
+	IPMI_LANP_BAK_GATEWAY_IP,
+	IPMI_LANP_BAK_GATEWAY_MAC,     /* 15 */
+	IPMI_LANP_SNMP_STRING,
+	IPMI_LANP_NUM_DEST,
+	IPMI_LANP_DEST_TYPE,
+	IPMI_LANP_DEST_ADDR,
+	IPMI_LANP_VLAN_ID,             /* 20 */
+	IPMI_LANP_VLAN_PRIORITY,
+	IPMI_LANP_RMCP_CIPHER_SUPPORT,
+	IPMI_LANP_RMCP_CIPHERS,
+	IPMI_LANP_RMCP_PRIV_LEVELS,
+	IPMI_LANP_VLAN_TAGS,
+	IPMI_LANP_BAD_PASS_THRESH,
+	IPMI_LANP_OEM_ALERT_STRING=96,
+	IPMI_LANP_ALERT_RETRY=97,
+	IPMI_LANP_UTC_OFFSET=98,
+	IPMI_LANP_DHCP_SERVER_IP=192,
+	IPMI_LANP_DHCP_SERVER_MAC=193,
+	IPMI_LANP_DHCP_ENABLE=194,
+	IPMI_LANP_CHAN_ACCESS_MODE=201,
+};
+#ifdef I2C_DUP
+/* For OMAP3 I2C_IV has changed to I2C_WE (wakeup enable) */
+enum {
+	OMAP_I2C_REV_REG = 0,
+	OMAP_I2C_IE_REG,
+	OMAP_I2C_STAT_REG,
+	OMAP_I2C_IV_REG,
+	OMAP_I2C_WE_REG,
+	OMAP_I2C_SYSS_REG,
+	OMAP_I2C_BUF_REG,
+	OMAP_I2C_CNT_REG,
+	OMAP_I2C_DATA_REG,
+	OMAP_I2C_SYSC_REG,
+	OMAP_I2C_CON_REG,
+	OMAP_I2C_OA_REG,
+	OMAP_I2C_SA_REG,
+	OMAP_I2C_PSC_REG,
+	OMAP_I2C_SCLL_REG,
+	OMAP_I2C_SCLH_REG,
+	OMAP_I2C_SYSTEST_REG,
+	OMAP_I2C_BUFSTAT_REG,
+	/* only on OMAP4430 */
+	OMAP_I2C_IP_V2_REVNB_LO,
+	OMAP_I2C_IP_V2_REVNB_HI,
+	OMAP_I2C_IP_V2_IRQSTATUS_RAW,
+	OMAP_I2C_IP_V2_IRQENABLE_SET,
+	OMAP_I2C_IP_V2_IRQENABLE_CLR,
+};
+#endif
+
+typedef struct sdr_get_rs sdr_get_rs;
+
+typedef struct sdr_record_full_sensor sdr_record_full_sensor;
+
+// define the current three primary sensor type
+typedef enum {
+	UBMC_SENSOR_UNKNOWN ,   //  unknown
+	UBMC_SENSOR_TEMP ,      //  temperature
+	UBMC_SENSOR_VOL  ,      //  voltage
+	UBMC_SENSOR_FAN  ,      //  fan
+} ipmi_sensor_type;
+
+
+#if 0
+#pragma pack(1)
+
+// This structure defines some of the data needed for 'ipmitool sdr/sensor' command .
+typedef struct _ipmi_sensor_s_ {
+#define IPMI_SENSOR_NAME_MAX    16
+	// this is use to fill sdr_record_full_sensor->id_string segment
+	// so the length must be not larger than the sdr_record_full_sensor->id_string segment
+	uint8_t                      name[IPMI_SENSOR_NAME_MAX];
+	ipmi_sensor_type             type;
+	sdr_get_rs                   sdr_header;  // the header of the sdr
+	sdr_record_full_sensor       sensor;      // the real content of the sdr
+}ipmi_sensor_s;
+
+#pragma pack(0)
+
+
+
+#pragma pack(1)
+// This structure define the sensor state , all this value will be get from the userspace .
+// and then write it to the shared memory( between kernel and userspace ) ,
+// then the value will be sent back to the 'ipmitool sdr/sensor' command as a reply message.
+typedef struct _ubmc_sensor_state_s_{
+	uint8_t                      name[IPMI_SENSOR_NAME_MAX];
+	ipmi_sensor_type             type;
+	uint8_t                      sensornum;
+	uint8_t                      value;     // the sensor value
+#define UBMC_SENSOR_THRESHOLD_MAX  6
+	// there will be 6 threshold value as the ipmitool source code
+	uint8_t                      thresholds[UBMC_SENSOR_THRESHOLD_MAX];
+	// the follow two segments are use to calculate the sensor value by 'ipmitool sdr'
+	// Because the sensor value has only one byte.
+    // The details of the calculation can be seen in ipmitool.tar.gz
+	uint16_t mtol;		/* M, tolerance */
+	uint32_t bacc;		/* accuracy, B, Bexp, Rexp */
+	// to ensure that the structure size is 32 bytes.
+	uint8_t                      __reserved[4];
+}ubmc_sensor_state;
+
+
+#pragma pack(0)
+#endif
+
+
+#pragma pack(1)
+
+// Merge the previous two structures : 'ubmc_sensor_state' and 'ipmi_sensor_s' into one ,
+// in order to change the 'mtol' and 'bacc' in user space .
+// ensure that the structure size is 128 bytes ,
+// In order to fit into the kernel shared memory align by 128 bytes .
+typedef struct _ubmc_sensor_s_ {
+#define IPMI_SENSOR_NAME_MAX    16
+	// this is use to fill sdr_record_full_sensor->id_string segment
+	// so the length must be not larger than the sdr_record_full_sensor->id_string segment
+	uint8_t                      name[IPMI_SENSOR_NAME_MAX];
+	ipmi_sensor_type             type;
+	uint8_t                      sensornum;   // it will be used in the userspace
+	uint8_t                      value;       // the sensor value
+#define UBMC_SENSOR_THRESHOLD_MAX  6
+	// there will be 6 threshold value as the ipmitool source code
+	uint8_t                      thresholds[UBMC_SENSOR_THRESHOLD_MAX];
+	sdr_get_rs                   sdr_header;   // the header of the sdr
+	sdr_record_full_sensor       sensor;       // the real content of the sdr
+	// to ensure that the structure size is 128 bytes.
+	uint8_t 					threshold_mask;
+	uint8_t                      __reserved[36];
+}ubmc_sensor_s;
+
+#pragma pack(0)
+
+typedef enum
+{
+	XSMALL = 0,
+	SMALL,
+	MIDDLE,
+	LARGE
+}ubmc_device_type_t;
+
+struct ubmc_ipmi_time
+{
+	bool tm_need_set;	//if it is 0,indicate that there are something need to do by checking io_status
+	struct timeval new_time;	//ipmitool sel time set time which want to set
+};
+struct ubmc_ipmi_dev {
+	void __iomem*		sensor_state_base; /* ubmc sensors state list virtual base , mmap to userspace */
+	uint16_t	rsp_len_last;
+
+	uint8_t	rsp_i2c_len;		//i2c_len (ssif_len+1), not ssif len
+	uint8_t rsp_buf[I2C_SMBUS_BLOCK_MAX+256];
+	ubmc_device_type_t       device_type;
+	int                 major;
+	struct class        *ubmc_class;
+	struct device       *ubmc_device;
+	struct ubmc_ipmi_sel_list ubmc_ipmi_sel_list;
+	struct ubmc_ipmi_lan_s ubmc_ipmi_lan;
+	int io_status;		//be used for some request flag,you can use below value
+#define STATUS_SET_TIME	0x01
+	struct ubmc_ipmi_time ipmi_time;
+
+};
+
+
+#pragma pack(1)
+
+struct ipmi_ssif_req {
+  uint8_t smb_cmd;                 // smbus command
+  uint8_t len;                     // length
+  uint8_t netfn;                   // ipmi netfn
+  uint8_t ipmi_cmd;                // ipmi command
+  uint8_t ipmi_data[];             // ipmi data
+} ;
+
+struct ipmi_ssif_rsp {
+  uint8_t len;
+  uint8_t netfn;                  // ipmi netfn
+  uint8_t ipmi_cmd;               // ipmi command
+  uint8_t ipmi_cc;                // complete code
+  uint8_t ipmi_data[];
+};
+
+
+#pragma pack(0)
+
+extern unsigned int ubmc_debug_enable;
+extern struct ubmc_ipmi_dev g_ubmc_ipmi_pdev;
+
+#define ubmc_debug(format, args...)  if( ubmc_debug_enable ) printk(KERN_WARNING "[FUNC = %s LINE = %d]= "format "\n", __func__, __LINE__,##args)
+#define ubmc_error(format, args...)  printk(KERN_WARNING "[%s:%d]= "format"\n", __func__, __LINE__,##args)
+
+#ifdef UBMC_DEBUG_INFO
+#define ubmc_debug_info(format, args...)  printk("[FUNC = %s LINE = %d]= "format "\n", __func__, __LINE__,##args)
+#else
+#define ubmc_debug_info(format, args...) if(0) printk(KERN_WARNING "[FUNC = %s LINE = %d]= "format "\n", __func__, __LINE__,##args)
+#endif
+int ubmc_ssif_parse_i2c_slave_msg(struct ubmc_ipmi_dev *dev, const uint8_t* inbuf, const uint16_t inlen, uint8_t* outbuf, uint16_t* p_out_len);
+int umbc_ipmi_init_shm_sensor_fill_all(ubmc_device_type_t type);
+int ubmc_i2c_slave_ssif_req_handle(struct ubmc_ipmi_dev *dev, const uint8_t* inbuf, const uint16_t inlen,
+		uint8_t* outbuf, uint16_t* p_outlen);
+int response_ipmi_error_request(struct ubmc_ipmi_dev *dev);
+
+#endif
--- linux-ti2018.02-rc4-int-orig/drivers/i2c/busses/ubmc-ipmi-sdr.h	1970-01-01 08:00:00.000000000 +0800
+++ linux-ti2018.02-rc4-int-silicom/drivers/i2c/busses/ubmc-ipmi-sdr.h	2020-03-09 10:47:12.014803575 +0800
@@ -0,0 +1,409 @@
+
+#ifndef _UBMC_IPMI_SDR_H
+#define _UBMC_IPMI_SDR_H
+
+
+
+#define READING_UNAVAILABLE	0x20
+#define SCANNING_DISABLED	0x40
+#define EVENT_MSG_DISABLED	0x80
+
+#define IS_READING_UNAVAILABLE(val)	((val) & READING_UNAVAILABLE)
+#define IS_SCANNING_DISABLED(val)	(!((val) & SCANNING_DISABLED))
+#define IS_EVENT_MSG_DISABLED(val)	(!((val) & EVENT_MSG_DISABLED))
+
+#define GET_SDR_REPO_INFO	0x20
+#define GET_SDR_ALLOC_INFO	0x21
+#define IPMI_CMD_GET_SEL_INFO  0x40
+#define IPMI_CMD_GET_SEL_ALLOC_INFO	0x41
+
+#define SDR_SENSOR_STAT_LO_NC	(1<<0)
+#define SDR_SENSOR_STAT_LO_CR	(1<<1)
+#define SDR_SENSOR_STAT_LO_NR	(1<<2)
+#define SDR_SENSOR_STAT_HI_NC	(1<<3)
+#define SDR_SENSOR_STAT_HI_CR	(1<<4)
+#define SDR_SENSOR_STAT_HI_NR	(1<<5)
+
+#define GET_DEVICE_SDR_INFO      0x20
+#define GET_DEVICE_SDR           0x21
+#define GET_SENSOR_FACTORS      0x23
+#define SET_SENSOR_HYSTERESIS	0x24
+#define GET_SENSOR_HYSTERESIS	0x25
+#define SET_SENSOR_THRESHOLDS   0x26
+#define GET_SENSOR_THRESHOLDS   0x27
+#define SET_SENSOR_EVENT_ENABLE	0x28
+#define GET_SENSOR_EVENT_ENABLE 0x29
+#define GET_SENSOR_EVENT_STATUS	0x2b
+#define GET_SENSOR_READING	0x2d
+#define GET_SENSOR_TYPE		0x2f
+
+
+
+
+#pragma pack(1)
+
+struct entity_id {
+	uint8_t	id;			/* physical entity id */
+	uint8_t	instance    : 7;	/* instance number */
+	uint8_t	logical     : 1;	/* physical/logical */
+} ;
+
+#pragma pack(0)
+
+
+#pragma pack(1)
+
+struct sdr_repo_info_rs {
+	uint8_t version;	/* SDR version (51h) */
+	uint16_t count;		/* number of records */
+	uint16_t free;		/* free space in SDR */
+	uint32_t add_stamp;	/* last add timestamp */
+	uint32_t erase_stamp;	/* last del timestamp */
+	uint8_t op_support;	/* supported operations */
+} ;
+
+#pragma pack(0)
+
+
+#pragma pack(1)
+
+/* builtin (device) sdrs support */
+struct sdr_device_info_rs {
+	unsigned char count;	/* number of records */
+	unsigned char flags;	/* flags */
+	unsigned char popChangeInd[3];	/* free space in SDR */
+} ;
+
+#pragma pack(0)
+
+#pragma pack(1)
+
+#define GET_SDR_RESERVE_REPO	0x22
+struct sdr_reserve_repo_rs {
+	uint16_t reserve_id;	/* reservation ID */
+} ;
+
+#pragma pack(0)
+
+
+
+
+#pragma pack(1)
+
+#define GET_SDR		0x23
+struct sdr_get_rq {
+	uint16_t reserve_id;	/* reservation ID */
+	uint16_t id;		/* record ID */
+	uint8_t offset;		/* offset into SDR */
+#define GET_SDR_ENTIRE_RECORD	0xff
+	uint8_t length;		/* length to read */
+} ;
+
+#pragma pack(0)
+
+
+
+#pragma pack(1)
+
+struct sdr_get_rs {
+	uint16_t next;		/* next record id */
+	uint16_t id;		/* record ID */
+	uint8_t version;	/* SDR version (51h) */
+#define SDR_RECORD_TYPE_FULL_SENSOR		0x01
+#define SDR_RECORD_TYPE_COMPACT_SENSOR		0x02
+#define SDR_RECORD_TYPE_EVENTONLY_SENSOR	0x03
+#define SDR_RECORD_TYPE_ENTITY_ASSOC		0x08
+#define SDR_RECORD_TYPE_DEVICE_ENTITY_ASSOC	0x09
+#define SDR_RECORD_TYPE_GENERIC_DEVICE_LOCATOR	0x10
+#define SDR_RECORD_TYPE_FRU_DEVICE_LOCATOR	0x11
+#define SDR_RECORD_TYPE_MC_DEVICE_LOCATOR	0x12
+#define SDR_RECORD_TYPE_MC_CONFIRMATION		0x13
+#define SDR_RECORD_TYPE_BMC_MSG_CHANNEL_INFO	0x14
+#define SDR_RECORD_TYPE_OEM			0xc0
+	uint8_t type;		/* record type */
+	uint8_t length;		/* remaining record bytes */
+} ;
+
+#pragma pack(0)
+
+
+struct sdr_record_mask {
+	union {
+		struct {
+			uint16_t assert_event;	/* assertion event mask */
+			uint16_t deassert_event;	/* de-assertion event mask */
+			uint16_t read;	/* discrete reading mask */
+		}  discrete;
+		struct {
+
+			uint16_t assert_lnc_low:1;
+			uint16_t assert_lnc_high:1;
+			uint16_t assert_lcr_low:1;
+			uint16_t assert_lcr_high:1;
+			uint16_t assert_lnr_low:1;
+			uint16_t assert_lnr_high:1;
+			uint16_t assert_unc_low:1;
+			uint16_t assert_unc_high:1;
+			uint16_t assert_ucr_low:1;
+			uint16_t assert_ucr_high:1;
+			uint16_t assert_unr_low:1;
+			uint16_t assert_unr_high:1;
+			uint16_t status_lnc:1;
+			uint16_t status_lcr:1;
+			uint16_t status_lnr:1;
+			uint16_t reserved:1;
+
+
+			uint16_t deassert_lnc_low:1;
+			uint16_t deassert_lnc_high:1;
+			uint16_t deassert_lcr_low:1;
+			uint16_t deassert_lcr_high:1;
+			uint16_t deassert_lnr_low:1;
+			uint16_t deassert_lnr_high:1;
+			uint16_t deassert_unc_low:1;
+			uint16_t deassert_unc_high:1;
+			uint16_t deassert_ucr_low:1;
+			uint16_t deassert_ucr_high:1;
+			uint16_t deassert_unr_low:1;
+			uint16_t deassert_unr_high:1;
+			uint16_t status_unc:1;
+			uint16_t status_ucr:1;
+			uint16_t status_unr:1;
+			uint16_t reserved_2:1;
+			union {
+				struct {
+
+					uint16_t readable:8;
+					uint16_t lnc:1;
+					uint16_t lcr:1;
+					uint16_t lnr:1;
+					uint16_t unc:1;
+					uint16_t ucr:1;
+					uint16_t unr:1;
+					uint16_t reserved:2;
+
+				}  set;
+				struct {
+
+					uint16_t lnc:1;
+					uint16_t lcr:1;
+					uint16_t lnr:1;
+					uint16_t unc:1;
+					uint16_t ucr:1;
+					uint16_t unr:1;
+					uint16_t reserved:2;
+					uint16_t settable:8;
+
+				}  read;
+			} ;
+		}  threshold;
+	}  type;
+} ;
+
+#pragma pack(0)
+
+
+
+#pragma pack(1)
+
+struct sdr_record_common_sensor {
+	struct {
+		uint8_t owner_id;
+
+		uint8_t lun:2;	/* sensor owner lun */
+		uint8_t __reserved:2;
+		uint8_t channel:4;	/* channel number */
+
+		uint8_t sensor_num;	/* unique sensor number */
+	}  keys;
+
+	struct entity_id entity;
+
+	struct {
+		struct {
+
+			uint8_t sensor_scan:1;
+			uint8_t event_gen:1;
+			uint8_t type:1;
+			uint8_t hysteresis:1;
+			uint8_t thresholds:1;
+			uint8_t events:1;
+			uint8_t scanning:1;
+			uint8_t __reserved:1;
+
+		}  init;
+		struct {
+
+			uint8_t event_msg:2;
+			uint8_t threshold:2;
+			uint8_t hysteresis:2;
+			uint8_t rearm:1;
+			uint8_t ignore:1;
+
+		}  capabilities;
+		uint8_t type;
+	}  sensor;
+
+	uint8_t event_type;	/* event/reading type code */
+
+	struct sdr_record_mask mask;
+
+	struct {
+
+		uint8_t pct:1;
+		uint8_t modifier:2;
+		uint8_t rate:3;
+		uint8_t analog:2;
+
+		struct {
+			uint8_t base;
+			uint8_t modifier;
+		}  type;
+	}  unit;
+} ;
+
+/* SDR Record Common Sensor header macros */
+#define IS_THRESHOLD_SENSOR(s)	((s)->event_type == 1)
+#define UNITS_ARE_DISCRETE(s)	((s)->unit.analog == 3)
+
+
+#pragma pack(0)
+
+
+
+#pragma pack(1)
+
+struct sdr_record_compact_sensor {
+	struct sdr_record_common_sensor cmn;
+	struct {
+
+		uint8_t count:4;
+		uint8_t mod_type:2;
+		uint8_t __reserved:2;
+
+
+		uint8_t mod_offset:7;
+		uint8_t entity_inst:1;
+
+	}  share;
+
+	struct {
+		struct {
+			uint8_t positive;
+			uint8_t negative;
+		}  hysteresis;
+	}  threshold;
+
+	uint8_t __reserved[3];
+	uint8_t oem;		/* reserved for OEM use */
+	uint8_t id_code;	/* sensor ID string type/length code */
+	uint8_t id_string[16];	/* sensor ID string bytes, only if id_code != 0 */
+} ;
+
+#pragma pack(0)
+
+
+#pragma pack(1)
+
+struct sdr_record_eventonly_sensor {
+	struct {
+		uint8_t owner_id;
+
+		uint8_t lun:2;	/* sensor owner lun */
+		uint8_t fru_owner:2;	/* fru device owner lun */
+		uint8_t channel:4;	/* channel number */
+
+		uint8_t sensor_num;	/* unique sensor number */
+	}  keys;
+
+	struct entity_id entity;
+
+	uint8_t sensor_type;	/* sensor type */
+	uint8_t event_type;	/* event/reading type code */
+
+	struct {
+
+		uint8_t count:4;
+		uint8_t mod_type:2;
+		uint8_t __reserved:2;
+
+		uint8_t mod_offset:7;
+		uint8_t entity_inst:1;
+
+	}  share;
+
+	uint8_t __reserved;
+	uint8_t oem;		/* reserved for OEM use */
+	uint8_t id_code;	/* sensor ID string type/length code */
+	uint8_t id_string[16];	/* sensor ID string bytes, only if id_code != 0 */
+
+} ;
+
+#pragma pack(0)
+
+
+
+#pragma pack(1)
+
+struct sdr_record_full_sensor {
+	struct sdr_record_common_sensor cmn;
+
+#define SDR_SENSOR_L_LINEAR     0x00
+#define SDR_SENSOR_L_LN         0x01
+#define SDR_SENSOR_L_LOG10      0x02
+#define SDR_SENSOR_L_LOG2       0x03
+#define SDR_SENSOR_L_E          0x04
+#define SDR_SENSOR_L_EXP10      0x05
+#define SDR_SENSOR_L_EXP2       0x06
+#define SDR_SENSOR_L_1_X        0x07
+#define SDR_SENSOR_L_SQR        0x08
+#define SDR_SENSOR_L_CUBE       0x09
+#define SDR_SENSOR_L_SQRT       0x0a
+#define SDR_SENSOR_L_CUBERT     0x0b
+#define SDR_SENSOR_L_NONLINEAR  0x70
+
+	uint8_t linearization;	/* 70h=non linear, 71h-7Fh=non linear, OEM */
+	uint16_t mtol;		/* M, tolerance */
+	uint32_t bacc;		/* accuracy, B, Bexp, Rexp */
+
+	struct {
+
+		uint8_t nominal_read:1;	/* nominal reading field specified */
+		uint8_t normal_max:1;	/* normal max field specified */
+		uint8_t normal_min:1;	/* normal min field specified */
+		uint8_t __reserved:5;
+
+	}  analog_flag;
+
+	uint8_t nominal_read;	/* nominal reading, raw value */
+	uint8_t normal_max;	/* normal maximum, raw value */
+	uint8_t normal_min;	/* normal minimum, raw value */
+	uint8_t sensor_max;	/* sensor maximum, raw value */
+	uint8_t sensor_min;	/* sensor minimum, raw value */
+
+	struct {
+		struct {
+			uint8_t non_recover;
+			uint8_t critical;
+			uint8_t non_critical;
+		}  upper;
+		struct {
+			uint8_t non_recover;
+			uint8_t critical;
+			uint8_t non_critical;
+		}  lower;
+		struct {
+			uint8_t positive;
+			uint8_t negative;
+		}  hysteresis;
+	}  threshold;
+	uint8_t __reserved[2];
+	uint8_t oem;		/* reserved for OEM use */
+	uint8_t id_code;	/* sensor ID string type/length code */
+	uint8_t id_string[16];	/* sensor ID string bytes, only if id_code != 0 */
+} ;
+
+#pragma pack(0)
+
+
+#endif				/* IPMI_SDR_H */
--- linux-ti2018.02-rc4-int-orig/drivers/i2c/busses/i2c-omap.h	1970-01-01 08:00:00.000000000 +0800
+++ linux-ti2018.02-rc4-int-silicom/drivers/i2c/busses/i2c-omap.h	2020-03-09 10:47:12.014803575 +0800
@@ -0,0 +1,166 @@
+/*
+ * i2c-omap.h
+ *
+ *  Created on: May 22, 2018
+ *      Author: jeff_zheng
+ */
+
+#ifndef DRIVERS_I2C_BUSSES_I2C_OMAP_H_
+#define DRIVERS_I2C_BUSSES_I2C_OMAP_H_
+
+
+/* I2C controller revisions */
+#define OMAP_I2C_OMAP1_REV_2		0x20
+
+/* I2C controller revisions present on specific hardware */
+#define OMAP_I2C_REV_ON_2430		0x00000036
+#define OMAP_I2C_REV_ON_3430_3530	0x0000003C
+#define OMAP_I2C_REV_ON_3630		0x00000040
+#define OMAP_I2C_REV_ON_4430_PLUS	0x50400002
+
+/* timeout waiting for the controller to respond */
+#define OMAP_I2C_TIMEOUT (msecs_to_jiffies(1000))
+
+/* timeout for pm runtime autosuspend */
+#define OMAP_I2C_PM_TIMEOUT		1000	/* ms */
+
+/* timeout for making decision on bus free status */
+#define OMAP_I2C_BUS_FREE_TIMEOUT (msecs_to_jiffies(10))
+
+/* For OMAP3 I2C_IV has changed to I2C_WE (wakeup enable) */
+enum {
+	OMAP_I2C_REV_REG = 0,
+	OMAP_I2C_IE_REG,
+	OMAP_I2C_STAT_REG,
+	OMAP_I2C_IV_REG,
+	OMAP_I2C_WE_REG,
+	OMAP_I2C_SYSS_REG,
+	OMAP_I2C_BUF_REG,
+	OMAP_I2C_CNT_REG,
+	OMAP_I2C_DATA_REG,
+	OMAP_I2C_SYSC_REG,
+	OMAP_I2C_CON_REG,
+	OMAP_I2C_OA_REG,
+	OMAP_I2C_SA_REG,
+	OMAP_I2C_PSC_REG,
+	OMAP_I2C_SCLL_REG,
+	OMAP_I2C_SCLH_REG,
+	OMAP_I2C_SYSTEST_REG,
+	OMAP_I2C_BUFSTAT_REG,
+	/* only on OMAP4430 */
+	OMAP_I2C_IP_V2_REVNB_LO,
+	OMAP_I2C_IP_V2_REVNB_HI,
+	OMAP_I2C_IP_V2_IRQSTATUS_RAW,
+	OMAP_I2C_IP_V2_IRQENABLE_SET,
+	OMAP_I2C_IP_V2_IRQENABLE_CLR,
+	OMAP_I2C_IE_CLR_REG,
+};
+
+/* I2C Interrupt Enable Register (OMAP_I2C_IE): */
+#define OMAP_I2C_IE_XDR		(1 << 14)	/* TX Buffer drain int enable */
+#define OMAP_I2C_IE_RDR		(1 << 13)	/* RX Buffer drain int enable */
+#define OMAP_I2C_IE_BB		(1 << 12)	/* Bus busy int enable */
+#define OMAP_I2C_IE_ROVR	(1 << 11)	/* Receive overrun int enable */
+#define OMAP_I2C_IE_XUDF	(1 << 10)	/* Transmit underflow int enable */
+#define OMAP_I2C_IE_AAS		(1 << 9)	/* Address as slave int enable */
+#define OMAP_I2C_IE_BF		(1 << 8)	/* Bus free int enable */
+#define OMAP_I2C_IE_AERR	(1 << 7)	/* Access error int enable */
+#define OMAP_I2C_IE_STC		(1 << 6)	/* Start int enable */
+#define OMAP_I2C_IE_GC		(1 << 5)	/* General call int enable */
+#define OMAP_I2C_IE_XRDY	(1 << 4)	/* TX data ready int enable */
+#define OMAP_I2C_IE_RRDY	(1 << 3)	/* RX data ready int enable */
+#define OMAP_I2C_IE_ARDY	(1 << 2)	/* Access ready int enable */
+#define OMAP_I2C_IE_NACK	(1 << 1)	/* No ack interrupt enable */
+#define OMAP_I2C_IE_AL		(1 << 0)	/* Arbitration lost int ena */
+
+/* I2C Status Register (OMAP_I2C_STAT): */
+#define OMAP_I2C_STAT_XDR	(1 << 14)	/* TX Buffer draining */
+#define OMAP_I2C_STAT_RDR	(1 << 13)	/* RX Buffer draining */
+#define OMAP_I2C_STAT_BB	(1 << 12)	/* Bus busy */
+#define OMAP_I2C_STAT_ROVR	(1 << 11)	/* Receive overrun */
+#define OMAP_I2C_STAT_XUDF	(1 << 10)	/* Transmit underflow */
+#define OMAP_I2C_STAT_AAS	(1 << 9)	/* Address as slave */
+#define OMAP_I2C_STAT_BF	(1 << 8)	/* Bus Free */
+#define OMAP_I2C_STAT_AERR	(1 << 7)	/* Bus Free */
+#define OMAP_I2C_STAT_XRDY	(1 << 4)	/* Transmit data ready */
+#define OMAP_I2C_STAT_RRDY	(1 << 3)	/* Receive data ready */
+#define OMAP_I2C_STAT_ARDY	(1 << 2)	/* Register access ready */
+#define OMAP_I2C_STAT_NACK	(1 << 1)	/* No ack interrupt enable */
+#define OMAP_I2C_STAT_AL	(1 << 0)	/* Arbitration lost int ena */
+
+/* I2C WE wakeup enable register */
+#define OMAP_I2C_WE_XDR_WE	(1 << 14)	/* TX drain wakup */
+#define OMAP_I2C_WE_RDR_WE	(1 << 13)	/* RX drain wakeup */
+#define OMAP_I2C_WE_AAS_WE	(1 << 9)	/* Address as slave wakeup*/
+#define OMAP_I2C_WE_BF_WE	(1 << 8)	/* Bus free wakeup */
+#define OMAP_I2C_WE_STC_WE	(1 << 6)	/* Start condition wakeup */
+#define OMAP_I2C_WE_GC_WE	(1 << 5)	/* General call wakeup */
+#define OMAP_I2C_WE_DRDY_WE	(1 << 3)	/* TX/RX data ready wakeup */
+#define OMAP_I2C_WE_ARDY_WE	(1 << 2)	/* Reg access ready wakeup */
+#define OMAP_I2C_WE_NACK_WE	(1 << 1)	/* No acknowledgment wakeup */
+#define OMAP_I2C_WE_AL_WE	(1 << 0)	/* Arbitration lost wakeup */
+
+#define OMAP_I2C_WE_ALL		(OMAP_I2C_WE_XDR_WE | OMAP_I2C_WE_RDR_WE | \
+				OMAP_I2C_WE_AAS_WE | OMAP_I2C_WE_BF_WE | \
+				OMAP_I2C_WE_STC_WE | OMAP_I2C_WE_GC_WE | \
+				OMAP_I2C_WE_DRDY_WE | OMAP_I2C_WE_ARDY_WE | \
+				OMAP_I2C_WE_NACK_WE | OMAP_I2C_WE_AL_WE)
+
+/* I2C Buffer Configuration Register (OMAP_I2C_BUF): */
+#define OMAP_I2C_BUF_RDMA_EN	(1 << 15)	/* RX DMA channel enable */
+#define OMAP_I2C_BUF_RXFIF_CLR	(1 << 14)	/* RX FIFO Clear */
+#define OMAP_I2C_BUF_XDMA_EN	(1 << 7)	/* TX DMA channel enable */
+#define OMAP_I2C_BUF_TXFIF_CLR	(1 << 6)	/* TX FIFO Clear */
+
+/* I2C Configuration Register (OMAP_I2C_CON): */
+#define OMAP_I2C_CON_EN		(1 << 15)	/* I2C module enable */
+#define OMAP_I2C_CON_BE		(1 << 14)	/* Big endian mode */
+#define OMAP_I2C_CON_OPMODE_HS	(1 << 12)	/* High Speed support */
+#define OMAP_I2C_CON_STB	(1 << 11)	/* Start byte mode (master) */
+#define OMAP_I2C_CON_MST	(1 << 10)	/* Master/slave mode */
+#define OMAP_I2C_CON_TRX	(1 << 9)	/* TX/RX mode (master only) */
+#define OMAP_I2C_CON_XA		(1 << 8)	/* Expand address */
+#define OMAP_I2C_CON_RM		(1 << 2)	/* Repeat mode (master only) */
+#define OMAP_I2C_CON_STP	(1 << 1)	/* Stop cond (master only) */
+#define OMAP_I2C_CON_STT	(1 << 0)	/* Start condition (master) */
+
+/* I2C SCL time value when Master */
+#define OMAP_I2C_SCLL_HSSCLL	8
+#define OMAP_I2C_SCLH_HSSCLH	8
+
+/* I2C System Test Register (OMAP_I2C_SYSTEST): */
+#define OMAP_I2C_SYSTEST_ST_EN		(1 << 15)	/* System test enable */
+#define OMAP_I2C_SYSTEST_FREE		(1 << 14)	/* Free running mode */
+#define OMAP_I2C_SYSTEST_TMODE_MASK	(3 << 12)	/* Test mode select */
+#define OMAP_I2C_SYSTEST_TMODE_SHIFT	(12)		/* Test mode select */
+/* Functional mode */
+#define OMAP_I2C_SYSTEST_SCL_I_FUNC	(1 << 8)	/* SCL line input value */
+#define OMAP_I2C_SYSTEST_SCL_O_FUNC	(1 << 7)	/* SCL line output value */
+#define OMAP_I2C_SYSTEST_SDA_I_FUNC	(1 << 6)	/* SDA line input value */
+#define OMAP_I2C_SYSTEST_SDA_O_FUNC	(1 << 5)	/* SDA line output value */
+/* SDA/SCL IO mode */
+#define OMAP_I2C_SYSTEST_SCL_I		(1 << 3)	/* SCL line sense in */
+#define OMAP_I2C_SYSTEST_SCL_O		(1 << 2)	/* SCL line drive out */
+#define OMAP_I2C_SYSTEST_SDA_I		(1 << 1)	/* SDA line sense in */
+#define OMAP_I2C_SYSTEST_SDA_O		(1 << 0)	/* SDA line drive out */
+
+/* OCP_SYSSTATUS bit definitions */
+#define SYSS_RESETDONE_MASK		(1 << 0)
+
+/* OCP_SYSCONFIG bit definitions */
+#define SYSC_CLOCKACTIVITY_MASK		(0x3 << 8)
+#define SYSC_SIDLEMODE_MASK		(0x3 << 3)
+#define SYSC_ENAWAKEUP_MASK		(1 << 2)
+#define SYSC_SOFTRESET_MASK		(1 << 1)
+#define SYSC_AUTOIDLE_MASK		(1 << 0)
+
+#define SYSC_IDLEMODE_SMART		0x2
+#define SYSC_CLOCKACTIVITY_FCLK		0x2
+
+/* Errata definitions */
+#define I2C_OMAP_ERRATA_I207		(1 << 0)
+#define I2C_OMAP_ERRATA_I462		(1 << 1)
+
+#define OMAP_I2C_IP_V2_INTERRUPTS_MASK	0x6FFF
+
+#endif /* DRIVERS_I2C_BUSSES_I2C_OMAP_H_ */
--- linux-ti2018.02-rc4-int-orig/drivers/i2c/busses/i2c-omap.c	2018-07-15 00:46:29.000000000 +0800
+++ linux-ti2018.02-rc4-int-silicom/drivers/i2c/busses/i2c-omap.c	2020-03-09 10:47:12.014803575 +0800
@@ -40,6 +40,10 @@
 #include <linux/pm_runtime.h>
 #include <linux/pinctrl/consumer.h>
 
+#include "i2c-omap.h"
+#if 0
+//moved to i2c-omap.h by Jeff
+
 /* I2C controller revisions */
 #define OMAP_I2C_OMAP1_REV_2		0x20
 
@@ -183,6 +187,7 @@
 #define I2C_OMAP_ERRATA_I462		(1 << 1)
 
 #define OMAP_I2C_IP_V2_INTERRUPTS_MASK	0x6FFF
+#endif
 
 struct omap_i2c_dev {
 	struct device		*dev;
--- linux-ti2018.02-rc4-int-orig/drivers/i2c/busses/ubmc-muxdump.c	1970-01-01 08:00:00.000000000 +0800
+++ linux-ti2018.02-rc4-int-silicom/drivers/i2c/busses/ubmc-muxdump.c	2020-03-09 10:47:12.014803575 +0800
@@ -0,0 +1,969 @@
+/*
+ * ubmc-muxdump.c
+ *
+ *  Created on: Jun 20, 2018
+ *      Author: jason_zhang
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/slab.h>
+#include <linux/fs.h>
+#include <linux/proc_fs.h>
+#include <linux/seq_file.h>
+#include <linux/mm.h>
+#include <net/net_namespace.h>
+#include <asm/io.h>
+#include "ubmc-muxdump.h"
+
+unsigned int READ_CTR_REG(unsigned int offset , volatile unsigned int *vir_adr)
+{
+	unsigned int val;
+	//printk("val is %x adr is %lx",*(vir_adr + offset),vir_adr + offset);
+	val = readl(vir_adr + offset);
+	printk("function READ_CTR_REG :value is %x vir_adr is %x ,off is %x",val,vir_adr,offset);
+	return val;
+}
+unsigned int read_ctr_reg(unsigned int offset , volatile unsigned int *vir_adr)
+{
+	unsigned int val;
+	val = readl(vir_adr + offset);
+	//printk("function READ_CTR_REG :value is %x vir_adr is %lx ,off is %x",val,vir_adr,offset);
+	return val;
+}
+volatile unsigned int *g_vir_addr;
+
+typedef struct pin{
+	enum io_sta_e{INPUT,OUTPUT} io_sta;
+    enum io_dir_e{PULLDISABLE,PULLUP,PULLDOWN} io_dir;
+    char pin_name[NAME_MAX_SIZE];
+    char pin_dir_str[NAME_MAX_SIZE];
+    char pin_sta_str[NAME_MAX_SIZE];
+	char mode;
+}pin_status;
+
+
+pin_status* get_pin(const char *pin_name,unsigned int reg_val)
+{
+	pin_status* pin;
+	unsigned int temp_val , temp;
+	pin = kmalloc(sizeof(pin_status),GFP_KERNEL);
+	if (pin == NULL)
+	{
+
+		printk("%s: kmalloc failed\n", __func__);
+		return NULL;
+	}
+	strcpy(pin->pin_name,pin_name);
+	temp_val = reg_val & 0x7f;
+	temp = (temp_val & 0x20) >> 5;			//bit 5
+	if(temp)
+	{
+		pin->io_dir = INPUT;
+		strcpy(pin->pin_dir_str,"INPUT");
+	}
+	else
+	{
+		pin->io_dir = OUTPUT;
+		strcpy(pin->pin_dir_str,"OUTPUT");
+	}
+	temp = (temp_val & 0x08) >> 3;			//bit 3
+	if(temp)
+	{
+		pin->io_sta = PULLDISABLE;
+		strcpy(pin->pin_sta_str,"PULLDISABLE");
+	}
+	else
+	{
+		if((temp_val & 0x10) >> 3)
+		{
+			pin->io_sta = PULLUP;
+			strcpy(pin->pin_sta_str,"PULLUP");
+		}
+		else
+		{
+			pin->io_sta = PULLDOWN;
+			strcpy(pin->pin_sta_str,"PULLDOWN");
+		}
+	}
+
+	pin->mode = temp_val & 0x07;
+	return pin;
+}
+
+void prt_to_proc(pin_status* pin,struct seq_file *m)
+{
+
+	seq_printf(m,"%-20s \t\t <%s|%s> \t\t MODE %d \n",pin->pin_name,pin->pin_dir_str,pin->pin_sta_str,pin->mode);
+}
+
+static void pin_ctr_reg_dump(struct seq_file *m,volatile unsigned int *vir_addr)
+{
+	unsigned int reg_val;
+	pin_status* pin ;
+	reg_val = read_ctr_reg(OFFSET(gpmc_ad0),vir_addr);
+	pin = get_pin("gpmc_ad0",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(gpmc_ad1),vir_addr);
+	pin = get_pin("gpmc_ad1",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(gpmc_ad2),vir_addr);
+	pin = get_pin("gpmc_ad2",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(gpmc_ad3),vir_addr);
+	pin = get_pin("gpmc_ad3",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(gpmc_ad4),vir_addr);
+	pin = get_pin("gpmc_ad4",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(gpmc_ad5),vir_addr);
+	pin = get_pin("gpmc_ad5",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(gpmc_ad6),vir_addr);
+	pin = get_pin("gpmc_ad6",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(gpmc_ad7),vir_addr);
+	pin = get_pin("gpmc_ad7",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(gpmc_ad8),vir_addr);
+	pin = get_pin("gpmc_ad8",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(gpmc_ad9),vir_addr);
+	pin = get_pin("gpmc_ad9",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(gpmc_ad10),vir_addr);
+	pin = get_pin("gpmc_ad10",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(gpmc_ad11),vir_addr);
+	pin = get_pin("gpmc_ad11",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(gpmc_ad12),vir_addr);
+	pin = get_pin("gpmc_ad12",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(gpmc_ad13),vir_addr);
+	pin = get_pin("gpmc_ad13",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(gpmc_ad14),vir_addr);
+	pin = get_pin("gpmc_ad14",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(gpmc_ad15),vir_addr);
+	pin = get_pin("gpmc_ad15",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(gpmc_a0),vir_addr);
+	pin = get_pin("gpmc_a0",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(gpmc_a1),vir_addr);
+	pin = get_pin("gpmc_a1",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(gpmc_a2),vir_addr);
+	pin = get_pin("gpmc_a2",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(gpmc_a3),vir_addr);
+	pin = get_pin("gpmc_a3",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(gpmc_a4),vir_addr);
+	pin = get_pin("gpmc_a4",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(gpmc_a5),vir_addr);
+	pin = get_pin("gpmc_a5",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(gpmc_a6),vir_addr);
+	pin = get_pin("gpmc_a6",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(gpmc_a7),vir_addr);
+	pin = get_pin("gpmc_a7",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(gpmc_a8),vir_addr);
+	pin = get_pin("gpmc_a8",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(gpmc_a9),vir_addr);
+	pin = get_pin("gpmc_a9",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(gpmc_a10),vir_addr);
+	pin = get_pin("gpmc_a10",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(gpmc_a11),vir_addr);
+	pin = get_pin("gpmc_a11",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(gpmc_wait0),vir_addr);
+	pin = get_pin("gpmc_wait0",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(gpmc_wpn),vir_addr);
+	pin = get_pin("gpmc_wpn",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(gpmc_be1n),vir_addr);
+	pin = get_pin("gpmc_be1n",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(gpmc_csn0),vir_addr);
+	pin = get_pin("gpmc_csn0",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(gpmc_csn1),vir_addr);
+	pin = get_pin("gpmc_csn1",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(gpmc_csn2),vir_addr);
+	pin = get_pin("gpmc_csn2",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(gpmc_csn3),vir_addr);
+	pin = get_pin("gpmc_csn3",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(gpmc_advn_ale),vir_addr);
+	pin = get_pin("gpmc_advn_ale",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(gpmc_oen_ren),vir_addr);
+	pin = get_pin("gpmc_oen_ren",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(gpmc_wen),vir_addr);
+	pin = get_pin("gpmc_wen",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(gpmc_be0n_cle),vir_addr);
+	pin = get_pin("gpmc_be0n_cle",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(lcd_data0),vir_addr);
+	pin = get_pin("lcd_data0",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(lcd_data1),vir_addr);
+	pin = get_pin("lcd_data1",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(lcd_data2),vir_addr);
+	pin = get_pin("lcd_data2",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(lcd_data3),vir_addr);
+	pin = get_pin("lcd_data3",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(lcd_data4),vir_addr);
+	pin = get_pin("lcd_data4",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(lcd_data5),vir_addr);
+	pin = get_pin("lcd_data5",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(lcd_data6),vir_addr);
+	pin = get_pin("lcd_data6",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(lcd_data7),vir_addr);
+	pin = get_pin("lcd_data7",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(lcd_data8),vir_addr);
+	pin = get_pin("lcd_data8",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(lcd_data9),vir_addr);
+	pin = get_pin("lcd_data9",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(lcd_data10),vir_addr);
+	pin = get_pin("lcd_data10",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(lcd_data11),vir_addr);
+	pin = get_pin("lcd_data11",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(lcd_data12),vir_addr);
+	pin = get_pin("lcd_data12",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(lcd_data13),vir_addr);
+	pin = get_pin("lcd_data13",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(lcd_data14),vir_addr);
+	pin = get_pin("lcd_data14",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(lcd_data15),vir_addr);
+	pin = get_pin("lcd_data15",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(lcd_vsync),vir_addr);
+	pin = get_pin("lcd_vsync",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(lcd_hsync),vir_addr);
+	pin = get_pin("lcd_hsync",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(lcd_ac_bias_en),vir_addr);
+	pin = get_pin("lcd_ac_bias_en",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(mmc0_dat3),vir_addr);
+	pin = get_pin("mmc0_dat3",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(mmc0_dat2),vir_addr);
+	pin = get_pin("mmc0_dat2",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(mmc0_dat1),vir_addr);
+	pin = get_pin("mmc0_dat1",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(mmc0_dat0),vir_addr);
+	pin = get_pin("mmc0_dat0",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(mmc0_clk),vir_addr);
+	pin = get_pin("mmc0_clk",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(mmc0_cmd),vir_addr);
+	pin = get_pin("mmc0_cmd",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(mii1_col),vir_addr);
+	pin = get_pin("mii1_col",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(mii1_crs),vir_addr);
+	pin = get_pin("mii1_crs",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(mii1_rxerr),vir_addr);
+	pin = get_pin("mii1_rxerr",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(mii1_txen),vir_addr);
+	pin = get_pin("mii1_txen",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(mii1_rxdv),vir_addr);
+	pin = get_pin("mii1_rxdv",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(mii1_txd3),vir_addr);
+	pin = get_pin("mii1_txd3",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(mii1_txd2),vir_addr);
+	pin = get_pin("mii1_txd2",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(mii1_txd1),vir_addr);
+	pin = get_pin("mii1_txd1",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(mii1_txd0),vir_addr);
+	pin = get_pin("mii1_txd0",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(mii1_txclk),vir_addr);
+	pin = get_pin("mii1_txclk",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(mii1_rxclk),vir_addr);
+	pin = get_pin("mii1_rxclk",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(mii1_rxd3),vir_addr);
+	pin = get_pin("mii1_rxd3",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(mii1_rxd2),vir_addr);
+	pin = get_pin("mii1_rxd2",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(mii1_rxd1),vir_addr);
+	pin = get_pin("mii1_rxd1",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(mii1_rxd0),vir_addr);
+	pin = get_pin("mii1_rxd0",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(rmii1_refclk),vir_addr);
+	pin = get_pin("rmii1_refclk",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(mdio_data),vir_addr);
+	pin = get_pin("mdio_data",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(mdio_clk),vir_addr);
+	pin = get_pin("mdio_clk",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(spi0_sclk),vir_addr);
+	pin = get_pin("spi0_sclk",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(spi0_d0),vir_addr);
+	pin = get_pin("spi0_d0",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(spi0_d1),vir_addr);
+	pin = get_pin("spi0_d1",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(spi0_cs0),vir_addr);
+	pin = get_pin("spi0_cs0",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(spi0_cs1),vir_addr);
+	pin = get_pin("spi0_cs1",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(ecap0_in_pwm0_out),vir_addr);
+	pin = get_pin("ecap0_in_pwm0_out",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(uart0_ctsn),vir_addr);
+	pin = get_pin("uart0_ctsn",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(uart0_rtsn),vir_addr);
+	pin = get_pin("uart0_rtsn",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(uart0_rxd),vir_addr);
+	pin = get_pin("uart0_rxd",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(uart0_txd),vir_addr);
+	pin = get_pin("uart0_txd",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(uart1_ctsn),vir_addr);
+	pin = get_pin("uart1_ctsn",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(uart1_rtsn),vir_addr);
+	pin = get_pin("uart1_rtsn",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(uart1_rxd),vir_addr);
+	pin = get_pin("uart1_rxd",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(uart1_txd),vir_addr);
+	pin = get_pin("uart1_txd",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(i2c0_sda),vir_addr);
+	pin = get_pin("i2c0_sda",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(i2c0_scl),vir_addr);
+	pin = get_pin("i2c0_scl",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(mcasp0_aclkx),vir_addr);
+	pin = get_pin("mcasp0_aclkx",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(mcasp0_fsx),vir_addr);
+	pin = get_pin("mcasp0_fsx",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(mcasp0_axr0),vir_addr);
+	pin = get_pin("mcasp0_axr0",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(mcasp0_ahclkr),vir_addr);
+	pin = get_pin("mcasp0_ahclkr",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(mcasp0_aclkr),vir_addr);
+	pin = get_pin("mcasp0_aclkr",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(mcasp0_fsr),vir_addr);
+	pin = get_pin("mcasp0_fsr",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(mcasp0_axr1),vir_addr);
+	pin = get_pin("mcasp0_axr1",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(mcasp0_ahclkx),vir_addr);
+	pin = get_pin("mcasp0_ahclkx",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(xdma_event_intr0),vir_addr);
+	pin = get_pin("xdma_event_intr0",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(xdma_event_intr1),vir_addr);
+	pin = get_pin("xdma_event_intr1",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(nresetin_out),vir_addr);
+	pin = get_pin("nresetin_out",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(porz),vir_addr);
+	pin = get_pin("porz",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(nnmi),vir_addr);
+	pin = get_pin("nnmi",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(osc0_in),vir_addr);
+	pin = get_pin("osc0_in",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(osc0_out),vir_addr);
+	pin = get_pin("osc0_out",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(rsvd1),vir_addr);
+	pin = get_pin("rsvd1",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(tms),vir_addr);
+	pin = get_pin("tms",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(tdi),vir_addr);
+	pin = get_pin("tdi",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(tdo),vir_addr);
+	pin = get_pin("tdo",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(tck),vir_addr);
+	pin = get_pin("tck",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(ntrst),vir_addr);
+	pin = get_pin("ntrst",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(emu0),vir_addr);
+	pin = get_pin("emu0",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(emu1),vir_addr);
+	pin = get_pin("emu1",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(osc1_in),vir_addr);
+	pin = get_pin("osc1_in",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(osc1_out),vir_addr);
+	pin = get_pin("osc1_out",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(pmic_power_en),vir_addr);
+	pin = get_pin("pmic_power_en",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(rtc_porz),vir_addr);
+	pin = get_pin("rtc_porz",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(rsvd2),vir_addr);
+	pin = get_pin("rsvd2",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(ext_wakeup),vir_addr);
+	pin = get_pin("ext_wakeup",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(enz_kaldo_1p8v),vir_addr);
+	pin = get_pin("enz_kaldo_1p8v",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(usb0_dm),vir_addr);
+	pin = get_pin("usb0_dm",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(usb0_dp),vir_addr);
+	pin = get_pin("usb0_dp",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(usb0_ce),vir_addr);
+	pin = get_pin("usb0_ce",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(usb0_id),vir_addr);
+	pin = get_pin("usb0_id",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(usb0_vbus),vir_addr);
+	pin = get_pin("usb0_vbus",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(usb0_drvvbus),vir_addr);
+	pin = get_pin("usb0_drvvbus",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(usb1_dm),vir_addr);
+	pin = get_pin("usb1_dm",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(usb1_dp),vir_addr);
+	pin = get_pin("usb1_dp",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(usb1_ce),vir_addr);
+	pin = get_pin("usb1_ce",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(usb1_id),vir_addr);
+	pin = get_pin("usb1_id",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(usb1_vbus),vir_addr);
+	pin = get_pin("usb1_vbus",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(usb1_drvvbus),vir_addr);
+	pin = get_pin("usb1_drvvbus",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(ddr_resetn),vir_addr);
+	pin = get_pin("ddr_resetn",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(ddr_csn0),vir_addr);
+	pin = get_pin("ddr_csn0",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(ddr_cke),vir_addr);
+	pin = get_pin("ddr_cke",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(ddr_ck),vir_addr);
+	pin = get_pin("ddr_ck",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(ddr_nck),vir_addr);
+	pin = get_pin("ddr_nck",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(ddr_casn),vir_addr);
+	pin = get_pin("ddr_casn",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(ddr_rasn),vir_addr);
+	pin = get_pin("ddr_rasn",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(ddr_wen),vir_addr);
+	pin = get_pin("ddr_wen",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(ddr_ba0),vir_addr);
+	pin = get_pin("ddr_ba0",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(ddr_ba1),vir_addr);
+	pin = get_pin("ddr_ba1",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(ddr_ba2),vir_addr);
+	pin = get_pin("ddr_ba2",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(ddr_a0),vir_addr);
+	pin = get_pin("ddr_a0",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(ddr_a1),vir_addr);
+	pin = get_pin("ddr_a1",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(ddr_a2),vir_addr);
+	pin = get_pin("ddr_a2",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(ddr_a3),vir_addr);
+	pin = get_pin("ddr_a3",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(ddr_a4),vir_addr);
+	pin = get_pin("ddr_a4",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(ddr_a5),vir_addr);
+	pin = get_pin("ddr_a5",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(ddr_a6),vir_addr);
+	pin = get_pin("ddr_a6",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(ddr_a7),vir_addr);
+	pin = get_pin("ddr_a7",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(ddr_a8),vir_addr);
+	pin = get_pin("ddr_a8",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(ddr_a9),vir_addr);
+	pin = get_pin("ddr_a9",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(ddr_a10),vir_addr);
+	pin = get_pin("ddr_a10",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(ddr_a11),vir_addr);
+	pin = get_pin("ddr_a11",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(ddr_a12),vir_addr);
+	pin = get_pin("ddr_a12",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(ddr_a13),vir_addr);
+	pin = get_pin("ddr_a13",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(ddr_a14),vir_addr);
+	pin = get_pin("ddr_a14",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(ddr_a15),vir_addr);
+	pin = get_pin("ddr_a15",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(ddr_odt),vir_addr);
+	pin = get_pin("ddr_odt",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(ddr_d0),vir_addr);
+	pin = get_pin("ddr_d0",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(ddr_d1),vir_addr);
+	pin = get_pin("ddr_d1",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(ddr_d2),vir_addr);
+	pin = get_pin("ddr_d2",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(ddr_d3),vir_addr);
+	pin = get_pin("ddr_d3",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(ddr_d4),vir_addr);
+	pin = get_pin("ddr_d4",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(ddr_d5),vir_addr);
+	pin = get_pin("ddr_d5",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(ddr_d6),vir_addr);
+	pin = get_pin("ddr_d6",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(ddr_d7),vir_addr);
+	pin = get_pin("ddr_d7",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(ddr_d8),vir_addr);
+	pin = get_pin("ddr_d8",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(ddr_d9),vir_addr);
+	pin = get_pin("ddr_d9",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(ddr_d10),vir_addr);
+	pin = get_pin("ddr_d10",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(ddr_d11),vir_addr);
+	pin = get_pin("ddr_d11",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(ddr_d12),vir_addr);
+	pin = get_pin("ddr_d12",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(ddr_d13),vir_addr);
+	pin = get_pin("ddr_d13",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(ddr_d14),vir_addr);
+	pin = get_pin("ddr_d14",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(ddr_d15),vir_addr);
+	pin = get_pin("ddr_d15",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(ddr_dqm0),vir_addr);
+	pin = get_pin("ddr_dqm0",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(ddr_dqm1),vir_addr);
+	pin = get_pin("ddr_dqm1",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(ddr_dqs0),vir_addr);
+	pin = get_pin("ddr_dqs0",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(ddr_dqsn0),vir_addr);
+	pin = get_pin("ddr_dqsn0",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(ddr_dqs1),vir_addr);
+	pin = get_pin("ddr_dqs1",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(ddr_dqsn1),vir_addr);
+	pin = get_pin("ddr_dqsn1",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(ddr_vref),vir_addr);
+	pin = get_pin("ddr_vref",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(ddr_vtp),vir_addr);
+	pin = get_pin("ddr_vtp",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(ddr_strben0),vir_addr);
+	pin = get_pin("ddr_strben0",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(ddr_strben1),vir_addr);
+	pin = get_pin("ddr_strben1",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(ain7),vir_addr);
+	pin = get_pin("ain7",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(ain6),vir_addr);
+	pin = get_pin("ain6",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(ain5),vir_addr);
+	pin = get_pin("ain5",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(ain4),vir_addr);
+	pin = get_pin("ain4",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(ain3),vir_addr);
+	pin = get_pin("ain3",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(ain2),vir_addr);
+	pin = get_pin("ain2",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(ain1),vir_addr);
+	pin = get_pin("ain1",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(ain0),vir_addr);
+	pin = get_pin("ain0",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(vrefp),vir_addr);
+	pin = get_pin("vrefp",reg_val);
+	prt_to_proc(pin,m);
+
+	reg_val = read_ctr_reg(OFFSET(vrefn),vir_addr);
+	pin = get_pin("vrefn",reg_val);
+	prt_to_proc(pin,m);
+
+}
+
+
+static int ubmc_proc_show(struct seq_file *m,void *v)
+{
+	pin_status* pin;
+	pin = (pin_status *)v;
+    if(pin != NULL)
+    {
+    	pin_ctr_reg_dump(m,g_vir_addr);
+    }
+    return 0;
+}
+static int ubmc_proc_open(struct inode *inode,struct file *file)
+{
+    return single_open(file,ubmc_proc_show,PDE_DATA(inode));
+}
+static const struct file_operations dl_file_ops = {
+    .owner = THIS_MODULE,
+    .open = ubmc_proc_open,
+    .read = seq_read,
+    .llseek = seq_lseek,
+    .release = single_release,
+};
+//static struct proc_dir_entry *root_umbc_mux_dir;
+
+int init_ubmc_pinmux_proc(struct proc_dir_entry *root_umbc_dir )
+{
+    if (!root_umbc_dir)
+    {
+    	printk("root_umbc_dir is NULL \n");
+    	return 1;
+    }
+    g_vir_addr = ioremap(CTRL_BASE,REG_NUM*4);
+    proc_create_data("pin-mux",0644,root_umbc_dir,&dl_file_ops,NULL);
+    return 0;
+
+}
+void exit_ubmc_pinmux_proc(struct proc_dir_entry *root_umbc_mux_dir )
+{
+	iounmap(g_vir_addr);
+	remove_proc_entry("pin-mux",root_umbc_mux_dir);
+}
+
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Silicom Ltd.");
+MODULE_DESCRIPTION("Silicom uBMC SSIF");
+
--- linux-ti2018.02-rc4-int-orig/drivers/i2c/busses/ubmc-muxdump.h	1970-01-01 08:00:00.000000000 +0800
+++ linux-ti2018.02-rc4-int-silicom/drivers/i2c/busses/ubmc-muxdump.h	2020-03-09 10:47:12.014803575 +0800
@@ -0,0 +1,231 @@
+/*
+ * ubmc-muxdump.h
+ *
+ *  Created on: Jun 20, 2018
+ *      Author: jason_zhang
+ */
+
+#ifndef DRIVERS_I2C_BUSSES_UBMC_MUXDUMP_H_
+#define DRIVERS_I2C_BUSSES_UBMC_MUXDUMP_H_
+
+
+struct pad_signals {
+	int gpmc_ad0;
+	int gpmc_ad1;
+	int gpmc_ad2;
+	int gpmc_ad3;
+	int gpmc_ad4;
+	int gpmc_ad5;
+	int gpmc_ad6;
+	int gpmc_ad7;
+	int gpmc_ad8;
+	int gpmc_ad9;
+	int gpmc_ad10;
+	int gpmc_ad11;
+	int gpmc_ad12;
+	int gpmc_ad13;
+	int gpmc_ad14;
+	int gpmc_ad15;
+	int gpmc_a0;
+	int gpmc_a1;
+	int gpmc_a2;
+	int gpmc_a3;
+	int gpmc_a4;
+	int gpmc_a5;
+	int gpmc_a6;
+	int gpmc_a7;
+	int gpmc_a8;
+	int gpmc_a9;
+	int gpmc_a10;
+	int gpmc_a11;
+	int gpmc_wait0;
+	int gpmc_wpn;
+	int gpmc_be1n;
+	int gpmc_csn0;
+	int gpmc_csn1;
+	int gpmc_csn2;
+	int gpmc_csn3;
+	int gpmc_clk;
+	int gpmc_advn_ale;
+	int gpmc_oen_ren;
+	int gpmc_wen;
+	int gpmc_be0n_cle;
+	int lcd_data0;
+	int lcd_data1;
+	int lcd_data2;
+	int lcd_data3;
+	int lcd_data4;
+	int lcd_data5;
+	int lcd_data6;
+	int lcd_data7;
+	int lcd_data8;
+	int lcd_data9;
+	int lcd_data10;
+	int lcd_data11;
+	int lcd_data12;
+	int lcd_data13;
+	int lcd_data14;
+	int lcd_data15;
+	int lcd_vsync;
+	int lcd_hsync;
+	int lcd_pclk;
+	int lcd_ac_bias_en;
+	int mmc0_dat3;
+	int mmc0_dat2;
+	int mmc0_dat1;
+	int mmc0_dat0;
+	int mmc0_clk;
+	int mmc0_cmd;
+	int mii1_col;
+	int mii1_crs;
+	int mii1_rxerr;
+	int mii1_txen;
+	int mii1_rxdv;
+	int mii1_txd3;
+	int mii1_txd2;
+	int mii1_txd1;
+	int mii1_txd0;
+	int mii1_txclk;
+	int mii1_rxclk;
+	int mii1_rxd3;
+	int mii1_rxd2;
+	int mii1_rxd1;
+	int mii1_rxd0;
+	int rmii1_refclk;
+	int mdio_data;
+	int mdio_clk;
+	int spi0_sclk;
+	int spi0_d0;
+	int spi0_d1;
+	int spi0_cs0;
+	int spi0_cs1;
+	int ecap0_in_pwm0_out;
+	int uart0_ctsn;
+	int uart0_rtsn;
+	int uart0_rxd;
+	int uart0_txd;
+	int uart1_ctsn;
+	int uart1_rtsn;
+	int uart1_rxd;
+	int uart1_txd;
+	int i2c0_sda;
+	int i2c0_scl;
+	int mcasp0_aclkx;
+	int mcasp0_fsx;
+	int mcasp0_axr0;
+	int mcasp0_ahclkr;
+	int mcasp0_aclkr;
+	int mcasp0_fsr;
+	int mcasp0_axr1;
+	int mcasp0_ahclkx;
+	int xdma_event_intr0;
+	int xdma_event_intr1;
+	int nresetin_out;
+	int porz;
+	int nnmi;
+	int osc0_in;
+	int osc0_out;
+	int rsvd1;
+	int tms;
+	int tdi;
+	int tdo;
+	int tck;
+	int ntrst;
+	int emu0;
+	int emu1;
+	int osc1_in;
+	int osc1_out;
+	int pmic_power_en;
+	int rtc_porz;
+	int rsvd2;
+	int ext_wakeup;
+	int enz_kaldo_1p8v;
+	int usb0_dm;
+	int usb0_dp;
+	int usb0_ce;
+	int usb0_id;
+	int usb0_vbus;
+	int usb0_drvvbus;
+	int usb1_dm;
+	int usb1_dp;
+	int usb1_ce;
+	int usb1_id;
+	int usb1_vbus;
+	int usb1_drvvbus;
+	int ddr_resetn;
+	int ddr_csn0;
+	int ddr_cke;
+	int ddr_ck;
+	int ddr_nck;
+	int ddr_casn;
+	int ddr_rasn;
+	int ddr_wen;
+	int ddr_ba0;
+	int ddr_ba1;
+	int ddr_ba2;
+	int ddr_a0;
+	int ddr_a1;
+	int ddr_a2;
+	int ddr_a3;
+	int ddr_a4;
+	int ddr_a5;
+	int ddr_a6;
+	int ddr_a7;
+	int ddr_a8;
+	int ddr_a9;
+	int ddr_a10;
+	int ddr_a11;
+	int ddr_a12;
+	int ddr_a13;
+	int ddr_a14;
+	int ddr_a15;
+	int ddr_odt;
+	int ddr_d0;
+	int ddr_d1;
+	int ddr_d2;
+	int ddr_d3;
+	int ddr_d4;
+	int ddr_d5;
+	int ddr_d6;
+	int ddr_d7;
+	int ddr_d8;
+	int ddr_d9;
+	int ddr_d10;
+	int ddr_d11;
+	int ddr_d12;
+	int ddr_d13;
+	int ddr_d14;
+	int ddr_d15;
+	int ddr_dqm0;
+	int ddr_dqm1;
+	int ddr_dqs0;
+	int ddr_dqsn0;
+	int ddr_dqs1;
+	int ddr_dqsn1;
+	int ddr_vref;
+	int ddr_vtp;
+	int ddr_strben0;
+	int ddr_strben1;
+	int ain7;
+	int ain6;
+	int ain5;
+	int ain4;
+	int ain3;
+	int ain2;
+	int ain1;
+	int ain0;
+	int vrefp;
+	int vrefn;
+};
+
+#define PAD_CTRL_BASE	0x800
+#define OFFSET(x)	(unsigned int) (&((struct pad_signals *)\
+                (PAD_CTRL_BASE))->x)
+
+#define PAD_CTRL_MASK 0XFF
+#define REG_NUM sizeof(struct pad_signals)/sizeof(int)
+#define NAME_MAX_SIZE 50
+#define CTRL_BASE 0x44E10000
+int init_ubmc_pinmux_proc(struct proc_dir_entry *root_dir);
+void exit_ubmc_pinmux_proc(struct proc_dir_entry *root_dir);
+#endif /* DRIVERS_I2C_BUSSES_UBMC_MUXDUMP_H_ */
--- linux-ti2018.02-rc4-int-orig/drivers/i2c/busses/ubmc-spi-reg.c	1970-01-01 08:00:00.000000000 +0800
+++ linux-ti2018.02-rc4-int-silicom/drivers/i2c/busses/ubmc-spi-reg.c	2020-03-09 10:47:12.015803574 +0800
@@ -0,0 +1,263 @@
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/slab.h>
+#include <linux/fs.h>
+#include <linux/proc_fs.h>
+#include <linux/seq_file.h>
+#include <linux/mm.h>
+#include <linux/kernel.h>
+#include <net/net_namespace.h>
+#include <asm/io.h>
+#include <linux/string.h>
+
+#define MCSPI0_BASE 0x48030000
+#define MCSPI0_SIZE 0x1a0
+#define BUFF_MAXSIZE 1024
+
+
+struct spi_regs
+{
+	unsigned int spi_reg_adr;
+	unsigned int spi_reg_value;
+	void* spi_io_base_adr;
+	unsigned int spi_offset;
+	char update;
+	char dir;
+};
+struct spi_regs g_spi_reg;
+
+#define CM_PER 0X44E00000
+#define CM_PER_SPI0_CLKCTRL 0X4C
+#define CM_PER_L4LS_CLKSTCTRL 0X0
+static void init_spi_pm(void)
+{
+	unsigned int reg_value;
+	void * io_base;
+	unsigned int mask_value;
+	io_base = ioremap_nocache(CM_PER,sizeof(char)*MCSPI0_SIZE);
+	reg_value = *(volatile unsigned int*)(io_base + CM_PER_L4LS_CLKSTCTRL);
+//	printk("%s CM_PER_L4LS_CLKSTCTRL value is 0x%x BIT 25 is %d \n",__func__,reg_value,(reg_value & 0x1000000)>>25);
+	reg_value = *(volatile unsigned int*)(io_base + CM_PER_SPI0_CLKCTRL);
+//	printk("%s CM_PER_SPI0_CLKCTRL value is 0x%x \n",__func__,reg_value);
+	*(volatile unsigned int*)(io_base + CM_PER_SPI0_CLKCTRL) = 0x02|reg_value;
+//	printk("%s enter value 0x02 to CM_PER_SPI0_CLKCTRL \n",__func__);
+	reg_value = *(volatile unsigned int*)(io_base + CM_PER_SPI0_CLKCTRL);
+//	printk("%s CM_PER_SPI0_CLKCTRL value is 0x%x \n",__func__,reg_value);
+	reg_value = *(volatile unsigned int*)(io_base + CM_PER_L4LS_CLKSTCTRL);
+//	printk("%s CM_PER_L4LS_CLKSTCTRL value is 0x%x BIT 25 is %d \n",__func__,reg_value,(reg_value & 0x1000000)>>25);
+	iounmap(io_base);
+}
+static unsigned int do_read_reg(struct spi_regs * spi_reg)
+{
+    unsigned int value;
+    init_spi_pm();
+    //request_mem_region(MCSPI0_BASE, MCSPI0_SIZE, "REG_MCSPI_SYST");
+	spi_reg->spi_io_base_adr = ioremap_nocache(MCSPI0_BASE,sizeof(char)*MCSPI0_SIZE);
+	//printk("%s step 1 ,spi_reg->spi_io_base_adr is %lx ,spi_reg->spi_offset is 0x%x \n",__func__,spi_reg->spi_io_base_adr,spi_reg->spi_offset);
+	//writel(spi_reg->spi_reg_value,spi_reg->spi_io_base_adr + spi_reg->spi_offset);
+	//printk("%s write reg done \n",__func__);
+	//printk("%s value is 0x%x spi_reg->spi_offset is 0x%x \n",__func__,value,spi_reg->spi_offset);
+	value = readl(spi_reg->spi_io_base_adr + spi_reg->spi_offset);
+	//value = *(volatile unsigned int *)(spi_reg->spi_io_base_adr + spi_reg->spi_offset);
+	//printk("read value 0x%x\n",value);
+	iounmap(spi_reg->spi_io_base_adr);
+	return value;
+}
+
+static int ubmc_spi_reg_proc_show(struct seq_file *m,void *v)
+{
+	unsigned int value = 0,size = 0;
+	char temp_buff[BUFF_MAXSIZE];
+
+	if(g_spi_reg.update & 0x11)
+	{
+		//printk("%s step 1",__func__);
+		value = do_read_reg(& g_spi_reg);
+		//printk("%s step 2",__func__);
+		sprintf(temp_buff,"the offset :0x%x  value:0x%x \n",g_spi_reg.spi_offset,value);
+		size = strlen(temp_buff);
+	}
+	else
+	{
+		//printk("%s step 3",__func__);
+		sprintf(temp_buff,"when you read spi0 reg ,please firstly \n"
+				      "'echo 0x00(offset of reg) > /proc/ubmc/spi-reg ' then "
+						"'echo cat /proc/ubmc/spi-reg' "
+						"and if you want to write the spi reg \n"
+						"'echo 0x00(offset of reg) 0xff(value) > /proc/ubmc/spi-reg ' \n");
+		size = strlen(temp_buff);
+		//printk("%s step 4 size is %d ",__func__,size);
+	}
+	seq_printf(m,temp_buff);
+    return 0;
+}
+
+
+static int ubmc_spi_reg_proc_open(struct inode *inode,struct file *file)
+{
+   return single_open(file,ubmc_spi_reg_proc_show,PDE_DATA(inode));
+}
+static int parse_str(char *str,unsigned int strsize,struct spi_regs * spi_reg)
+{
+	char *curr;
+	char temp[BUFF_MAXSIZE];
+	unsigned char value_num = 0;
+	unsigned int count = 0,value = 0,space_num = 0;
+	curr = str;
+	if (str == NULL)
+	{
+		printk("%s: str is NULL \n", __func__);
+		return -1;
+	}
+	while(count <= strsize )
+	{
+		value = simple_strtoul(str + count,&curr,0);
+		count = curr - str;
+		for(space_num = 0;str[count + space_num] == ' ';space_num++)
+		{
+			if(space_num + count > strsize)
+			{
+				break ;
+			}
+		}
+		count = count + space_num;
+		if(value >= 0)
+		{
+			if(value_num == 0)
+			{
+				if(value > MCSPI0_SIZE)
+				{
+					printk("Write fail ! It is not spi register adr \n");
+					return -1;
+				}
+				spi_reg->spi_offset = value;
+				spi_reg->update = spi_reg->update & 0X01;
+				//is_spi_reg?
+			}
+			else if(value_num == 1)
+			{
+				spi_reg->spi_reg_value = value;
+				spi_reg->update = spi_reg->update | 0X10;
+			}
+			else
+			{
+				break;
+			}
+			value_num++;
+		}
+		else
+		{
+			printk("err : %s %s \n",__func__,str);
+			return -1;
+		}
+
+	}
+	return 0;
+}
+
+static int do_write_reg(struct spi_regs * spi_reg)
+{
+	volatile unsigned int *io_adr;
+	unsigned int offset;
+	//spin_lock
+	spi_reg->spi_io_base_adr = ioremap(MCSPI0_BASE,sizeof(int)*MCSPI0_SIZE);
+	writel(spi_reg->spi_reg_value,spi_reg->spi_io_base_adr + spi_reg->spi_offset);
+	//printk("%s value is 0x%x offset is 0x%x \n",__func__,spi_reg->spi_reg_value,spi_reg->spi_offset);
+	iounmap(spi_reg->spi_io_base_adr);
+
+	//spi_unlock
+}
+int ubmc_spi_reg_proc_write(struct file *file,const char __user *buffer, size_t count, loff_t *pos)
+{
+	unsigned int size = 0, i = 0;
+	int ret = 0;
+	char temp_buff[BUFF_MAXSIZE];
+	memset(temp_buff,0,sizeof(char)*BUFF_MAXSIZE);
+	if (count > BUFF_MAXSIZE)
+	{
+		size = BUFF_MAXSIZE;
+	}
+	else
+	{
+		size = count;
+	}
+	copy_from_user(temp_buff, buffer, size);
+	ret = parse_str(temp_buff,size,& g_spi_reg);
+	if(ret)
+	{
+		printk("%s write spi reg fail \n");
+		return -1;
+	}
+	do_write_reg(&g_spi_reg);
+	return size;
+}
+
+
+int ubmc_spi_reg_proc_read(struct file *file, char __user *buf,size_t count, loff_t *ppos)
+{
+	char temp_buff[BUFF_MAXSIZE];
+	unsigned int size, value;
+	if(count > BUFF_MAXSIZE)
+	{
+		size = BUFF_MAXSIZE;
+	}
+	else
+	{
+		size = count;
+	}
+	printk("count is %d \n",count);
+	if(g_spi_reg.update & 0x11)
+	{
+	//	printk("%s step 1",__func__);
+		value = do_read_reg(& g_spi_reg);
+	//	printk("%s step 2",__func__);
+		sprintf(temp_buff,"the offset :0x%x  value:0x%x",g_spi_reg.spi_offset,value);
+		size = strlen(temp_buff);
+	}
+	else
+	{
+		sprintf(temp_buff,"when you read spi0 reg ,'echo 0x00(adr) > /proc/ubmc/spi-reg ' then "
+				"'echo cat /proc/ubmc/spi-reg' "
+				"and when you write the spi reg 'echo 0x00(adr) 0xff(value) > /proc/ubmc/spi-reg ' \n");
+		size = strlen(temp_buff);
+	}
+	copy_to_user(buf,temp_buff,size);
+	count = count - size;
+	printk("%s step 5",__func__);
+	return size;
+}
+
+static const struct file_operations spi_reg_file_ops = {
+    .owner = THIS_MODULE,
+    .open = ubmc_spi_reg_proc_open,
+    .read = seq_read,//ubmc_spi_reg_proc_read,
+	.write = ubmc_spi_reg_proc_write,
+ //   .llseek = ubmc_spi_reg_proc_lseek,
+ //   .release = ubmc_spi_reg_proc_release,
+};
+
+int init_ubmc_spi_reg(struct proc_dir_entry *root_dir)
+{
+	//root_umbc_spi_reg_dir = proc_mkdir("ubmc",NULL);
+	struct proc_dir_entry* root ;
+	int i = 0 , value = 0;
+	root = root_dir;
+    if (!root)
+    {
+    	printk("%s NO root_dir",__func__);
+		return 1;
+    }
+    else
+    {
+    //	root->read_proc = ubmc_spi_reg_proc_read;
+    //	root->write_proc = ubmc_spi_reg_proc_write;
+    }
+    proc_create_data("spi0-reg",0666,root_dir,&spi_reg_file_ops,NULL);
+    init_spi_pm();
+
+}
+void exit_spi_reg(struct proc_dir_entry *root_dir )
+{
+	remove_proc_entry("spi0-reg",root_dir);
+}
--- linux-ti2018.02-rc4-int-orig/drivers/i2c/busses/ubmc-spi-reg.h	1970-01-01 08:00:00.000000000 +0800
+++ linux-ti2018.02-rc4-int-silicom/drivers/i2c/busses/ubmc-spi-reg.h	2020-03-09 10:47:12.015803574 +0800
@@ -0,0 +1,13 @@
+/*
+ * ubmc-spi-reg.h
+ *
+ *  Created on: Jun 25, 2018
+ *      Author: jason_zhang
+ */
+
+#ifndef DRIVERS_I2C_BUSSES_UBMC_SPI_REG_H_
+#define DRIVERS_I2C_BUSSES_UBMC_SPI_REG_H_
+
+int init_ubmc_spi_reg(struct proc_dir_entry *root_dir);
+void exit_spi_reg(struct proc_dir_entry *root_dir );
+#endif /* DRIVERS_I2C_BUSSES_UBMC_SPI_REG_H_ */
--- linux-ti2018.02-rc4-int-orig/drivers/i2c/busses/ubmc-ipmi-sel.c	1970-01-01 08:00:00.000000000 +0800
+++ linux-ti2018.02-rc4-int-silicom/drivers/i2c/busses/ubmc-ipmi-sel.c	2020-03-09 10:47:12.015803574 +0800
@@ -0,0 +1,83 @@
+/*
+ * ubmc-ipmi-sel.c
+ *
+ *  Created on: Jul 31, 2018
+ *      Author: jason_zhang
+ */
+
+#include "ubmc-ipmi-sel.h"
+#include <linux/list.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/slab.h>
+
+int ubmc_ipmi_add_sel_node(struct ubmc_ipmi_sel_list * sel_list,struct ubmc_ipmi_sel_list *sel_node)
+{
+	struct ubmc_ipmi_sel_list *tmp;
+	tmp = (struct ubmc_ipmi_sel_list *)kmalloc(sizeof(struct ubmc_ipmi_sel_list),GFP_KERNEL);
+	if(tmp == NULL)
+	{
+		printk("malloc fail \n");
+		return -ENOMEM;
+	}
+	memcpy(tmp,sel_node,sizeof(struct ubmc_ipmi_sel_list));
+	list_add_tail(&(tmp->list), &(sel_list->list));
+	return 1;
+}
+
+void ubmc_ipmi_sel_list_init(struct ubmc_ipmi_sel_list * sel_list , unsigned int sel_num)
+{
+	sel_list->sel_entry_max_num = sel_num;
+	INIT_LIST_HEAD(&sel_list->list);
+}
+
+void ubmc_ipmi_set_sel_maxnum(struct ubmc_ipmi_sel_list * sel_list , unsigned int sel_num)
+{
+	sel_list->sel_entry_max_num = sel_num;
+}
+void ubmc_ipmi_sel_list_del(struct ubmc_ipmi_sel_list * sel_list)
+{
+	struct ubmc_ipmi_sel_list *tmp ,*n;
+	list_for_each_entry_safe(tmp,n,&sel_list->list,list)
+	{
+		if(!list_is_last(&tmp->list,&sel_list->list))
+		{
+			list_del(&tmp->list);
+		}
+		else
+		{
+			break;
+		}
+
+	}
+}
+//delete the first node then add a new node when the list is full
+int ubmc_ipmi_del_then_add_node(struct ubmc_ipmi_sel_list * sel_list,struct ubmc_ipmi_sel_list *sel_node)
+{
+	struct ubmc_ipmi_sel_list *tmp ,*n;
+	int ret = 0;
+	list_for_each_entry_safe(tmp,n,&sel_list->list,list)
+	{
+		if(!list_is_last(&tmp->list,&sel_list->list))
+		{
+			//printk("ubmc_ipmi_del_then_add_node : record id is 0x%x \n",tmp->event.record_id);
+			tmp->event.record_id = tmp->event.record_id - 1;
+			if(tmp->event.record_id == 0)
+			{
+				//printk("ubmc_ipmi_del_then_add_node:list_del : record id is %d \n",tmp->event.record_id);
+				list_del(&tmp->list);
+			}
+		}
+		else
+		{
+			tmp->event.record_id = tmp->event.record_id - 1;
+			//printk("ubmc_ipmi_del_then_add_node else: record id is 0x%x \n",tmp->event.record_id);
+			break;
+		}
+
+	}
+	ret = ubmc_ipmi_add_sel_node(sel_list,sel_node);
+	//printk("ubmc_ipmi_del_then_add_node:end: record id is %x \n",sel_node->event.record_id);
+	return ret;
+}
+
--- linux-ti2018.02-rc4-int-orig/drivers/i2c/busses/ubmc-ipmi-sel.h	1970-01-01 08:00:00.000000000 +0800
+++ linux-ti2018.02-rc4-int-silicom/drivers/i2c/busses/ubmc-ipmi-sel.h	2020-03-09 10:47:12.015803574 +0800
@@ -0,0 +1,136 @@
+/*
+ * ubmc-ipmi-sel.h
+ *
+ *  Created on: Jul 25, 2018
+ *      Author: jason_zhang
+ */
+
+#ifndef DRIVERS_I2C_BUSSES_UBMC_IPMI_SEL_H_
+#define DRIVERS_I2C_BUSSES_UBMC_IPMI_SEL_H_
+
+//this file is copied from ipmitool ipmi_sel.h
+#include <linux/types.h>
+#define IPMI_CMD_GET_SEL_INFO		0x40
+#define IPMI_CMD_GET_SEL_ALLOC_INFO	0x41
+#define IPMI_CMD_RESERVE_SEL		0x42
+#define IPMI_CMD_GET_SEL_ENTRY		0x43
+#define IPMI_CMD_ADD_SEL_ENTRY		0x44
+#define IPMI_CMD_PARTIAL_ADD_SEL_ENTRY	0x45
+#define IPMI_CMD_DELETE_SEL_ENTRY	0x46
+#define IPMI_CMD_CLEAR_SEL		0x47
+#define IPMI_CMD_GET_SEL_TIME		0x48
+#define IPMI_CMD_SET_SEL_TIME		0x49
+#define IPMI_CMD_GET_AUX_LOG_STATUS	0x5A
+#define IPMI_CMD_SET_AUX_LOG_STATUS	0x5B
+
+enum {
+	IPMI_EVENT_CLASS_DISCRETE,
+	IPMI_EVENT_CLASS_DIGITAL,
+	IPMI_EVENT_CLASS_THRESHOLD,
+	IPMI_EVENT_CLASS_OEM,
+};
+
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(1)
+#endif
+#if 0
+struct sel_get_rq {
+	uint16_t	reserve_id;
+	uint16_t	record_id;
+	uint8_t	offset;
+	uint8_t	length;
+} ATTRIBUTE_PACKING;
+#endif
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(0)
+#endif
+#define WORDS_BIGENDIAN 0
+struct standard_spec_sel_rec{
+	uint32_t	timestamp;
+	uint16_t	gen_id;
+	uint8_t	evm_rev;
+	uint8_t	sensor_type;
+	uint8_t	sensor_num;
+#if WORDS_BIGENDIAN
+	uint8_t	event_dir  : 1;
+	uint8_t	event_type : 7;
+#else
+	uint8_t	event_type : 7;
+	uint8_t	event_dir  : 1;
+#endif
+#define DATA_BYTE2_SPECIFIED_MASK	0xc0    /* event_data[0] bit mask */
+#define DATA_BYTE3_SPECIFIED_MASK	0x30    /* event_data[0] bit mask */
+#define EVENT_OFFSET_MASK		0x0f    /* event_data[0] bit mask */
+	uint8_t	event_data[3];
+};
+/* Dell Specific MACRO's */
+#define	OEM_CODE_IN_BYTE2		0x80	  /* Dell specific OEM Byte in Byte 2 Mask */
+#define	OEM_CODE_IN_BYTE3		0x20	  /* Dell specific OEM Byte in Byte 3 Mask */
+/* MASK MACROS */
+#define	MASK_LOWER_NIBBLE		0x0F
+#define	MASK_HIGHER_NIBBLE		0xF0
+/*Senosr type Macro's */
+#define	SENSOR_TYPE_MEMORY		0x0C
+#define	SENSOR_TYPE_CRIT_INTR		0x13
+#define	SENSOR_TYPE_EVT_LOG		0x10
+#define	SENSOR_TYPE_SYS_EVENT		0x12
+#define	SENSOR_TYPE_PROCESSOR		0x07
+#define	SENSOR_TYPE_OEM_SEC_EVENT	0xC1
+#define SENSOR_TYPE_VER_CHANGE		0x2B
+#define	SENSOR_TYPE_FRM_PROG		0x0F
+#define	SENSOR_TYPE_WTDOG		0x23
+#define	SENSOR_TYPE_OEM_NFATAL_ERROR	0xC2
+#define	SENSOR_TYPE_OEM_FATAL_ERROR	0xC3
+#define SENSOR_TYPE_TXT_CMD_ERROR	0x20
+#define SENSOR_TYPE_SUPERMICRO_OEM 0xD0
+/* End of Macro for DELL Specific */
+#define SEL_OEM_TS_DATA_LEN		6
+#define SEL_OEM_NOTS_DATA_LEN		13
+struct oem_ts_spec_sel_rec{
+	uint32_t timestamp;
+	uint8_t manf_id[3];
+	uint8_t	oem_defined[SEL_OEM_TS_DATA_LEN];
+};
+
+struct oem_nots_spec_sel_rec{
+	uint8_t oem_defined[SEL_OEM_NOTS_DATA_LEN];
+};
+
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(1)
+#endif
+struct sel_event_record {
+	uint16_t	record_id;
+	uint8_t	record_type;
+	union{
+		struct standard_spec_sel_rec standard_type;
+		struct oem_ts_spec_sel_rec oem_ts_type;
+		struct oem_nots_spec_sel_rec oem_nots_type;
+	} sel_type;
+};
+#ifdef HAVE_PRAGMA_PACK
+#pragma pack(0)
+#endif
+
+struct ipmi_event_sensor_types {
+	uint8_t	code;
+	uint8_t	offset;
+#define ALL_OFFSETS_SPECIFIED  0xff
+	uint8_t   data;
+	const char	* desc;
+};
+
+struct ubmc_ipmi_sel_list
+{
+	struct list_head list;
+	struct sel_event_record event;
+	unsigned int sel_entry_max_num;
+	void *data;
+};
+extern struct ubmc_ipmi_sel_list g_ubmc_ipmi_sel_list;
+void ubmc_ipmi_set_sel_maxnum(struct ubmc_ipmi_sel_list * sel_list , unsigned int sel_num);
+void ubmc_ipmi_sel_list_init(struct ubmc_ipmi_sel_list * sel_list , unsigned int sel_num);
+int ubmc_ipmi_add_sel_node(struct ubmc_ipmi_sel_list * sel_list,struct ubmc_ipmi_sel_list *sel_node);
+void ubmc_ipmi_sel_list_del(struct ubmc_ipmi_sel_list * sel_list);
+int ubmc_ipmi_del_then_add_node(struct ubmc_ipmi_sel_list * sel_list,struct ubmc_ipmi_sel_list *sel_node);
+#endif /* DRIVERS_I2C_BUSSES_UBMC_IPMI_SEL_H_ */
--- linux-ti2018.02-rc4-int-orig/drivers/i2c/busses/ubmc-ipmi-lan.h	1970-01-01 08:00:00.000000000 +0800
+++ linux-ti2018.02-rc4-int-silicom/drivers/i2c/busses/ubmc-ipmi-lan.h	2020-03-09 10:47:12.015803574 +0800
@@ -0,0 +1,49 @@
+/*
+ * ubmc-ipmi-lan.h
+ *
+ *  Created on: Nov 6, 2018
+ *      Author: jason_zhang
+ */
+
+#ifndef DRIVERS_I2C_BUSSES_UBMC_IPMI_LAN_H_
+#define DRIVERS_I2C_BUSSES_UBMC_IPMI_LAN_H_
+
+//This file need to sync with user space ubmc_ipmi_lan.h
+
+#define MAC_SIZE    16
+#define IP_SIZE     16
+#define SUBNET_MASK_SIZE     16
+#define ETH_NAME_SIZE 16
+
+#define IPMI_LAN_ACCESSBIL 1
+#define IPMI_LAN_UNACCESSBIL 0
+
+
+struct ipmi_netinf
+{
+	int id;
+	char eth_name[ETH_NAME_SIZE];
+	char mac_adr[MAC_SIZE];
+	char mac_adr_status;
+	unsigned int ip_adr;
+	char ip_adr_status;
+	unsigned int subnet_mask;
+	char subnet_mask_status;
+	char ip_source;
+	int socket_ctr_fd;
+	char staus;
+	int ipmi_dev_fd;
+
+};
+
+
+struct ubmc_ipmi_lan_s
+{
+    int ipmi_dev_fd;
+	struct ipmi_netinf eth0;
+	struct ipmi_netinf eth1;
+};
+
+void prt_lan_info(struct ubmc_ipmi_lan_s* lan);
+void prt_netinf_info(struct ipmi_netinf* netinf);
+#endif /* DRIVERS_I2C_BUSSES_UBMC_IPMI_LAN_H_ */
--- linux-ti2018.02-rc4-int-orig/drivers/i2c/busses/ubmc-ipmi-lan.c	1970-01-01 08:00:00.000000000 +0800
+++ linux-ti2018.02-rc4-int-silicom/drivers/i2c/busses/ubmc-ipmi-lan.c	2020-03-09 10:47:12.015803574 +0800
@@ -0,0 +1,39 @@
+/*
+ * ubmc-ipmi-lan.c
+ *
+ *  Created on: Nov 6, 2018
+ *      Author: jason_zhang
+ */
+#include <linux/string.h>
+#include "ubmc-ipmi-lan.h"
+#include <linux/printk.h>
+#include <linux/if.h>
+#include <linux/ip.h>
+#include <linux/netdevice.h>
+void prt_lan_info(struct ubmc_ipmi_lan_s* lan)
+{
+
+	 prt_netinf_info(&lan->eth0);
+	 prt_netinf_info(&lan->eth1);
+}
+
+void prt_netinf_info(struct ipmi_netinf* netinf)
+{
+	struct ipmi_netinf tmp;
+	char ip[4];
+	char mask[4];
+	unsigned int net_ip;
+	unsigned int net_mask;
+
+	memcpy(&tmp,netinf,sizeof(struct ipmi_netinf));
+	net_ip = htonl(tmp.ip_adr);
+	net_mask= htonl(tmp.subnet_mask);
+	memcpy(&ip,&net_ip,sizeof(unsigned int ));
+	memcpy(&mask,&net_mask,sizeof(unsigned int));
+	printk("prt_info : net_ip is %x ,net_mask is %x \n",net_ip,net_mask);
+	printk("name is %s \n",tmp.eth_name);
+	printk("ip is %d.%d.%d.%d ,ip state is %d \n",ip[0],ip[1],ip[2],ip[3],tmp.ip_adr_status);
+	printk("mac is %x:%x:%x:%x:%x:%x ,mac state is %d \n",tmp.mac_adr[0],tmp.mac_adr[1],tmp.mac_adr[2],tmp.mac_adr[3],tmp.mac_adr[4],tmp.mac_adr[5],tmp.mac_adr_status);
+	printk("mask is %d.%d.%d.%d ,mask state is %d \n",mask[0],mask[1],mask[2],mask[3],tmp.subnet_mask_status);
+
+}
--- linux-ti2018.02-rc4-int-orig/drivers/i2c/busses/ubmc-ipmi-omap.c	1970-01-01 08:00:00.000000000 +0800
+++ linux-ti2018.02-rc4-int-silicom/drivers/i2c/busses/ubmc-ipmi-omap.c	2020-03-09 10:47:12.015803574 +0800
@@ -0,0 +1,648 @@
+/*
+ * ubmc-i2c-slave.c
+ *
+ *  Created on: May 22, 2018
+ *      Author: jeff_zheng
+ */
+
+#include <linux/mm.h>
+#include <linux/i2c.h>
+#include <linux/init.h>
+#include <linux/list.h>
+#include <linux/mm_types.h>
+#include <linux/module.h>
+#include <linux/spinlock.h>
+#include <linux/sysfs.h>
+#include <linux/wait.h>
+#include <linux/slab.h>
+#include <linux/uaccess.h>
+#include <linux/mm_types.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+
+#include "ubmc-i2c-ipmi.h"
+#include "ubmc-i2c-slave.h"
+
+#define I2C_OMAP_NAME "omap_slave"
+static const uint8_t reg_map_ip_v2[] = {
+	[OMAP_I2C_REV_REG] = 0x04,
+	[OMAP_I2C_IE_REG] = 0x2c,
+	[OMAP_I2C_STAT_REG] = 0x28,
+	[OMAP_I2C_IV_REG] = 0x34,
+	[OMAP_I2C_WE_REG] = 0x34,
+	[OMAP_I2C_SYSS_REG] = 0x90,
+	[OMAP_I2C_BUF_REG] = 0x94,
+	[OMAP_I2C_CNT_REG] = 0x98,
+	[OMAP_I2C_DATA_REG] = 0x9c,
+	[OMAP_I2C_SYSC_REG] = 0x10,
+	[OMAP_I2C_CON_REG] = 0xa4,
+	[OMAP_I2C_OA_REG] = 0xa8,
+	[OMAP_I2C_SA_REG] = 0xac,
+	[OMAP_I2C_PSC_REG] = 0xb0,
+	[OMAP_I2C_SCLL_REG] = 0xb4,
+	[OMAP_I2C_SCLH_REG] = 0xb8,
+	[OMAP_I2C_SYSTEST_REG] = 0xbC,
+	[OMAP_I2C_BUFSTAT_REG] = 0xc0,
+	[OMAP_I2C_IP_V2_REVNB_LO] = 0x00,
+	[OMAP_I2C_IP_V2_REVNB_HI] = 0x04,
+	[OMAP_I2C_IP_V2_IRQSTATUS_RAW] = 0x24,
+	[OMAP_I2C_IP_V2_IRQENABLE_SET] = 0x2c,
+	[OMAP_I2C_IP_V2_IRQENABLE_CLR] = 0x30,
+};
+
+static void __ubmc_i2c_irq_stats_dump(uint16_t stat)
+{
+	char buf[128];
+	uint16_t loc = 0;
+
+	buf[0] = 0;
+	if (stat & OMAP_I2C_IE_XDR)
+		loc+=sprintf(buf+loc, "XDR |");
+	if (stat & OMAP_I2C_IE_RDR)
+		loc+=sprintf(buf+loc, "RDR |");
+	if (stat & OMAP_I2C_IE_BB)
+		loc+=sprintf(buf+loc, "BB  |");
+	if (stat & OMAP_I2C_IE_ROVR)
+		loc+=sprintf(buf+loc, "ROVR|");
+	if (stat & OMAP_I2C_IE_XUDF)
+		loc+=sprintf(buf+loc, "XUDF|");
+	if (stat & OMAP_I2C_IE_AAS)
+		loc+=sprintf(buf+loc, "AAS |");
+	if (stat & OMAP_I2C_IE_BF)
+		loc+=sprintf(buf+loc, "BF  |");
+	if (stat & OMAP_I2C_IE_AERR)
+		loc+=sprintf(buf+loc, "AERR|");
+	if (stat & OMAP_I2C_IE_STC)
+		loc+=sprintf(buf+loc, "STC |");
+	if (stat & OMAP_I2C_IE_GC)
+		loc+=sprintf(buf+loc, "GC  |");
+	if (stat & OMAP_I2C_IE_XRDY)
+		loc+=sprintf(buf+loc, "XRDY|");
+	if (stat & OMAP_I2C_IE_RRDY)
+		loc+=sprintf(buf+loc, "RRDY|");
+	if (stat & OMAP_I2C_IE_ARDY)
+		loc+=sprintf(buf+loc, "ARDY|");
+	if (stat & OMAP_I2C_IE_NACK)
+		loc+=sprintf(buf+loc, "NACK|");
+	if (stat & OMAP_I2C_IE_AL)
+		loc+=sprintf(buf+loc, "AL  |");
+	printk(KERN_WARNING "%s\n", buf);
+
+}
+
+#define ubmc_i2c_irq_stats_dump(stat)	\
+	do { if (ubmc_debug_enable) { __ubmc_i2c_irq_stats_dump(stat); }} while(0)
+
+#if 0
+#define ubmc_i2c_print_hex_dump(...)	\
+	do { if (ubmc_debug_enable) { print_hex_dump(KERN_DEBUG, ## __VA_ARGS__ ); }} while(0)
+#else
+#define ubmc_i2c_print_hex_dump(...)	\
+	do { print_hex_dump(KERN_DEBUG, ## __VA_ARGS__ ); } while(0)
+#endif
+
+
+static inline void ubmc_i2c_write_reg(struct ubmc_i2c_slave_dev *i2c_dev,
+				      int reg, uint16_t val)
+{
+	writew_relaxed(val, i2c_dev->base + reg_map_ip_v2[reg]);
+}
+
+static inline uint16_t ubmc_i2c_read_reg(struct ubmc_i2c_slave_dev *i2c_dev, int reg)
+{
+	return readw_relaxed(i2c_dev->base + reg_map_ip_v2[reg]);
+}
+
+static inline void ubmc_i2c_irq_stat_ack(struct ubmc_i2c_slave_dev *dev, uint16_t stat)
+{
+	ubmc_i2c_write_reg(dev, OMAP_I2C_STAT_REG, stat);
+}
+
+
+static inline void ubmc_i2c_client_reset_receive_buf(struct ubmc_i2c_slave_dev *dev)
+{
+	memset(dev->rx_msg_buf, 0, sizeof(dev->rx_msg_buf));
+	dev->rx_msg_idx = 0;
+}
+
+static void ubmc_i2c_receive_data_multi(struct ubmc_i2c_slave_dev *dev)
+{
+	uint16_t w;
+	uint16_t num_bytes = 0;
+
+
+	num_bytes = (ubmc_i2c_read_reg(dev,
+		OMAP_I2C_BUFSTAT_REG) >> 8) & 0x3F;
+	ubmc_debug("Receiving %u bytes, from idx %u, DCOUNT %u" , num_bytes, dev->rx_msg_idx,
+			ubmc_i2c_read_reg(dev, OMAP_I2C_CNT_REG) &0XFFFF);
+	while (num_bytes--)
+	{
+		w = ubmc_i2c_read_reg(dev, OMAP_I2C_DATA_REG);
+
+		/* make sure writes to dev->buf_len are ordered */
+		dev->rx_msg_buf[dev->rx_msg_idx] = w;
+		dev->rx_msg_idx ++;
+
+		if (dev->rx_msg_idx >= SSIF_REQ_BUF_SIZE)
+		{
+			ubmc_error("i2c receive buffer wrap, not suppose to happen!!!!!!!");
+			dev->rx_msg_idx = 0;
+			break;
+		}
+	}
+}
+static int __ubmc_i2c_slave_write_buf(struct ubmc_i2c_slave_dev *dev, uint8_t* buf, uint8_t num_bytes)
+{
+	uint16_t		idx;
+	uint16_t		tx_fifo_size;
+	tx_fifo_size = (ubmc_i2c_read_reg(dev, OMAP_I2C_BUFSTAT_REG) ) & 0x3F;
+	ubmc_debug("tx fifo size %u", tx_fifo_size);
+	//this print hex dump can't be removed right now, there seems to be a timing issue for interrupt handling
+	//removing this will cause the system to hang.
+	if(ubmc_debug_enable)
+		print_hex_dump(KERN_DEBUG, "SSIF MSG TX:", DUMP_PREFIX_OFFSET, 16, 1, buf, num_bytes, false);
+
+	for(idx = 0; idx<num_bytes; idx++)
+	{
+		ubmc_i2c_write_reg(dev, OMAP_I2C_DATA_REG, buf[idx]);
+	}
+
+	tx_fifo_size = (ubmc_i2c_read_reg(dev, OMAP_I2C_BUFSTAT_REG) ) & 0x3F;
+	ubmc_debug("tx fifo size %u after", tx_fifo_size);
+	return num_bytes;
+}
+
+
+static void ubmc_i2c_resize_fifo_thresh(struct ubmc_i2c_slave_dev *dev, uint8_t size, bool is_rx)
+{
+#if 0
+	uint16_t		buf_reg_val;
+
+	/*
+	 * Set up notification threshold based on message size. We're doing
+	 * this to try and avoid draining feature as much as possible. Whenever
+	 * we have big messages to transfer (bigger than our total fifo size)
+	 * then we might use draining feature to transfer the remaining bytes.
+	 */
+
+	dev->threshold = clamp(size, (uint8_t) 1, dev->fifo_size);
+	ubmc_debug("threshold set to %d",dev->threshold);
+	buf_reg_val = ubmc_i2c_read_reg(dev, OMAP_I2C_BUF_REG);
+
+	if (is_rx) {
+		/* Clear RX Threshold */
+		buf_reg_val &= ~(0x3f << 8);
+		buf_reg_val |= ((dev->threshold - 1) << 8) | OMAP_I2C_BUF_RXFIF_CLR;
+	} else {
+		/* Clear TX Threshold */
+		buf_reg_val &= ~0x3f;
+		buf_reg_val |= (dev->threshold - 1) | OMAP_I2C_BUF_TXFIF_CLR;
+	}
+
+	ubmc_i2c_write_reg(dev, OMAP_I2C_BUF_REG, buf_reg_val);
+#else
+	uint16_t thresh, buf_reg_val;
+	if( size <= dev->fifo_size)
+	{
+		thresh = size;
+	}
+	else
+	{
+		thresh = dev->fifo_size/2;
+	}
+	ubmc_debug("TX threshold set to %d", thresh);
+	buf_reg_val = ubmc_i2c_read_reg(dev, OMAP_I2C_BUF_REG);
+	buf_reg_val &= ~0x3f;
+	buf_reg_val |= (thresh - 1) | OMAP_I2C_BUF_TXFIF_CLR;
+	ubmc_i2c_write_reg(dev, OMAP_I2C_BUF_REG, buf_reg_val);
+#endif
+
+}
+
+
+
+// use to check whether the ssif message in the active buffer
+// is a compete or not .
+// if it is a complete message , push it into the requests queue
+static bool ubmc_ssif_is_complete_req_msg(uint8_t* p_rx_msg, uint16_t rx_msg_len)
+{
+	uint8_t index = 0;
+	bool has_found = false;
+	struct ipmi_ssif_req *req = NULL;
+
+	if(rx_msg_len == 0)
+		return false;
+
+	// IPMI request message must begin with SSIF_IPMI_REQUEST(0x02) and end with the SSIF_IPMI_RESPONSE(0x03)
+	// For example : 0x02 0x02 0x18 0x01 0x03
+	if (p_rx_msg[0] == SSIF_IPMI_REQUEST && rx_msg_len > 3 &&p_rx_msg[rx_msg_len - 1] == SSIF_IPMI_RESPONSE)
+	{
+		req = (struct ipmi_ssif_req *)(p_rx_msg);
+		if( rx_msg_len >= req->len + 2 &&
+				p_rx_msg[req->len + 2] == SSIF_IPMI_RESPONSE )
+		{
+			return true;
+		}
+	}
+	// if it is a IPMI request message . it must begin with
+	// the SSIF_IPMI_RESPONSE(0x03) .
+	if( p_rx_msg[0] == SSIF_IPMI_RESPONSE && rx_msg_len > 1 ) //rx_msg_len need to > 1 to differ from i2cget 0x03
+	{
+		for(index=0;index<rx_msg_len;index++)
+		{
+			if( p_rx_msg[index] != SSIF_IPMI_RESPONSE)
+			{
+				has_found = true;
+				break;
+			}
+		}
+		// found all is the SSIF_IPMI_RESPONSE(0x03) byte.
+		if( !has_found && index == rx_msg_len )
+		{
+			return true;
+		}
+	}
+
+	return false;
+}
+
+static void ubmc_i2c_slave_send_current_buf(struct ubmc_i2c_slave_dev* dev)
+{
+	uint8_t num_bytes = dev->tx_msg_len;
+	uint16_t w = 0;
+
+	dev->tx_msg_idx = 0;
+	ubmc_debug("Start TX, len %u", num_bytes);
+
+	// set the fifo length
+//	ubmc_i2c_resize_fifo_thresh(dev, num_bytes, false);
+
+	/* make sure writes to dev->buf_len are ordered */
+	barrier();
+
+	/* Clear the FIFO Buffers */
+	w = ubmc_i2c_read_reg(dev, OMAP_I2C_BUF_REG);
+	w |= OMAP_I2C_BUF_RXFIF_CLR | OMAP_I2C_BUF_TXFIF_CLR;
+
+	ubmc_i2c_write_reg(dev, OMAP_I2C_BUF_REG, w);
+
+	if(num_bytes > dev->fifo_size)
+	{
+		num_bytes = dev->fifo_size/2 + 8;
+	}
+
+	dev->tx_msg_idx += __ubmc_i2c_slave_write_buf(dev, dev->tx_msg_buf + dev->tx_msg_idx, num_bytes);
+
+	if(dev->tx_msg_idx >= dev->tx_msg_len)
+	{
+		//finished tx, set len to 0, so tx continue logic will not be triggered
+		dev->tx_msg_len = 0;
+		ubmc_debug("Finished tx");
+		return;
+	}
+	return;
+}
+
+static void ubmc_i2c_slave_send_current_buf_continue(struct ubmc_i2c_slave_dev* dev)
+{
+//	uint16_t w = 0;
+	uint8_t num_bytes = dev->tx_msg_len - dev->tx_msg_idx;
+
+	if(num_bytes == 0)
+	{
+		ubmc_error("Unexpected tx continue, rsp_len %u rsp_buf_idx %u", dev->tx_msg_len, dev->tx_msg_idx);
+		return;
+	}
+
+	ubmc_debug("Finishing TX, len %u, continue from %u", num_bytes, dev->tx_msg_idx);
+#if 0
+	// set the fifo length
+	ubmc_i2c_resize_fifo_thresh(dev, num_bytes, false);
+
+	/* make sure writes to dev->buf_len are ordered */
+	barrier();
+
+	/* Clear the FIFO Buffers */
+	w = ubmc_i2c_read_reg(dev, OMAP_I2C_BUF_REG);
+	w |= OMAP_I2C_BUF_RXFIF_CLR | OMAP_I2C_BUF_TXFIF_CLR;
+	ubmc_i2c_write_reg(dev, OMAP_I2C_BUF_REG, w);
+
+	if (dev->threshold){
+		num_bytes = dev->threshold;
+	}
+
+#endif
+	dev->tx_msg_idx += __ubmc_i2c_slave_write_buf(dev, dev->tx_msg_buf + dev->tx_msg_idx, num_bytes);
+//	dev->threshold = 0;
+
+	if(dev->tx_msg_idx >= dev->tx_msg_len)
+	{
+		dev->tx_msg_len = 0;
+		ubmc_debug("Finished tx");
+		return;
+	}
+	return;
+}
+
+
+
+static irqreturn_t ubmc_i2c_slave_irq_handle(int this_irq, void *dev_id)
+{
+
+	uint16_t bits;
+	uint16_t stat;
+	uint16_t num_bytes;
+	char w;
+	int i = 0;
+	num_bytes = 32;
+
+	unsigned long flags = 0;
+	struct ubmc_i2c_slave_dev *dev = (struct ubmc_i2c_slave_dev *)dev_id;
+	spin_lock_irqsave(&dev->lock, flags);
+	do {
+		//irq enable
+		bits = ubmc_i2c_read_reg(dev, OMAP_I2C_IE_REG);
+		//irq tatus
+		stat = ubmc_i2c_read_reg(dev, OMAP_I2C_STAT_REG);
+		//ubmc_i2c_irq_stats_dump(stat);
+		//__ubmc_i2c_irq_stats_dump(stat);
+		if( stat == 0 ){
+			// to check if it is a complete ssif message
+			ubmc_error("interrupt with stat 0");
+		}
+		if( stat & OMAP_I2C_STAT_NACK)
+		{
+		}
+		if( stat & OMAP_I2C_STAT_AAS )
+		{
+		}
+		if( stat & OMAP_I2C_STAT_BF )
+		{
+		}
+		if( stat & OMAP_I2C_STAT_ROVR )
+		{
+
+		//	num_bytes = (ubmc_i2c_read_reg(dev,
+		//			OMAP_I2C_BUFSTAT_REG) >> 8) & 0x3F;
+			ubmc_error("interrupt with OMAP_I2C_STAT_ROVR num_bytes is %d \n",num_bytes);
+			while (num_bytes--)
+			{
+				w = ubmc_i2c_read_reg(dev, OMAP_I2C_DATA_REG);
+
+				/* make sure writes to dev->buf_len are ordered */
+				dev->rx_msg_buf[dev->rx_msg_idx] = w;
+				dev->rx_msg_idx ++;
+
+				if (dev->rx_msg_idx >= SSIF_REQ_BUF_SIZE)
+				{
+					ubmc_error("i2c receive buffer wrap, not suppose to happen!!!!!!!");
+					dev->rx_msg_idx = 0;
+					break;
+				}
+			}
+		}
+#if 0
+		if( stat & OMAP_I2C_STAT_RRDY )
+		{
+			ubmc_i2c_receive_data_byte(dev);
+		}
+#endif
+		if( stat & OMAP_I2C_STAT_XRDY )
+		{//i2c master is expecting we sent something,
+			if(dev->tx_msg_len)
+			{
+#if 1
+				ubmc_error("not continue yet, as we have problem with this still");
+#else
+				ubmc_i2c_slave_send_current_buf_continue(dev);
+#endif
+				dev->tx_msg_len = 0;
+			}
+			else
+			{
+				ubmc_i2c_receive_data_multi(dev);
+			/*	for(i=0;i < dev->rx_msg_idx;i ++)
+				{
+					printk("%x\n",dev->rx_msg_buf[i]);
+				}*/
+				if(ubmc_ssif_is_complete_req_msg(dev->rx_msg_buf, dev->rx_msg_idx))
+				{
+					if( ubmc_i2c_slave_ssif_req_handle(&g_ubmc_ipmi_pdev, dev->rx_msg_buf, dev->rx_msg_idx, dev->tx_msg_buf, &dev->tx_msg_len) == BMC_OK )
+					{
+						dev->tx_msg_ready = true;
+						ubmc_i2c_client_reset_receive_buf(dev);
+					}
+					else
+					{
+						ubmc_i2c_client_reset_receive_buf(dev);
+
+						dev->tx_msg_buf[0] = 0x03;
+						dev->tx_msg_buf[1] = 0x81;
+						dev->tx_msg_buf[2] = 0x81;
+						dev->tx_msg_buf[3] = 0x81;
+						dev->tx_msg_len = 4;
+
+						//clear tx buf
+						ubmc_i2c_slave_send_current_buf(dev);
+						ubmc_i2c_irq_stat_ack(dev,stat & bits);
+						break;
+					}
+
+				}
+				else
+				{
+					ubmc_error("Invalid rx message \n");
+				/*	printk("rcv:len is %d ts_len is %d \n",dev->rx_msg_idx,dev->tx_msg_len);
+					for(i=0;i < dev->rx_msg_idx;i ++)
+					{
+						printk("\n %x \n",dev->rx_msg_buf[i]);
+					}*/
+					ubmc_i2c_client_reset_receive_buf(dev);
+					//response_ipmi_error_request(dev, dev->tx_msg_buf, &dev->tx_msg_len);
+					//dev->tx_msg_buf[0] = 0x00;
+					//dev->tx_msg_len = 1;
+					dev->tx_msg_buf[0] = 0x03;
+					dev->tx_msg_buf[1] = 0x81;
+					dev->tx_msg_buf[2] = 0x81;
+					dev->tx_msg_buf[3] = 0x81;
+					dev->tx_msg_len = 4;
+
+					//clear tx buf
+
+					ubmc_i2c_slave_send_current_buf(dev);
+					dev->tx_msg_ready = false;
+					//dev->tx_msg_ready = false;
+					ubmc_i2c_irq_stat_ack(dev,stat & bits);
+					//stat = ubmc_i2c_read_reg(dev, OMAP_I2C_STAT_REG);
+					//ubmc_i2c_irq_stats_dump(stat);
+					break;
+				}
+				// try to parse_i2c_slave_msg
+				if(dev->tx_msg_ready)
+				{
+					dev->tx_msg_ready = false;
+					if(dev->tx_msg_len)
+					{
+						//send current tx,
+						//the function set tx_msg_len to 0 if all is transmitted
+						//otherwise, the continue function needs to be called
+						ubmc_i2c_slave_send_current_buf(dev);
+						/* make sure writes to dev->buf_len are ordered */
+						ubmc_i2c_irq_stat_ack(dev,stat & bits);
+						break;
+					}
+					else
+					{
+						ubmc_error("Invalid tx message length 0");
+					}
+				}
+			}
+
+		}
+		if (stat & OMAP_I2C_STAT_XUDF) {
+			//tx overflow
+#if 0
+			if(dev->tx_msg_len)
+			{
+				//we don't care whether rest is sent successfully or not
+				//we only continue it once.
+
+#if 0
+				ubmc_error("not continue yet, as we have problem with this still");
+#else
+				ubmc_i2c_slave_send_current_buf_continue(dev);
+#endif
+				dev->tx_msg_len = 0;
+				barrier();
+			}
+#endif
+		}
+		ubmc_i2c_irq_stat_ack(dev,stat & bits);
+
+	} while (0);
+
+	spin_unlock_irqrestore(&dev->lock, flags);
+
+	return IRQ_HANDLED;
+}
+
+/**
+ * OMAP i2c slave mode,
+ * We don't actuall need RRDY int, when there's an incoming request from the master,
+ * the fifo will hold the data, giving it is less then 32 bytes, and then when the i2c logic is ready
+ * send response to the master, an XRDY int will be generated.
+ * We can read the complete receive message in XRDY int.
+ */
+static void ubmc_i2c_slave_mode_setup(struct ubmc_i2c_slave_dev *dev)
+{
+	uint16_t s;
+
+	/* Set up the fifo size - Get total size */
+	s = (ubmc_i2c_read_reg(dev, OMAP_I2C_BUFSTAT_REG) >> 14) & 0x3;
+	dev->fifo_size = 0x8 << s;
+
+	// init the default threshold value as 0x00 ,Otherwise there might be a random value.
+//	dev->threshold = 0x00;
+	/*
+	 * Set up notification threshold as half the total available
+	 * size. This is to ensure that we can handle the status on int
+	 * call back latencies.
+	 */
+
+	//dev->fifo_size = (dev->fifo_size / 2);
+	// reset the i2c module
+	ubmc_i2c_write_reg(dev,OMAP_I2C_CON_REG,
+			ubmc_i2c_read_reg(dev,OMAP_I2C_CON_REG) &~OMAP_I2C_CON_EN);
+	ubmc_i2c_write_reg(dev,OMAP_I2C_SYSC_REG,OMAP_I2C_SYST_RESET);
+
+	ubmc_i2c_write_reg(dev,OMAP_I2C_OA_REG,0X42);
+	/* SCL low and high time values */
+	ubmc_i2c_write_reg(dev,OMAP_I2C_SCLL_REG,0x00);
+	ubmc_i2c_write_reg(dev,OMAP_I2C_SCLH_REG,0x00);
+
+	//Clear all enabled int
+	ubmc_i2c_write_reg(dev,OMAP_I2C_IP_V2_IRQENABLE_CLR,
+						OMAP_I2C_IE_AERR|OMAP_I2C_IE_XDR|OMAP_I2C_IE_XUDF|
+						OMAP_I2C_IE_RRDY|
+						OMAP_I2C_IE_XRDY|OMAP_I2C_IE_GC|
+						OMAP_I2C_IE_AAS|OMAP_I2C_IE_BF);
+
+	ubmc_i2c_write_reg(dev,OMAP_I2C_IE_REG,
+//			OMAP_I2C_IE_XDR|
+//			OMAP_I2C_IE_RRDY|OMAP_I2C_IE_XUDF|
+			OMAP_I2C_IE_ROVR|
+			OMAP_I2C_IE_XRDY|OMAP_I2C_IE_GC|
+			OMAP_I2C_IE_AAS|OMAP_I2C_IE_BF);
+
+//	s = ubmc_i2c_read_reg(dev,OMAP_I2C_IE_REG);
+//	ubmc_debug("Enabled Interrupt after");
+//	ubmc_i2c_irq_stats_dump(s);
+
+
+	ubmc_i2c_write_reg(dev,OMAP_I2C_WE_REG,OMAP_I2C_WE_ALL);
+
+	/* clear current interruts...*/
+	ubmc_i2c_write_reg (dev,OMAP_I2C_STAT_REG,0xFFFF);
+	// enable i2c module
+	ubmc_i2c_write_reg(dev,OMAP_I2C_CON_REG,OMAP_I2C_CON_EN);
+
+	// set the fifo length
+	ubmc_i2c_resize_fifo_thresh(dev, 13, false);
+}
+
+
+static void ubmc_i2c_slave_init_enable_i2c2_clkctrl( struct ubmc_i2c_slave_dev *i2c_dev )
+{
+	if( readw_relaxed(i2c_dev->cm_per_base + CM_PER_I2C2_CLKCTRL) != 0x02 ){
+		writew_relaxed(0x02, i2c_dev->cm_per_base + CM_PER_I2C2_CLKCTRL);
+	}
+}
+
+int ubmc_omap_slave_init(void *dev)
+{
+	int rc;
+	struct ubmc_i2c_slave_dev* p_dev = dev;
+
+	memset(p_dev, 0, sizeof(*p_dev));
+
+	spin_lock_init(&p_dev->lock);
+	p_dev->irq = INT_OMAP_I2C_IRQ ;
+	p_dev->cm_per_base = ioremap(OMAP_CM_PER_BASE, OMAP_CM_PER_MEM_SIZE);
+	if (IS_ERR(p_dev->cm_per_base))
+			return PTR_ERR(p_dev->cm_per_base);
+	strcpy(p_dev->name,I2C_OMAP_NAME);
+	p_dev->base = ioremap(I2C1_START_PHY_ADDR, IORESOURCE_MEM_SIZE);
+	if (IS_ERR(p_dev->base))
+		return PTR_ERR(p_dev->base);
+
+	ubmc_i2c_slave_init_enable_i2c2_clkctrl(p_dev);
+
+	//important to have a short sleep here, otherwise the i2c hw is not fully initialized, and might give
+	//and exception of "external abort on non-linefetch"
+	//ubmc_debug("Initializing i2c-1 as slave");
+	schedule_timeout(1);
+
+	ubmc_i2c_slave_mode_setup(p_dev);
+	rc = request_irq(p_dev->irq, &ubmc_i2c_slave_irq_handle,IRQF_SHARED, "i2c_slave", p_dev);
+	if ( rc ) {
+		ubmc_error("Could not assign IRQ handler to irq %d rc %d !\n",p_dev->irq,rc);
+		return -1;
+	}
+
+
+
+	return 0;
+}
+
+void ubmc_omap_slave_deinit(void *dev)
+{
+	struct ubmc_i2c_slave_dev* p_dev = dev;
+
+	free_irq(p_dev->irq, p_dev);
+	if(p_dev->cm_per_base)
+		iounmap(p_dev->cm_per_base);
+	if(p_dev->base)
+		iounmap(p_dev->base);
+
+}
+
--- linux-ti2018.02-rc4-int-orig/drivers/i2c/busses/ubmc-ipmi-pxa.c	1970-01-01 08:00:00.000000000 +0800
+++ linux-ti2018.02-rc4-int-silicom/drivers/i2c/busses/ubmc-ipmi-pxa.c	2020-03-09 10:47:12.015803574 +0800
@@ -0,0 +1,644 @@
+/*
+ * ubmc_ipmi_pxa.c
+ *
+ *  Created on: Sep 11, 2019
+ *      Author: jason_zhang
+ */
+
+#include <linux/mm.h>
+#include <linux/i2c.h>
+#include <linux/init.h>
+#include <linux/list.h>
+#include <linux/mm_types.h>
+#include <linux/module.h>
+#include <linux/spinlock.h>
+#include <linux/sysfs.h>
+#include <linux/wait.h>
+#include <linux/slab.h>
+#include <linux/uaccess.h>
+#include <linux/mm_types.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/delay.h>
+#include <linux/i2c/pxa-i2c.h>
+#include "i2c-pxa.h"
+#include "ubmc-i2c-ipmi.h"
+#include "ubmc-i2c-slave.h"
+
+#define I2C_PXA_NAME "pxa_slave"
+static void __pxa_i2c_irq_stats_dump(uint32_t stat)
+{
+	char buf[128];
+	uint16_t loc = 0;
+
+	buf[0] = 0;
+	if (stat & ISR_SAD)
+		loc+=sprintf(buf+loc, "ISR_SAD |");
+	if (stat & ISR_BED)
+		loc+=sprintf(buf+loc, "ISR_BED |");
+	if (stat & ISR_GCAD)
+		loc+=sprintf(buf+loc, "ISR_GCAD |");
+	if (stat & ISR_ITE)
+		loc+=sprintf(buf+loc, "ISR_ITE |");
+	if (stat & ISR_IRF)
+		loc+=sprintf(buf+loc, "ISR_IRF |");
+	if (stat & ISR_ALD)
+		loc+=sprintf(buf+loc, "ISR_ALD |");
+	if (stat & ISR_SSD)
+		loc+=sprintf(buf+loc, "ISR_SSD |");
+	if (stat & ISR_IBB)
+		loc+=sprintf(buf+loc, "ISR_IBB|");
+	if (stat & ISR_UB)
+		loc+=sprintf(buf+loc, "ISR_UB |");
+	if (stat & ISR_ACKNAK)
+		loc+=sprintf(buf+loc, "ISR_ACKNAK |");
+	if (stat & ISR_RWM)
+		loc+=sprintf(buf+loc, "ISR_RWM |");
+	/*
+	if (stat & OMAP_I2C_IE_RRDY)
+		loc+=sprintf(buf+loc, "RRDY|");
+	if (stat & OMAP_I2C_IE_ARDY)
+		loc+=sprintf(buf+loc, "ARDY|");
+	if (stat & OMAP_I2C_IE_NACK)
+		loc+=sprintf(buf+loc, "NACK|");
+	if (stat & OMAP_I2C_IE_AL)
+		loc+=sprintf(buf+loc, "AL  |");
+		*/
+	printk(KERN_WARNING "%s\n", buf);
+
+}
+#define pxa_i2c_irq_stats_dump(stat)	\
+	do { if (ubmc_debug_enable) { __pxa_i2c_irq_stats_dump(stat); }} while(0)
+
+/*common */
+static inline void ubmc_i2c_client_reset_receive_buf(struct ubmc_i2c_slave_dev *dev)
+{
+	memset(dev->rx_msg_buf, 0, sizeof(dev->rx_msg_buf));
+	dev->rx_msg_idx = 0;
+}
+
+
+
+
+// use to check whether the ssif message in the active buffer
+// is a compete or not .
+// if it is a complete message , push it into the requests queue
+static bool ubmc_ssif_is_complete_req_msg(uint8_t* p_rx_msg, uint16_t rx_msg_len)
+{
+	uint8_t index = 0;
+	bool has_found = false;
+	struct ipmi_ssif_req *req = NULL;
+
+	if(rx_msg_len == 0)
+		return false;
+
+	// IPMI request message must begin with SSIF_IPMI_REQUEST(0x02) and end with the SSIF_IPMI_RESPONSE(0x03)
+	// For example : 0x02 0x02 0x18 0x01 0x03
+	if (p_rx_msg[0] == SSIF_IPMI_REQUEST && rx_msg_len > 3)
+	{
+		req = (struct ipmi_ssif_req *)(p_rx_msg);
+		if( rx_msg_len >= req->len + 2 &&
+				p_rx_msg[req->len + 2] == SSIF_IPMI_RESPONSE )
+		{
+			return true;
+		}
+	}
+	// if it is a IPMI request message . it must begin with
+	// the SSIF_IPMI_RESPONSE(0x03) .
+	if( p_rx_msg[0] == SSIF_IPMI_RESPONSE && rx_msg_len > 1 ) //rx_msg_len need to > 1 to differ from i2cget 0x03
+	{
+		for(index=0;index<rx_msg_len;index++)
+		{
+			if( p_rx_msg[index] != SSIF_IPMI_RESPONSE)
+			{
+				has_found = true;
+				break;
+			}
+		}
+		// found all is the SSIF_IPMI_RESPONSE(0x03) byte.
+		if( !has_found && index == rx_msg_len )
+		{
+			return true;
+		}
+	}
+
+	return false;
+}
+
+
+
+/********************************Below depend on i2c controller*******************************************************/
+
+#define VALID_INT_SOURCE	(ISR_SSD | ISR_ALD | ISR_ITE | ISR_IRF | \
+				ISR_SAD | ISR_BED | ISR_RXSR | ISR_TXSR)
+static inline int i2c_pxa_is_slavemode(struct ubmc_i2c_slave_dev *dev)
+{
+	return !(readl(_ICR(dev)) & ICR_SCLE);
+}
+
+static void i2c_pxa_slave_start(struct ubmc_i2c_slave_dev *dev, unsigned int  isr)
+{
+	int timeout;
+
+	//if (i2c_debug > 0)
+	//	printk("SAD, mode is slave-%cx\n",(isr & ISR_RWM) ? 'r' : 't');
+
+	/*
+	 * slave could interrupt in the middle of us generating a
+	 * start condition... if this happens, we'd better back off
+	 * and stop holding the poor thing up
+	 */
+	writel(readl(_ICR(dev)) & ~(ICR_START|ICR_STOP), _ICR(dev));
+#if 1
+	if((isr & ISR_RWM) == 0)
+	{
+	writel(readl(_ICR(dev)) | ICR_TB, _ICR(dev));
+	timeout = 0x10000;
+
+	while (1) {
+		if ((readl(_IBMR(dev)) & 2) == 2)
+			break;
+
+		timeout--;
+
+		if (timeout <= 0) {
+			printk( "timeout waiting for SCL high\n");
+			break;
+		}
+	}
+	}
+#endif
+	writel(readl(_ICR(dev)) & ~ICR_SCLE, _ICR(dev));
+}
+
+
+
+static void i2c_pxa_send_data(struct ubmc_i2c_slave_dev *dev,char dat)
+{
+	int timeout;
+	uint32_t icr;
+
+	writel( dat, _IDBR(dev));
+
+#if 1
+	writel(readl(_ICR(dev)) | ICR_TB, _ICR(dev));
+	timeout = 0x10000;
+	while (1) {
+		if ((readl(_IBMR(dev)) & 2) == 2)
+			break;
+
+		timeout--;
+
+		if (timeout <= 0) {
+			printk( "timeout waiting for SCL high\n");
+			break;
+		}
+	}
+	//printk("snd dat is %x \n",dat);
+#endif
+}
+static void i2c_pxa_send_byte(struct ubmc_i2c_slave_dev *dev)
+{
+	unsigned char dat;
+	int timeout;
+	uint32_t icr;
+	dat = 0x33;
+
+
+	uint8_t num_bytes = dev->tx_msg_len;
+	uint16_t w = 0;
+	if(dev->tx_msg_idx > num_bytes - 1)
+	{
+		/*
+		printk("clear the ISR_ITE,idx is %d ,len is %d \n",dev->tx_msg_idx,dev->tx_msg_len);
+		printk("clear ISR_ITF:%s: %ld: ISR=%08x, ICR=%08x, IBMR=%02x ,ISAR=%02x,IDBR=%02x\n",
+					__func__, (long)jiffies, readl(_ISR(dev)), readl(_ICR(dev)), readl(_IBMR(dev)), readl(_ISAR(dev)), readl(_IDBR(dev)));
+		*/
+		dev->tx_msg_idx = 0;
+		dev->tx_msg_len = 0;
+		return ;
+	}
+	/* Clear the tx intrrupt Buffers */
+
+	writel( dev->tx_msg_buf[dev->tx_msg_idx], _IDBR(dev));
+	ubmc_debug("sending dat[%d]=%x  len is %d\n",dev->tx_msg_idx,dev->tx_msg_buf[dev->tx_msg_idx],num_bytes);
+	dev->tx_msg_idx ++;
+
+	writel(readl(_ICR(dev)) | ICR_TB, _ICR(dev));
+	//writel(readl(_ICR(dev)) | ICR_TB, _ICR(dev));
+	timeout = 0x10000;
+	while (1) {
+		if ((readl(_IBMR(dev)) & 2) == 2)
+			break;
+
+		timeout--;
+
+		if (timeout <= 0) {
+			printk( "timeout waiting for SCL high\n");
+			break;
+		}
+	}
+	timeout = 0x10000;
+	while (1) {
+		if ((readl(_ICR(dev)) & ICR_TB) == 0)
+			break;
+
+		timeout--;
+
+		if (timeout <= 0) {
+			printk( "timeout waiting for ICR_TB high\n");
+			break;
+		}
+	}
+
+	//printk("sending dat[%d]=%x ICR_TB is %d len is %d\n",dev->tx_msg_idx,dev->tx_msg_buf[dev->tx_msg_idx],(readl(_ICR(dev)) & ICR_TB),num_bytes);
+	//writel(readl(_ISR(dev)) | ISR_ITE, _ISR(dev));
+
+}
+
+
+static void i2c_pxa_slave_rxfull(struct ubmc_i2c_slave_dev *dev, unsigned int  isr)
+{
+	unsigned char byte ;
+/*
+	if (i2c->slave != NULL)
+		i2c->slave->write(i2c->slave->data, byte);
+*/
+
+	/* make sure writes to dev->buf_len are ordered */
+	//writel(readl(_ICR(dev)) | ICR_TB, _ICR(dev));
+
+	byte = readl(_IDBR(dev));
+	dev->rx_msg_buf[dev->rx_msg_idx] = byte;
+	dev->rx_msg_idx ++;
+
+	if (dev->rx_msg_idx >= SSIF_REQ_BUF_SIZE)
+	{
+		ubmc_error("i2c receive buffer wrap, not suppose to happen!!!!!!!");
+		dev->rx_msg_idx = 0;
+	}
+	//printk("receiving :dat[%d] is 0x%x ICR_TB is %d \n",dev->rx_msg_idx,byte,(readl(_ICR(dev)) & ICR_TB));
+
+	writel(readl(_ISR(dev)) & ~ISR_IRF, _ISR(dev));
+	writel(readl(_ICR(dev)) | ICR_TB, _ICR(dev));
+
+	while(readl(_ICR(dev)) & ICR_TB)
+	{
+		mdelay(1);
+	}
+	ubmc_debug("received :dat is 0x%x \n",byte);
+
+
+}
+
+static irqreturn_t ubmc_i2c_slave_irq_handle(int this_irq, void *dev_id)
+{
+
+	uint16_t bits;
+	uint16_t stat;
+	int m;
+	struct ubmc_i2c_slave_dev *dev = (struct ubmc_i2c_slave_dev *)dev_id;
+	u32 isr = readl(_ISR(dev));
+	pxa_i2c_irq_stats_dump(isr);
+	if (!(isr & VALID_INT_SOURCE))
+		return IRQ_NONE;
+	writel(isr & VALID_INT_SOURCE, _ISR(dev));
+	ubmc_debug_info(":%s: %ld: ISR=%08x, ICR=%08x, IBMR=%02x ,ISAR=%02x,IDBR=%02x\n",
+	__func__, (long)jiffies, readl(_ISR(dev)), readl(_ICR(dev)), readl(_IBMR(dev)), readl(_ISAR(dev)), readl(_IDBR(dev)));
+
+	if (isr & ISR_SAD)
+	{
+		ubmc_debug_info("ISR_SAD:%s: %ld: ISR=%08x, ICR=%08x, IBMR=%02x ,ISAR=%02x,IDBR=%02x\n",
+		__func__, (long)jiffies, readl(_ISR(dev)), readl(_ICR(dev)), readl(_IBMR(dev)), readl(_ISAR(dev)), readl(_IDBR(dev)));
+		ubmc_debug("ISR_SAD, mode is slave-%cx\n",(isr & ISR_RWM) ? 't' : 'r');
+		i2c_pxa_slave_start(dev, isr);
+
+	}
+	if (isr & ISR_ALD) {
+		/*
+		 * Do we need to do anything here?  The PXA docs
+		 * are vague about what happens.
+		 */
+		//i2c_pxa_scream_blue_murder(i2c, "ALD set");
+		writel(readl(_ISR(dev)) | ISR_ALD, _ICR(dev));
+		writel(readl(_ICR(dev)) | ICR_TB, _ICR(dev));
+		/*
+		 * We ignore this error.  We seem to see spurious ALDs
+		 * for seemingly no reason.  If we handle them as I think
+		 * they should, we end up causing an I2C error, which
+		 * is painful for some systems.
+		 */
+		return; /* ignore */
+	}
+	if (isr & ISR_SSD)
+	{
+		//i2c_pxa_slave_stop(i2c);
+		//isr = 0;
+		writel(readl(_ISR(dev))  | ISR_SSD, _ISR(dev));
+		writel(readl(_ICR(dev)) | ICR_TB, _ICR(dev));
+		/*
+		printk("ISR_SSD:%s: %ld: ISR=%08x, ICR=%08x, IBMR=%02x ,ISAR=%02x,IDBR=%02x\n",
+		__func__, (long)jiffies, readl(_ISR(dev)), readl(_ICR(dev)), readl(_IBMR(dev)), readl(_ISAR(dev)), readl(_IDBR(dev)));
+		*/
+	}
+	if(isr & ISR_ACKNAK)
+	{
+
+		writel(readl(_ICR(dev)) | ICR_TB, _ICR(dev));
+	}
+
+
+	if (i2c_pxa_is_slavemode(dev))
+	{
+#if 0
+		//printk("pxa slave mode isr is %x \n",isr);
+		if (isr & ISR_ITE)		//do not need this .
+		{
+			ubmc_debug_info("ISR_ITE:%s: %ld: ISR=%08x, ICR=%08x, IBMR=%02x ,ISAR=%02x,IDBR=%02x\n",
+			__func__, (long)jiffies, readl(_ISR(dev)), readl(_ICR(dev)), readl(_IBMR(dev)), readl(_ISAR(dev)), readl(_IDBR(dev)));
+			//i2c_pxa_slave_txempty(dev, isr);
+			i2c_pxa_send_byte(dev);
+			printk("ISR_ITE \n");
+
+		}
+#endif
+		if(isr & ISR_IRF)
+		{
+			i2c_pxa_slave_rxfull(dev, isr);
+			ubmc_debug_info("ISR_IRF:%s: %ld: ISR=%08x, ICR=%08x, IBMR=%02x ,ISAR=%02x,IDBR=%02x\n",
+			__func__, (long)jiffies, readl(_ISR(dev)), readl(_ICR(dev)), readl(_IBMR(dev)), readl(_ISAR(dev)), readl(_IDBR(dev)));
+		}
+		if((isr & ISR_RWM))	//'t'
+		{
+			ubmc_debug_info("ISR_IRF:%s: %ld: ISR=%08x, ICR=%08x, IBMR=%02x ,ISAR=%02x,IDBR=%02x\n",
+			__func__, (long)jiffies, readl(_ISR(dev)), readl(_ICR(dev)), readl(_IBMR(dev)), readl(_ISAR(dev)), readl(_IDBR(dev)));
+			if(ubmc_ssif_is_complete_req_msg(dev->rx_msg_buf, dev->rx_msg_idx))
+			{
+				if( ubmc_i2c_slave_ssif_req_handle(&g_ubmc_ipmi_pdev, dev->rx_msg_buf, dev->rx_msg_idx, dev->tx_msg_buf, &dev->tx_msg_len) == BMC_OK )
+				{
+					dev->tx_msg_ready = true;
+					/*
+					for(m=0 ; m < dev->tx_msg_len;m ++)
+					{
+						printk("ssif tx:dat%d %x",m,dev->tx_msg_buf[m]);
+					}
+					printk("\n");
+					*/
+					i2c_pxa_send_byte(dev);
+					ubmc_debug_info("ISR_ITE #1:%s: %ld: ISR=%08x, ICR=%08x, IBMR=%02x ,ISAR=%02x,IDBR=%02x\n",
+					__func__, (long)jiffies, readl(_ISR(dev)), readl(_ICR(dev)), readl(_IBMR(dev)), readl(_ISAR(dev)), readl(_IDBR(dev)));
+				}
+				ubmc_i2c_client_reset_receive_buf(dev);
+			}
+			else if(isr & ISR_ITE)
+			{
+				i2c_pxa_send_byte(dev);
+				//i2c_pxa_send_data(dev,0x88);
+				ubmc_debug_info("ISR_ITE #2:%s: %ld: ISR=%08x, ICR=%08x, IBMR=%02x ,ISAR=%02x,IDBR=%02x\n",
+				__func__, (long)jiffies, readl(_ISR(dev)), readl(_ICR(dev)), readl(_IBMR(dev)), readl(_ISAR(dev)), readl(_IDBR(dev)));
+			}
+			else
+			{
+				ubmc_error("Invalid rx message TB is %d \n",(readl(_ICR(dev)) & ICR_TB));
+				ubmc_i2c_client_reset_receive_buf(dev);
+				//i2c_pxa_slave_txempty(dev, isr);
+				i2c_pxa_send_data(dev,0x55);
+				ubmc_debug_info("ISR_IRF:%s: %ld: ISR=%08x, ICR=%08x, IBMR=%02x ,ISAR=%02x,IDBR=%02x\n",
+				__func__, (long)jiffies, readl(_ISR(dev)), readl(_ICR(dev)), readl(_IBMR(dev)), readl(_ISAR(dev)), readl(_IDBR(dev)));
+#if 0
+				dev->tx_msg_buf[0] = 0xff;
+				dev->tx_msg_len = 1;
+				ubmc_i2c_slave_send_current_buf(dev);
+				dev->tx_msg_ready = false;
+				//dev->tx_msg_ready = false;
+				ubmc_i2c_irq_stat_ack(dev,stat & bits);
+				//stat = ubmc_i2c_read_reg(dev, OMAP_I2C_STAT_REG);
+				//ubmc_i2c_irq_stats_dump(stat);
+			//	break;
+#endif
+			}
+		}
+		else if(isr & ISR_ITE)		//ITE && r mode	tx has been empty
+		{
+
+			dev->tx_msg_idx = 0;
+			dev->tx_msg_len = 0;
+			writel(readl(_ISR(dev)) | ISR_ITE, _ISR(dev));
+			writel(readl(_ICR(dev)) | ICR_TB, _ICR(dev));
+			//i2c_pxa_slave_rxfull(dev, isr);
+			ubmc_debug_info("ISR_ITE Rx Mode:%s: %ld: ISR=%08x, ICR=%08x, IBMR=%02x ,ISAR=%02x,IDBR=%02x\n",
+			__func__, (long)jiffies, readl(_ISR(dev)), readl(_ICR(dev)), readl(_IBMR(dev)), readl(_ISAR(dev)), readl(_IDBR(dev)));
+		}
+		if(isr & ISR_RXSR)
+		{
+			ubmc_debug_info("ISR_RXSR : \n");
+		}
+		if(isr & ISR_TXSR)
+		{
+			ubmc_debug_info("ISR_TXSR : \n");
+
+		}
+	}
+	else
+	{
+		ubmc_debug_info("do here 3\n");
+		//i2c_pxa_scream_blue_murder(i2c, "spurious irq");
+	}
+	ubmc_debug_info("done irq \n");
+	return IRQ_HANDLED;
+}
+
+
+static unsigned int i2c_debug = 0;
+/*
+static void decode_ICR(unsigned int val)
+{
+	decode_bits(KERN_DEBUG "ICR", icr_bits, ARRAY_SIZE(icr_bits), val);
+	printk("\n");
+}
+*/
+
+static void i2c_pxa_abort(struct ubmc_i2c_slave_dev *dev)
+{
+	int i = 250;
+
+	if (i2c_pxa_is_slavemode(dev)) {
+		ubmc_debug_info("%s: called in slave mode\n", __func__);
+		return;
+	}
+
+	while ((i > 0) && (readl(_IBMR(dev)) & 0x1) == 0) {
+		unsigned long icr = readl(_ICR(dev));
+
+		icr &= ~ICR_START;
+		icr |= ICR_ACKNAK | ICR_STOP | ICR_TB;
+
+		writel(icr, _ICR(dev));
+
+//		show_state(dev);
+
+		mdelay(1);
+		i --;
+	}
+
+	writel(readl(_ICR(dev)) & ~(ICR_MA | ICR_START | ICR_STOP),
+	       _ICR(dev));
+}
+
+static int i2c_pxa_wait_slave(struct ubmc_i2c_slave_dev *dev)
+{
+	unsigned long timeout = jiffies + HZ*1;
+	/* wait for stop */
+
+//	show_state(dev);
+
+	while (time_before(jiffies, timeout)) {
+
+		ubmc_debug_info("%s: %ld: ISR=%08x, ICR=%08x, IBMR=%02x\n",
+				__func__, (long)jiffies, readl(_ISR(dev)), readl(_ICR(dev)), readl(_IBMR(dev)));
+
+		if ((readl(_ISR(dev)) & (ISR_UB|ISR_IBB)) == 0 ||
+		    (readl(_ISR(dev)) & ISR_SAD) != 0 ||
+		    (readl(_ICR(dev)) & ICR_SCLE) == 0) {
+/*			if (i2c_debug > 1)
+				dev_dbg(&dev->adap.dev, "%s: done\n", __func__);
+				*/
+			return 1;
+		}
+
+		msleep(1);
+	}
+/*
+	if (i2c_debug > 0)
+		dev_dbg(&i2c->adap.dev, "%s: did not free\n", __func__);
+		*/
+	return 0;
+}
+
+/*
+ * clear the hold on the bus, and take of anything else
+ * that has been configured
+ */
+static void i2c_pxa_set_slave(struct ubmc_i2c_slave_dev *dev, int errcode)
+{
+//	show_state(dev);
+	if (errcode < 0) {
+		udelay(100);   /* simple delay */
+	} else {
+		/* we need to wait for the stop condition to end */
+
+		/* if we where in stop, then clear... */
+		if (readl(_ICR(dev)) & ICR_STOP) {
+			udelay(100);
+			writel(readl(_ICR(dev)) & ~ICR_STOP, _ICR(dev));
+		}
+
+		if (!i2c_pxa_wait_slave(dev)) {
+			printk( "%s: wait timedout\n",__func__);
+			return;
+		}
+	}
+
+	writel(readl(_ICR(dev)) & ~(ICR_STOP|ICR_ACKNAK|ICR_MA), _ICR(dev));
+	writel(readl(_ICR(dev)) & ~ICR_SCLE, _ICR(dev));
+
+	if (i2c_debug) {
+		/*
+		dev_dbg(&i2c->adap.dev, "ICR now %08x, ISR %08x\n", readl(_ICR(dev)), readl(_ISR(dev)));
+		decode_ICR(readl(_ICR(dev)));
+		*/
+	}
+}
+
+static void ubmc_i2c_slave_mode_setup(struct ubmc_i2c_slave_dev *dev)
+{
+	printk("Resetting I2C Controller Unit\n");
+
+	/* abort any transfer currently under way */
+	i2c_pxa_abort(dev);
+	dev->slave_addr = 0x42;
+	/* reset according to 9.8 */
+	writel(ICR_UR, _ICR(dev));
+	writel(I2C_ISR_INIT, _ISR(dev));
+	writel(readl(_ICR(dev)) & ~ICR_UR, _ICR(dev));
+	writel(dev->slave_addr, _ISAR(dev));
+
+	/* set control register values */
+	writel(I2C_ICR_INIT |  dev->fm_mask , _ICR(dev));
+	//writel(readl(_ICR(dev)) | (dev->high_mode ? i2c->hs_mask : 0), _ICR(dev));
+	//dev_info(&i2c->adap.dev, "Enabling slave mode\n");
+	writel(readl(_ICR(dev)) | ICR_SADIE | ICR_ALDIE | ICR_SSDIE, _ICR(dev));
+	i2c_pxa_set_slave(dev, 0);
+	/* enable unit */
+	writel(readl(_ICR(dev)) | ICR_IUE, _ICR(dev));
+	udelay(100);
+}
+
+
+int ubmc_pxa_slave_init(void*dev)
+{
+	int rc;
+	struct ubmc_i2c_slave_dev* p_dev = dev;
+	unsigned int isr;
+	memset(p_dev, 0, sizeof(*p_dev));
+
+	spin_lock_init(&p_dev->lock);
+	p_dev->reg_base =ioremap(0xd0011000, 0x400);
+	if (IS_ERR(p_dev->reg_base))
+	{
+		printk("ioremap fail \n");
+		return PTR_ERR(p_dev->base);
+	}
+	p_dev->reg_ibmr = p_dev->reg_base + pxa_reg_layout[REGS_A3700].ibmr;
+	p_dev->reg_idbr = p_dev->reg_base + pxa_reg_layout[REGS_A3700].idbr;
+	p_dev->reg_icr = p_dev->reg_base + pxa_reg_layout[REGS_A3700].icr;
+	p_dev->reg_isr = p_dev->reg_base + pxa_reg_layout[REGS_A3700].isr;
+	p_dev->reg_isar = p_dev->reg_base + pxa_reg_layout[REGS_A3700].isar;
+	p_dev->reg_rfth = p_dev->reg_base + 0x3c;
+	p_dev->reg_tfth = p_dev->reg_base + 0x40;
+	p_dev->fm_mask = pxa_reg_layout[REGS_A3700].fm ? : ICR_FM;
+	p_dev->hs_mask = pxa_reg_layout[REGS_A3700].hs ? : ICR_HS;
+	p_dev->slave_addr = 0x42;
+	strcpy(p_dev->name,I2C_PXA_NAME);
+	//writel(isr & VALID_INT_SOURCE, _ISR(p_dev));
+	//ubmc_debug("Initializing i2c-1 as slave");
+	p_dev->irq = 8 ;
+	rc = request_irq(p_dev->irq, &ubmc_i2c_slave_irq_handle,IRQF_SHARED |IRQF_NO_SUSPEND, "i2c_slave", p_dev);
+	if( rc ){
+		ubmc_error("Could not assign IRQ handler to irq %d rc %d !\n",p_dev->irq,rc);
+		return -1;
+	}
+	/* abort any transfer currently under way */
+	i2c_pxa_abort(p_dev);
+	p_dev->slave_addr = 0x42;
+	/* reset according to 9.8 */
+	writel(ICR_UR, _ICR(p_dev));
+	writel(I2C_ISR_INIT, _ISR(p_dev));
+	writel(readl(_ICR(p_dev)) & ~ICR_UR, _ICR(p_dev));
+	writel(p_dev->slave_addr, _ISAR(p_dev));
+	p_dev->fast_mode =1 ;
+	p_dev->high_mode =0 ;
+	/* set control register values */
+	writel(I2C_ICR_INIT | (p_dev->fast_mode ? p_dev->fm_mask : 0), _ICR(p_dev));
+	writel(readl(_ICR(p_dev)) | (p_dev->high_mode ? p_dev->hs_mask : 0), _ICR(p_dev));
+	//dev_info(&i2c->adap.dev, "Enabling slave mode\n");
+	writel(readl(_ICR(p_dev)) | ICR_SADIE | ICR_ALDIE | ICR_SSDIE, _ICR(p_dev));
+	i2c_pxa_set_slave(p_dev, 0);
+	udelay(100);
+	writel(readl(_ICR(p_dev)) | ICR_IUE, _ICR(p_dev));
+	udelay(100);
+	return 0;
+}
+
+void ubmc_pxa_slave_deinit(void *dev)
+{
+	struct ubmc_i2c_slave_dev* p_dev = dev;
+
+	free_irq(p_dev->irq, p_dev);
+	if(p_dev->cm_per_base)
+		iounmap(p_dev->cm_per_base);
+	if(p_dev->base)
+		iounmap(p_dev->base);
+
+}
+
--- linux-ti2018.02-rc4-int-orig/drivers/i2c/busses/i2c-pxa.h	1970-01-01 08:00:00.000000000 +0800
+++ linux-ti2018.02-rc4-int-silicom/drivers/i2c/busses/i2c-pxa.h	2020-03-09 10:47:12.016803573 +0800
@@ -0,0 +1,194 @@
+/*
+ * i2c-pxa.h
+ *
+ *  Created on: Aug 27, 2019
+ *      Author: jason_zhang
+ */
+
+#ifndef I2C_BUSSES_I2C_PXA_H_
+#define I2C_BUSSES_I2C_PXA_H_
+
+#include <linux/i2c/pxa-i2c.h>
+/*
+ * I2C bit definitions
+ */
+struct pxa_reg_layout {
+	u32 ibmr;
+	u32 idbr;
+	u32 icr;
+	u32 isr;
+	u32 isar;
+	u32 ilcr;
+	u32 iwcr;
+	u32 fm;
+	u32 hs;
+};
+
+enum pxa_i2c_types {
+	REGS_PXA2XX,
+	REGS_PXA3XX,
+	REGS_CE4100,
+	REGS_PXA910,
+	REGS_A3700,
+};
+
+
+#define ICR_BUSMODE_FM	(1 << 16)	   /* shifted fast mode for armada-3700 */
+#define ICR_BUSMODE_HS	(1 << 17)	   /* shifted high speed mode for armada-3700 */
+
+
+#define ICR_START	(1 << 0)	   /* start bit */
+#define ICR_STOP	(1 << 1)	   /* stop bit */
+#define ICR_ACKNAK	(1 << 2)	   /* send ACK(0) or NAK(1) */
+#define ICR_TB		(1 << 3)	   /* transfer byte bit */
+#define ICR_MA		(1 << 4)	   /* master abort */
+#define ICR_SCLE	(1 << 5)	   /* master clock enable */
+#define ICR_IUE		(1 << 6)	   /* unit enable */
+#define ICR_GCD		(1 << 7)	   /* general call disable */
+#define ICR_ITEIE	(1 << 8)	   /* enable tx interrupts */
+#define ICR_IRFIE	(1 << 9)	   /* enable rx interrupts */
+#define ICR_BEIE	(1 << 10)	   /* enable bus error ints */
+#define ICR_SSDIE	(1 << 11)	   /* slave STOP detected int enable */
+#define ICR_ALDIE	(1 << 12)	   /* enable arbitration interrupt */
+#define ICR_SADIE	(1 << 13)	   /* slave address detected int enable */
+#define ICR_UR		(1 << 14)	   /* unit reset */
+#define ICR_FM		(1 << 15)	   /* fast mode */
+#define ICR_HS		(1 << 16)	   /* High Speed mode */
+#define ICR_GPIOEN	(1 << 19)	   /* enable GPIO mode for SCL in HS */
+#define ICR_FIFOEN	(1 << 21)	   /*enable FIFO mode*/
+#define ICR_TXBEGIN	(1 << 22)	   /*I2C transaction begin*/
+#define ICR_TXDONE_IE	(1 << 23)	   /*Transaction Done Interrupt Enable*/
+#define ICR_RXOV_IE	(1 << 27)	   /*Receive FIFO overrun Interrupt Enable*/
+
+
+#define ISR_RWM		(1 << 0)	   /* read/write mode */
+#define ISR_ACKNAK	(1 << 1)	   /* ack/nak status */
+#define ISR_UB		(1 << 2)	   /* unit busy */
+#define ISR_IBB		(1 << 3)	   /* bus busy */
+#define ISR_SSD		(1 << 4)	   /* slave stop detected */
+#define ISR_ALD		(1 << 5)	   /* arbitration loss detected */
+#define ISR_ITE		(1 << 6)	   /* tx buffer empty */
+#define ISR_IRF		(1 << 7)	   /* rx buffer full */
+#define ISR_GCAD	(1 << 8)	   /* general call address detected */
+#define ISR_SAD		(1 << 9)	   /* slave address detected */
+#define ISR_BED		(1 << 10)	   /* bus error no ACK/NAK */
+#define ISR_RXSR	(1 << 14)	   /* receive fifo services request */
+#define ISR_TXSR	(1 << 15)	   /* transaction fifo services request */
+
+/* bit field shift & mask */
+#define ILCR_SLV_SHIFT		0
+#define ILCR_SLV_MASK		(0x1FF << ILCR_SLV_SHIFT)
+#define ILCR_FLV_SHIFT		9
+#define ILCR_FLV_MASK		(0x1FF << ILCR_FLV_SHIFT)
+#define ILCR_HLVL_SHIFT		18
+#define ILCR_HLVL_MASK		(0x1FF << ILCR_HLVL_SHIFT)
+#define ILCR_HLVH_SHIFT		27
+#define ILCR_HLVH_MASK		(0x1F << ILCR_HLVH_SHIFT)
+
+#define IWCR_CNT_SHIFT		0
+#define IWCR_CNT_MASK		(0x1F << IWCR_CNT_SHIFT)
+#define IWCR_HS_CNT1_SHIFT	5
+#define IWCR_HS_CNT1_MASK	(0x1F << IWCR_HS_CNT1_SHIFT)
+#define IWCR_HS_CNT2_SHIFT	10
+#define IWCR_HS_CNT2_MASK	(0x1F << IWCR_HS_CNT2_SHIFT)
+
+#define DEBUG 2
+struct pxa_i2c {
+	spinlock_t		lock;
+	wait_queue_head_t	wait;
+	struct i2c_msg		*msg;
+	unsigned int		msg_num;
+	unsigned int		msg_idx;
+	unsigned int		msg_ptr;
+	unsigned int		slave_addr;
+	unsigned int		req_slave_addr;
+
+	struct i2c_adapter	adap;
+	struct clk		*clk;
+#ifdef CONFIG_I2C_PXA_SLAVE
+	struct i2c_slave_client *slave;
+#endif
+
+	unsigned int		irqlogidx;
+	u32			isrlog[32];
+	u32			icrlog[32];
+
+	void __iomem		*reg_base;
+	void __iomem		*reg_ibmr;
+	void __iomem		*reg_idbr;
+	void __iomem		*reg_icr;
+	void __iomem		*reg_isr;
+	void __iomem		*reg_isar;
+	void __iomem		*reg_ilcr;
+	void __iomem		*reg_iwcr;
+
+	unsigned long		iobase;
+	unsigned long		iosize;
+
+	int			irq;
+	unsigned int		use_pio :1;
+	unsigned int		fast_mode :1;
+	unsigned int		high_mode:1;
+	unsigned char		master_code;
+	unsigned long		rate;
+	bool			highmode_enter;
+	u32			fm_mask;
+	u32			hs_mask;
+};
+
+#define _IBMR(i2c)	((i2c)->reg_ibmr)
+#define _IDBR(i2c)	((i2c)->reg_idbr)
+#define _ICR(i2c)	((i2c)->reg_icr)
+#define _ISR(i2c)	((i2c)->reg_isr)
+#define _ISAR(i2c)	((i2c)->reg_isar)
+#define _ILCR(i2c)	((i2c)->reg_ilcr)
+#define _IWCR(i2c)	((i2c)->reg_iwcr)
+
+/*
+ * I2C registers definitions
+ */
+struct pxa_reg_layout pxa_reg_layout[] = {
+	[REGS_PXA2XX] = {
+		.ibmr =	0x00,
+		.idbr =	0x08,
+		.icr =	0x10,
+		.isr =	0x18,
+		.isar =	0x20,
+	},
+	[REGS_PXA3XX] = {
+		.ibmr =	0x00,
+		.idbr =	0x04,
+		.icr =	0x08,
+		.isr =	0x0c,
+		.isar =	0x10,
+	},
+	[REGS_CE4100] = {
+		.ibmr =	0x14,
+		.idbr =	0x0c,
+		.icr =	0x00,
+		.isr =	0x04,
+		/* no isar register */
+	},
+	[REGS_PXA910] = {
+		.ibmr = 0x00,
+		.idbr = 0x08,
+		.icr =	0x10,
+		.isr =	0x18,
+		.isar = 0x20,
+		.ilcr = 0x28,
+		.iwcr = 0x30,
+	},
+	[REGS_A3700] = {
+		.ibmr =	0x00,
+		.idbr =	0x04,
+		.icr =	0x08,
+		.isr =	0x0c,
+		.isar =	0x10,
+		.fm = ICR_BUSMODE_FM,
+		.hs = ICR_BUSMODE_HS,
+	},
+};
+
+
+
+#endif /* I2C_BUSSES_I2C_PXA_H_ */
--- linux-ti2018.02-rc4-int-orig/drivers/i2c/busses/i2c-pxa.c	2018-07-15 00:46:29.000000000 +0800
+++ linux-ti2018.02-rc4-int-silicom/drivers/i2c/busses/i2c-pxa.c	2020-03-09 10:47:12.016803573 +0800
@@ -37,76 +37,11 @@
 #include <linux/slab.h>
 #include <linux/io.h>
 #include <linux/i2c/pxa-i2c.h>
-
+#include "i2c-pxa.h"
 #include <asm/irq.h>
 
-struct pxa_reg_layout {
-	u32 ibmr;
-	u32 idbr;
-	u32 icr;
-	u32 isr;
-	u32 isar;
-	u32 ilcr;
-	u32 iwcr;
-	u32 fm;
-	u32 hs;
-};
-
-enum pxa_i2c_types {
-	REGS_PXA2XX,
-	REGS_PXA3XX,
-	REGS_CE4100,
-	REGS_PXA910,
-	REGS_A3700,
-};
 
-#define ICR_BUSMODE_FM	(1 << 16)	   /* shifted fast mode for armada-3700 */
-#define ICR_BUSMODE_HS	(1 << 17)	   /* shifted high speed mode for armada-3700 */
 
-/*
- * I2C registers definitions
- */
-static struct pxa_reg_layout pxa_reg_layout[] = {
-	[REGS_PXA2XX] = {
-		.ibmr =	0x00,
-		.idbr =	0x08,
-		.icr =	0x10,
-		.isr =	0x18,
-		.isar =	0x20,
-	},
-	[REGS_PXA3XX] = {
-		.ibmr =	0x00,
-		.idbr =	0x04,
-		.icr =	0x08,
-		.isr =	0x0c,
-		.isar =	0x10,
-	},
-	[REGS_CE4100] = {
-		.ibmr =	0x14,
-		.idbr =	0x0c,
-		.icr =	0x00,
-		.isr =	0x04,
-		/* no isar register */
-	},
-	[REGS_PXA910] = {
-		.ibmr = 0x00,
-		.idbr = 0x08,
-		.icr =	0x10,
-		.isr =	0x18,
-		.isar = 0x20,
-		.ilcr = 0x28,
-		.iwcr = 0x30,
-	},
-	[REGS_A3700] = {
-		.ibmr =	0x00,
-		.idbr =	0x04,
-		.icr =	0x08,
-		.isr =	0x0c,
-		.isar =	0x10,
-		.fm = ICR_BUSMODE_FM,
-		.hs = ICR_BUSMODE_HS,
-	},
-};
 
 static const struct platform_device_id i2c_pxa_id_table[] = {
 	{ "pxa2xx-i2c",		REGS_PXA2XX },
@@ -118,113 +53,11 @@
 };
 MODULE_DEVICE_TABLE(platform, i2c_pxa_id_table);
 
-/*
- * I2C bit definitions
- */
-
-#define ICR_START	(1 << 0)	   /* start bit */
-#define ICR_STOP	(1 << 1)	   /* stop bit */
-#define ICR_ACKNAK	(1 << 2)	   /* send ACK(0) or NAK(1) */
-#define ICR_TB		(1 << 3)	   /* transfer byte bit */
-#define ICR_MA		(1 << 4)	   /* master abort */
-#define ICR_SCLE	(1 << 5)	   /* master clock enable */
-#define ICR_IUE		(1 << 6)	   /* unit enable */
-#define ICR_GCD		(1 << 7)	   /* general call disable */
-#define ICR_ITEIE	(1 << 8)	   /* enable tx interrupts */
-#define ICR_IRFIE	(1 << 9)	   /* enable rx interrupts */
-#define ICR_BEIE	(1 << 10)	   /* enable bus error ints */
-#define ICR_SSDIE	(1 << 11)	   /* slave STOP detected int enable */
-#define ICR_ALDIE	(1 << 12)	   /* enable arbitration interrupt */
-#define ICR_SADIE	(1 << 13)	   /* slave address detected int enable */
-#define ICR_UR		(1 << 14)	   /* unit reset */
-#define ICR_FM		(1 << 15)	   /* fast mode */
-#define ICR_HS		(1 << 16)	   /* High Speed mode */
-#define ICR_GPIOEN	(1 << 19)	   /* enable GPIO mode for SCL in HS */
-
-#define ISR_RWM		(1 << 0)	   /* read/write mode */
-#define ISR_ACKNAK	(1 << 1)	   /* ack/nak status */
-#define ISR_UB		(1 << 2)	   /* unit busy */
-#define ISR_IBB		(1 << 3)	   /* bus busy */
-#define ISR_SSD		(1 << 4)	   /* slave stop detected */
-#define ISR_ALD		(1 << 5)	   /* arbitration loss detected */
-#define ISR_ITE		(1 << 6)	   /* tx buffer empty */
-#define ISR_IRF		(1 << 7)	   /* rx buffer full */
-#define ISR_GCAD	(1 << 8)	   /* general call address detected */
-#define ISR_SAD		(1 << 9)	   /* slave address detected */
-#define ISR_BED		(1 << 10)	   /* bus error no ACK/NAK */
-
-/* bit field shift & mask */
-#define ILCR_SLV_SHIFT		0
-#define ILCR_SLV_MASK		(0x1FF << ILCR_SLV_SHIFT)
-#define ILCR_FLV_SHIFT		9
-#define ILCR_FLV_MASK		(0x1FF << ILCR_FLV_SHIFT)
-#define ILCR_HLVL_SHIFT		18
-#define ILCR_HLVL_MASK		(0x1FF << ILCR_HLVL_SHIFT)
-#define ILCR_HLVH_SHIFT		27
-#define ILCR_HLVH_MASK		(0x1F << ILCR_HLVH_SHIFT)
-
-#define IWCR_CNT_SHIFT		0
-#define IWCR_CNT_MASK		(0x1F << IWCR_CNT_SHIFT)
-#define IWCR_HS_CNT1_SHIFT	5
-#define IWCR_HS_CNT1_MASK	(0x1F << IWCR_HS_CNT1_SHIFT)
-#define IWCR_HS_CNT2_SHIFT	10
-#define IWCR_HS_CNT2_MASK	(0x1F << IWCR_HS_CNT2_SHIFT)
-
-struct pxa_i2c {
-	spinlock_t		lock;
-	wait_queue_head_t	wait;
-	struct i2c_msg		*msg;
-	unsigned int		msg_num;
-	unsigned int		msg_idx;
-	unsigned int		msg_ptr;
-	unsigned int		slave_addr;
-	unsigned int		req_slave_addr;
-
-	struct i2c_adapter	adap;
-	struct clk		*clk;
-#ifdef CONFIG_I2C_PXA_SLAVE
-	struct i2c_slave_client *slave;
-#endif
-
-	unsigned int		irqlogidx;
-	u32			isrlog[32];
-	u32			icrlog[32];
-
-	void __iomem		*reg_base;
-	void __iomem		*reg_ibmr;
-	void __iomem		*reg_idbr;
-	void __iomem		*reg_icr;
-	void __iomem		*reg_isr;
-	void __iomem		*reg_isar;
-	void __iomem		*reg_ilcr;
-	void __iomem		*reg_iwcr;
-
-	unsigned long		iobase;
-	unsigned long		iosize;
-
-	int			irq;
-	unsigned int		use_pio :1;
-	unsigned int		fast_mode :1;
-	unsigned int		high_mode:1;
-	unsigned char		master_code;
-	unsigned long		rate;
-	bool			highmode_enter;
-	u32			fm_mask;
-	u32			hs_mask;
-};
-
-#define _IBMR(i2c)	((i2c)->reg_ibmr)
-#define _IDBR(i2c)	((i2c)->reg_idbr)
-#define _ICR(i2c)	((i2c)->reg_icr)
-#define _ISR(i2c)	((i2c)->reg_isr)
-#define _ISAR(i2c)	((i2c)->reg_isar)
-#define _ILCR(i2c)	((i2c)->reg_ilcr)
-#define _IWCR(i2c)	((i2c)->reg_iwcr)
 
 /*
  * I2C Slave mode address
  */
-#define I2C_PXA_SLAVE_ADDR      0x1
+#define I2C_PXA_SLAVE_ADDR      0x42
 
 #ifdef DEBUG
 
@@ -514,7 +347,7 @@
 
 	/* reset according to 9.8 */
 	writel(ICR_UR, _ICR(i2c));
-	writel(I2C_ISR_INIT, _ISR(i2c));
+	//writel(I2C_ISR_INIT, _ISR(i2c));
 	writel(readl(_ICR(i2c)) & ~ICR_UR, _ICR(i2c));
 
 	if (i2c->reg_isar && IS_ENABLED(CONFIG_I2C_PXA_SLAVE))
@@ -1068,7 +901,6 @@
 {
 	struct pxa_i2c *i2c = dev_id;
 	u32 isr = readl(_ISR(i2c));
-
 	if (!(isr & VALID_INT_SOURCE))
 		return IRQ_NONE;
 
@@ -1087,7 +919,6 @@
 	 * Always clear all pending IRQs.
 	 */
 	writel(isr & VALID_INT_SOURCE, _ISR(i2c));
-
 	if (isr & ISR_SAD)
 		i2c_pxa_slave_start(i2c, isr);
 	if (isr & ISR_SSD)
@@ -1210,7 +1041,6 @@
 	struct pxa_i2c *i2c;
 	struct resource *res = NULL;
 	int ret, irq;
-
 	i2c = devm_kzalloc(&dev->dev, sizeof(struct pxa_i2c), GFP_KERNEL);
 	if (!i2c)
 		return -ENOMEM;
@@ -1279,7 +1109,6 @@
 #endif
 		i2c->adap.class = plat->class;
 	}
-
 	if (i2c->high_mode) {
 		if (i2c->rate) {
 			clk_set_rate(i2c->clk, i2c->rate);
@@ -1296,9 +1125,11 @@
 		i2c->adap.algo = &i2c_pxa_pio_algorithm;
 	} else {
 		i2c->adap.algo = &i2c_pxa_algorithm;
+/*
 		ret = devm_request_irq(&dev->dev, irq, i2c_pxa_handler,
 				IRQF_SHARED | IRQF_NO_SUSPEND,
 				dev_name(&dev->dev), i2c);
+*/
 		if (ret) {
 			dev_err(&dev->dev, "failed to request irq: %d\n", ret);
 			goto ereqirq;
@@ -1356,7 +1187,7 @@
 static int i2c_pxa_resume_noirq(struct device *dev)
 {
 	struct pxa_i2c *i2c = dev_get_drvdata(dev);
-
+	printk("do i2c_pxa_resume_noirq \n");
 	clk_enable(i2c->clk);
 	i2c_pxa_reset(i2c);
 
