--- linux-ti2018.02-rc4-int-orig/drivers/net/ethernet/ti/cpsw.c	2018-07-15 00:46:29.000000000 +0800
+++ linux-ti2018.02-rc4-int-silicom/drivers/net/ethernet/ti/cpsw.c	2020-03-09 10:47:12.122803446 +0800
@@ -38,11 +38,19 @@
 #include <linux/net_switch_config.h>
 
 #include <linux/pinctrl/consumer.h>
+#ifndef NO_SILC_MOD
+#include <net/ncsi.h>
+#endif
 
 #include "cpsw.h"
 #include "cpsw_ale.h"
 #include "cpts.h"
 #include "davinci_cpdma.h"
+#ifdef CONFIG_BCM5421_SUPPORT
+#include <linux/kthread.h>
+#include "davinci_mdio_int.h"
+extern int g_bcm5421_exist;
+#endif
 
 #define CPSW_DEBUG	(NETIF_MSG_HW		| NETIF_MSG_WOL		| \
 			 NETIF_MSG_DRV		| NETIF_MSG_LINK	| \
@@ -82,6 +90,7 @@
 #define CPSW_MAJOR_VERSION(reg)		(reg >> 8 & 0x7)
 #define CPSW_MINOR_VERSION(reg)		(reg & 0xff)
 #define CPSW_RTL_VERSION(reg)		((reg >> 11) & 0x1f)
+#define SIL_VERSION		        "Silicom v1.10"
 
 #define CPSW_VERSION_1		0x19010a
 #define CPSW_VERSION_2		0x19010c
@@ -123,9 +132,13 @@
 #define CPSW_POLL_WEIGHT	64
 #define CPSW_RX_VLAN_ENCAP_HDR_SIZE		4
 #define CPSW_MIN_PACKET_SIZE	(VLAN_ETH_ZLEN)
+#ifdef NO_SILC_MOD
 #define CPSW_MAX_PACKET_SIZE	(VLAN_ETH_FRAME_LEN +\
 				 ETH_FCS_LEN +\
 				 CPSW_RX_VLAN_ENCAP_HDR_SIZE)
+#else
+#define CPSW_MAX_PACKET_SIZE	10240
+#endif
 
 #define RX_PRIORITY_MAPPING	0x76543210
 #define TX_PRIORITY_MAPPING	0x33221100
@@ -309,6 +322,10 @@
 #define CPSW_MAX_BLKS_TX_SHIFT		4
 #define CPSW_MAX_BLKS_RX		5
 
+#ifdef CONFIG_BCM5421_SUPPORT
+static struct task_struct *thread_st;
+#endif
+
 struct cpsw_host_regs {
 	u32	max_blks;
 	u32	blk_cnt;
@@ -376,6 +393,9 @@
 	int		phy_if;
 	u8		mac_addr[ETH_ALEN];
 	u16		dual_emac_res_vlan;	/* Reserved VLAN for DualEMAC */
+#ifndef NO_SILC_MOD
+	bool	use_ncsi;	/* Enable ncsi on this interface */
+#endif
 };
 
 struct cpsw_platform_data {
@@ -389,6 +409,9 @@
 	u32	mac_control;	/* Mac control register */
 	u16	default_vlan;	/* Def VLAN for ALE lookup in VLAN aware mode*/
 	bool	dual_emac;	/* Enable Dual EMAC mode */
+#ifndef NO_SILC_MOD
+	bool	slave_ncsi;	/* Enable ncsi on slave interface */
+#endif
 };
 
 struct cpsw_slave {
@@ -452,6 +475,11 @@
 	u8				mac_addr[ETH_ALEN];
 	bool				rx_pause;
 	bool				tx_pause;
+#ifndef NO_SILC_MOD
+	bool				hw_link;
+	struct ncsi_dev *ncsi_dev;
+	bool			ncsi_dev_started;
+#endif
 	u8				port_state[3];
 	u32 emac_port;
 	struct cpsw_common *cpsw;
@@ -538,6 +566,9 @@
 
 #define ndev_to_cpsw(ndev) (((struct cpsw_priv *)netdev_priv(ndev))->cpsw)
 #define napi_to_cpsw(napi)	container_of(napi, struct cpsw_common, napi)
+#ifndef  NO_SILC_MOD
+#define slave_to_priv(slave)	((struct cpsw_priv *)netdev_priv((slave)->ndev))
+#endif
 #define for_each_slave(priv, func, arg...)				\
 	do {								\
 		struct cpsw_slave *slave;				\
@@ -723,6 +754,9 @@
 	struct net_device	*ndev = skb->dev;
 	struct cpsw_common	*cpsw = ndev_to_cpsw(ndev);
 
+//	printk(KERN_ERR "TXD %d skb %p %p\n", len, skb, skb->data);
+
+
 	/* Check whether the queue is stopped due to stalled tx dma, if the
 	 * queue is stopped then start the queue as we have free desc for tx
 	 */
@@ -788,6 +822,11 @@
 	int			ret = 0;
 	struct cpsw_common	*cpsw = ndev_to_cpsw(ndev);
 
+//	printk(KERN_ERR "PR %d skb %p %p\n", len, skb, skb->data);
+//	    print_hex_dump(KERN_ERR, "received: ", DUMP_PREFIX_OFFSET,
+//	               16, 1, skb->data, len, 0);
+//		return;
+
 	cpsw_dual_emac_src_port_detect(cpsw, status, ndev, skb);
 
 	if (unlikely(status < 0) || unlikely(!netif_running(ndev))) {
@@ -1151,13 +1190,39 @@
 	for_each_slave(priv, _cpsw_adjust_link, priv, &link);
 
 	if (link) {
+#ifndef NO_SILC_MOD
+		netdev_info(ndev, "Link on start tx");
+#endif
 		if (cpsw_need_resplit(cpsw))
 			cpsw_split_res(ndev);
 
 		netif_carrier_on(ndev);
 		if (netif_running(ndev))
 			netif_tx_wake_all_queues(ndev);
+#ifndef NO_SILC_MOD
+		if(priv->ncsi_dev)
+		{
+			if (!priv->ncsi_dev_started)
+			{
+				int rc;
+				netdev_notice(ndev, "Starting NCSI");
+			/* Start the NCSI device */
+				rc = ncsi_start_dev(priv->ncsi_dev);
+				if(rc == 0 )
+				{
+					priv->ncsi_dev_started = true;
+				}
+				else
+				{
+					netdev_notice(ndev, "Failed Starting NCSI, %d", rc);
+				}
+			}
+		}
+#endif
 	} else {
+#ifndef NO_SILC_MOD
+		netdev_info(ndev, "No link stop tx");
+#endif
 		netif_carrier_off(ndev);
 		netif_tx_stop_all_queues(ndev);
 	}
@@ -1360,6 +1425,9 @@
 	struct phy_device *phy;
 	struct cpsw_common *cpsw = priv->cpsw;
 
+#ifndef NO_SILC_MOD
+	ubmc_info(&slave->ndev->dev, "cpsw_slave_open %u\n", priv->emac_port);
+#endif
 	soft_reset_slave(slave);
 
 	/* setup priority mapping */
@@ -1513,6 +1581,7 @@
 				cpsw_err(priv, ifup, "cannot allocate skb\n");
 				return -ENOMEM;
 			}
+//			printk(KERN_ERR "SA %p %p\n", skb, skb->data);
 
 			skb_set_queue_mapping(skb, ch);
 			ret = cpdma_chan_submit(cpsw->rxv[ch].ch, skb,
@@ -1538,9 +1607,23 @@
 static void cpsw_slave_stop(struct cpsw_slave *slave, struct cpsw_common *cpsw)
 {
 	u32 slave_port;
+#ifndef NO_SILC_MOD
+	struct cpsw_priv* priv = slave_to_priv(slave);
+#endif
 
 	slave_port = cpsw_get_slave_port(slave->slave_num);
 
+#ifndef NO_SILC_MOD
+	if(priv->ncsi_dev)
+	{
+		if(priv->ncsi_dev_started)
+		{
+			netdev_notice(slave->ndev, "Stopping NCSI");
+			ncsi_stop_dev(priv->ncsi_dev);
+			priv->ncsi_dev_started = false;
+		}
+	}
+#endif
 	if (!slave->phy)
 		return;
 	phy_stop(slave->phy);
@@ -1581,9 +1664,9 @@
 
 	reg = cpsw->version;
 
-	dev_info(priv->dev, "initializing cpsw version %d.%d (%d)\n",
+	dev_info(priv->dev, "initializing cpsw version %d.%d (%d)- %s\n",
 		 CPSW_MAJOR_VERSION(reg), CPSW_MINOR_VERSION(reg),
-		 CPSW_RTL_VERSION(reg));
+		 CPSW_RTL_VERSION(reg), SIL_VERSION);
 
 	/* Initialize host and slave ports */
 	if (!cpsw->usage_count)
@@ -1679,6 +1762,25 @@
 	return 0;
 }
 
+#ifndef NO_SILC_MOD
+static void cpsw_ncsi_handler(struct ncsi_dev *nd)
+{
+	if (unlikely(nd->state != ncsi_dev_state_functional))
+		return;
+
+#if 0
+	if (nd->dev)
+		netif_carrier_on(nd->dev);
+	else
+		netif_carrier_off(nd->dev);
+#endif
+//	dump_stack();
+	netdev_info(nd->dev, "NCSI interface %s\n",
+		    nd->link_up ? "up" : "down");
+
+}
+#endif
+
 static netdev_tx_t cpsw_ndo_start_xmit(struct sk_buff *skb,
 				       struct net_device *ndev)
 {
@@ -2466,6 +2568,10 @@
 	regs->version = cpsw->version;
 
 	cpsw_ale_dump(cpsw->ale, reg);
+
+#ifdef CONFIG_BCM5421_SUPPORT
+	davinci_mdio_dump();
+#endif
 }
 
 static void cpsw_get_drvinfo(struct net_device *ndev,
@@ -3009,6 +3115,11 @@
 
 	if (of_property_read_bool(node, "dual_emac"))
 		data->dual_emac = 1;
+#ifndef NO_SILC_MOD
+	if (of_property_read_bool(node, "slave_ncsi"))
+		data->slave_ncsi = 1;
+	data->slave_ncsi = 1;
+#endif
 
 	/*
 	 * Populate all the child nodes here...
@@ -3176,6 +3287,17 @@
 	ndev->netdev_ops = &cpsw_netdev_ops;
 	ndev->ethtool_ops = &cpsw_ethtool_ops;
 
+#ifndef NO_SILC_MOD
+	if(cpsw->data.slave_ncsi)
+	{
+		priv_sl2->ncsi_dev = ncsi_register_dev(ndev, cpsw_ncsi_handler);
+		if (!priv_sl2->ncsi_dev)
+		{
+			dev_err(cpsw->dev, "cpsw: failed to register with NCSI\n");
+			return -ENODEV;
+		}
+	}
+#endif
 	/* register the network device */
 	SET_NETDEV_DEV(ndev, cpsw->dev);
 	ret = register_netdev(ndev);
@@ -3226,6 +3348,20 @@
 };
 MODULE_DEVICE_TABLE(of, cpsw_of_mtable);
 
+#ifdef CONFIG_BCM5421_SUPPORT
+static int thread_fn(void *cpsw)
+{
+	while (1)
+	{
+		config_rgmi_sgmii();
+		ssleep(1);
+	}
+
+	do_exit(0);
+	return 0;
+}
+#endif
+
 static int cpsw_probe(struct platform_device *pdev)
 {
 	struct clk			*clk;
@@ -3521,6 +3657,18 @@
 
 	pm_runtime_put(&pdev->dev);
 
+#ifdef CONFIG_BCM5421_SUPPORT
+	if(g_bcm5421_exist)
+	{
+		thread_st = kthread_run(thread_fn, cpsw, "bcm5421_thread");
+
+		if (thread_st)
+			dev_info(&pdev->dev, "bcm5421 thread created successfully\n");
+		else
+			dev_err(&pdev->dev, "bcm5421 thread creation failed\n");
+	}
+#endif
+
 	return 0;
 
 clean_unregister_netdev_ret:
@@ -3537,6 +3685,19 @@
 	return ret;
 }
 
+#ifndef NO_SILC_MOD
+static void cpsw_slave_ncsi_deinit(struct cpsw_slave* slave)
+{
+	struct cpsw_priv* priv = slave_to_priv(slave);
+	if(priv->ncsi_dev && priv->ncsi_dev_started)
+		ncsi_stop_dev(priv->ncsi_dev);
+	priv->ncsi_dev_started = false;
+	if(priv->ncsi_dev)
+		ncsi_unregister_dev(priv->ncsi_dev);
+
+}
+#endif
+
 static int cpsw_remove(struct platform_device *pdev)
 {
 	struct net_device *ndev = platform_get_drvdata(pdev);
@@ -3549,8 +3710,26 @@
 		return ret;
 	}
 
+#ifdef CONFIG_BCM5421_SUPPORT
+	if (thread_st && g_bcm5421_exist == 1)
+	{
+		kthread_stop(thread_st);
+		dev_info(&pdev->dev, "bcm5421 thread stopped\n");
+	}
+#endif
+
 	if (cpsw->data.dual_emac)
+#ifndef NO_SILC_MOD
+	{
+		if(cpsw->data.slave_ncsi)
+		{
+			cpsw_slave_ncsi_deinit(&cpsw->slaves[1]);
+		}
+#endif
 		unregister_netdev(cpsw->slaves[1].ndev);
+#ifndef NO_SILC_MOD
+	}
+#endif
 	unregister_netdev(ndev);
 
 	cpts_release(cpsw->cpts);
--- linux-ti2018.02-rc4-int-orig/drivers/net/ethernet/ti/cpsw.h	2018-07-15 00:46:29.000000000 +0800
+++ linux-ti2018.02-rc4-int-silicom/drivers/net/ethernet/ti/cpsw.h	2020-03-09 10:47:12.123803445 +0800
@@ -24,4 +24,6 @@
 void cpsw_phy_sel(struct device *dev, phy_interface_t phy_mode, int slave);
 int ti_cm_get_macid(struct device *dev, int slave, u8 *mac_addr);
 
+#define ubmc_info	dev_info
+
 #endif /* __CPSW_H__ */
--- linux-ti2018.02-rc4-int-orig/drivers/net/ethernet/ti/cpsw-phy-sel.c	2018-07-15 00:46:29.000000000 +0800
+++ linux-ti2018.02-rc4-int-silicom/drivers/net/ethernet/ti/cpsw-phy-sel.c	2020-03-09 10:47:12.124803443 +0800
@@ -55,6 +55,10 @@
 	bool rgmii_id = false;
 
 	reg = readl(priv->gmii_sel);
+#ifndef NO_SILC_MOD
+	dev_info(priv->dev, "cpsw_gmii_sel_am3352 %u gmii-sel addr %p, orig value %08x\n", slave, priv->gmii_sel, reg);
+	dev_info(priv->dev, "cpsw_gmii_sel_am3352 %u phy_mode %u\n", slave, phy_mode);
+#endif
 
 	switch (phy_mode) {
 	case PHY_INTERFACE_MODE_RMII:
@@ -102,6 +106,15 @@
 
 	reg &= ~mask;
 	reg |= mode;
+#ifndef NO_SILC_MOD
+	if(slave == 1)
+	{// bit 7 rmii2_io_clk_en R/W 1h 0: RMII Reference Clock Output mode. Enable RMII clock to be
+	 // for enable this for ncsi
+		reg |= 0x80;
+	}
+	dev_info(priv->dev, "cpsw_gmii_sel_am3352 gmii-sel addr %p, new value %08x phy_mode %u\n",
+		 priv->gmii_sel, reg, phy_mode);
+#endif
 
 	writel(reg, priv->gmii_sel);
 }
--- linux-ti2018.02-rc4-int-orig/drivers/net/ethernet/ti/davinci_mdio.c	2018-07-15 00:46:29.000000000 +0800
+++ linux-ti2018.02-rc4-int-silicom/drivers/net/ethernet/ti/davinci_mdio.c	2020-03-09 10:47:12.125803442 +0800
@@ -42,6 +42,10 @@
 #include <linux/of_device.h>
 #include <linux/of_mdio.h>
 #include <linux/pinctrl/consumer.h>
+#ifdef CONFIG_BCM5421_SUPPORT
+#include "davinci_mdio_int.h"
+extern int g_bcm5421_exist ;
+#endif
 
 /*
  * This timeout definition is a worst-case ultra defensive measure against
@@ -108,6 +112,10 @@
 	u32		clk_div;
 };
 
+#ifdef CONFIG_BCM5421_SUPPORT
+struct davinci_mdio_data *mdio_data;
+#endif
+
 static void davinci_mdio_init_clk(struct davinci_mdio_data *data)
 {
 	u32 mdio_in, div, mdio_out_khz, access_time;
@@ -144,6 +152,99 @@
 	__raw_writel(data->clk_div | CONTROL_ENABLE, &data->regs->control);
 }
 
+#ifdef CONFIG_BCM5421_SUPPORT
+
+#define 	MII_PHYSID1   0x02	/* PHYS ID 1	*/
+#define 	MII_PHYSID2   0x03	/* PHYS ID 2	*/
+
+static int davinci_mdio_read(struct mii_bus *bus, int phy_id, int phy_reg);
+static int davinci_mdio_write(struct mii_bus *bus, int phy_id, int phy_reg, u16 phy_data);
+
+static int davinci_mdio_write_bcm5421(struct mii_bus *bus, int phy_id, int phy_reg, u16 phy_data)
+{
+	davinci_mdio_write(bus, phy_id, 0x1E, (u16)phy_reg);
+	udelay(50);
+	davinci_mdio_write(bus, phy_id, 0x1F, phy_data);
+	udelay(50);
+	return 0;
+}
+
+static int davinci_mdio_read_bcm5421(struct mii_bus *bus, int phy_id, int phy_reg)
+{
+        int val;
+
+	davinci_mdio_write(bus, phy_id, 0x1E, (u16)phy_reg);
+	udelay(50);
+	val = davinci_mdio_read(bus, phy_id, 0x1F);
+	udelay(50);
+	return val;
+}
+
+static void davinci_mdio_reg_dump_bcm5421(struct mii_bus *bus, int phy_id)
+{
+	int ret;
+
+	printk("\n0. +++++++ BCM5421: READ PHY IDs +++++++\n");
+	printk("MII_PHYSID1:\n");
+	ret = davinci_mdio_read(bus, phy_id, MII_PHYSID1);
+	printk("davinci_mdio_read() READ REG=0x%x VALUE=0x%x\n",
+	       MII_PHYSID1, ret);
+	printk("MII_PHYSID2:\n");
+	ret = davinci_mdio_read(bus, phy_id, MII_PHYSID2);
+	printk("davinci_mdio_read() READ REG=0x%x VALUE=0x%x\n",
+	       MII_PHYSID2, ret);
+
+	printk("\n1. +++++++ BCM5421: MODE_CONTROL RDB 0x21 +++++++\n");
+	ret = davinci_mdio_read_bcm5421(bus, 0, 0x021);
+	printk("davinci_mdio_read() READ REG=0x0021 VALUE=0x%x\n", ret);
+
+	printk("\n2. +++++++ BCM5421: READ IEEE Regs 0,1,4,5 +++++++\n");
+	ret = davinci_mdio_read(bus, 0, 0x0);
+	printk("davinci_mdio_read() READ REG=0x00 VALUE=0x%x\n", ret);
+	ret = davinci_mdio_read(bus, 0, 0x1);
+	printk("davinci_mdio_read() READ REG=0x01 VALUE=0x%x\n", ret);
+	ret = davinci_mdio_read(bus, 0, 0x4);
+	printk("davinci_mdio_read() READ REG=0x04 VALUE=0x%x\n", ret);
+	ret = davinci_mdio_read(bus, 0, 0x5);
+	printk("davinci_mdio_read() READ REG=0x05 VALUE=0x%x\n", ret);
+
+	printk("\n3. +++++++ BCM5421: READ RGMII_2_SGMII SLAVE regs +++++++\n");
+	ret = davinci_mdio_read_bcm5421(bus, 0, 0x002F);
+	printk("davinci_mdio_read() READ REG=0x002F VALUE=0x%x\n", ret);
+	ret = davinci_mdio_read_bcm5421(bus, 0, 0x0013);
+	printk("davinci_mdio_read() READ REG=0x0013 VALUE=0x%x\n", ret);
+	ret = davinci_mdio_read_bcm5421(bus, 0, 0x0810);
+	printk("davinci_mdio_read() READ REG=0x0810 VALUE=0x%x\n", ret);
+	ret = davinci_mdio_read_bcm5421(bus, 0, 0x0021);
+	printk("davinci_mdio_read() READ REG=0x0021 VALUE=0x%x\n", ret);
+	ret = davinci_mdio_read_bcm5421(bus, 0, 0x0000);
+	printk("davinci_mdio_read() READ REG=0x0000 VALUE=0x%x\n", ret);
+	ret = davinci_mdio_read_bcm5421(bus, 0, 0x0021);
+	printk("davinci_mdio_read() READ REG=0x0021 VALUE=0x%x\n", ret);
+	ret =davinci_mdio_read_bcm5421(bus, 0, 0x023E);
+	printk("davinci_mdio_read() READ REG=0x023E VALUE=0x%x\n", ret);
+	ret = davinci_mdio_read_bcm5421(bus, 0, 0x0235);
+	printk("davinci_mdio_read() READ REG=0x0235 VALUE=0x%x\n", ret);
+	ret = davinci_mdio_read_bcm5421(bus, 0, 0x0000);
+	printk("davinci_mdio_read() READ REG=0x0000 VALUE=0x%x\n", ret);
+}
+
+static void config_bcm5421_rgmi_sgmii(struct mii_bus *bus)
+{
+	davinci_mdio_write_bcm5421(bus, 0, 0x002F, 0x71E7);
+	davinci_mdio_write_bcm5421(bus, 0, 0x0013, 0x0E00);
+	davinci_mdio_write_bcm5421(bus, 0, 0x0810, 0x00B0);
+	davinci_mdio_write_bcm5421(bus, 0, 0x0021, 0x7C02);
+	davinci_mdio_write_bcm5421(bus, 0, 0x0000, 0x1940);
+	davinci_mdio_write_bcm5421(bus, 0, 0x0021, 0x7C03);
+	davinci_mdio_write_bcm5421(bus, 0, 0x023E, 0x78E2);
+#if 0 /* for SGMI Slave */
+	davinci_mdio_write_bcm5421(bus, 0, 0x0235, 0x5402);
+#endif
+	davinci_mdio_write_bcm5421(bus, 0, 0x0000, 0x1140);
+}
+#endif
+
 static int davinci_mdio_reset(struct mii_bus *bus)
 {
 	struct davinci_mdio_data *data = bus->priv;
@@ -161,6 +262,10 @@
 
 	/* dump hardware version info */
 	ver = __raw_readl(&data->regs->version);
+#ifdef CONFIG_BCM5421_SUPPORT
+	dev_info(data->dev,"Silicom davinci mdio version %d.%d\n", 1, 10);
+	mdio_data = data;
+#endif
 	dev_info(data->dev,
 		 "davinci mdio revision %d.%d, bus freq %ld\n",
 		 (ver >> 8) & 0xff, ver & 0xff,
@@ -175,6 +280,9 @@
 		/* restrict mdio bus to live phys only */
 		dev_info(data->dev, "detected phy mask %x\n", ~phy_mask);
 		phy_mask = ~phy_mask;
+#ifdef CONFIG_BCM5421_SUPPORT
+		config_bcm5421_rgmi_sgmii(bus);
+#endif
 	} else {
 		/* desperately scan all phys */
 		dev_warn(data->dev, "no live phy, scanning all\n");
@@ -437,7 +545,15 @@
 		ret = mdiobus_register(data->bus);
 	}
 	if (ret)
+	{
+#ifdef CONFIG_BCM5421_SUPPORT
+		g_bcm5421_exist = 0;
+#endif
 		goto bail_out;
+	}
+#ifdef CONFIG_BCM5421_SUPPORT
+		g_bcm5421_exist = 1;
+#endif
 
 	/* scan and dump the bus */
 	for (addr = 0; addr < PHY_MAX_ADDR; addr++) {
@@ -617,5 +733,52 @@
 }
 module_exit(davinci_mdio_exit);
 
+#ifdef CONFIG_BCM5421_SUPPORT
+void davinci_mdio_dump(void)
+{
+    davinci_mdio_reg_dump_bcm5421(mdio_data->bus, 0);
+}
+EXPORT_SYMBOL_GPL(davinci_mdio_dump);
+
+int davinci_mdio_reg_read(int phy_id, int phy_reg, int rdb_mode)
+{
+    if (rdb_mode == 1)
+    {
+	return davinci_mdio_read_bcm5421(mdio_data->bus, 0, phy_reg);
+    }
+    else
+    {
+	return davinci_mdio_read(mdio_data->bus, 0, phy_reg);
+    }
+}
+EXPORT_SYMBOL_GPL(davinci_mdio_reg_read);
+
+int davinci_mdio_reg_write(int phy_id, int phy_reg, int rdb_mode, u16 phy_data)
+{
+    if (rdb_mode == 1)
+    {
+	return davinci_mdio_write_bcm5421(mdio_data->bus, 0, phy_reg, phy_data);
+    }
+    else
+    {
+	return davinci_mdio_write(mdio_data->bus, 0, phy_reg, phy_data);
+    }
+}
+EXPORT_SYMBOL_GPL(davinci_mdio_reg_write);
+
+void config_rgmi_sgmii(void)
+{
+  int val;
+
+  val = davinci_mdio_read(mdio_data->bus, 0, 0x01);
+  udelay(50);
+  
+  if(!(val & (1<<2))) {
+	config_bcm5421_rgmi_sgmii(mdio_data->bus);
+  }
+}
+EXPORT_SYMBOL_GPL(config_rgmi_sgmii);
+#endif
+
 MODULE_LICENSE("GPL");
 MODULE_DESCRIPTION("DaVinci MDIO driver");
--- linux-ti2018.02-rc4-int-orig/drivers/net/ethernet/ti/davinci_mdio_int.h	2018-07-15 00:46:29.000000000 +0800
+++ linux-ti2018.02-rc4-int-silicom/drivers/net/ethernet/ti/davinci_mdio_int.h	2020-03-09 10:47:12.125803442 +0800
@@ -18,5 +18,12 @@
 			void __iomem *reg_base,
 			const char *clk_name);
 void davinci_mdio_release(struct davinci_mdio_data *mdio);
+#ifdef CONFIG_BCM5421_SUPPORT
+void davinci_mdio_dump(void);
+int davinci_mdio_reg_read(int phy_id, int phy_reg, int rdb_mode);
+int davinci_mdio_reg_write(int phy_id, int phy_reg, int rdb_mode, u16 phy_data);
+void config_rgmi_sgmii(void);
+extern int g_bcm5421_exist = 0;
+#endif
 
 #endif /* DAVINCI_MDIO_INT_H_ */
--- linux-ti2018.02-rc4-int-orig/drivers/net/ethernet/ti/Kconfig	2018-07-15 00:46:29.000000000 +0800
+++ linux-ti2018.02-rc4-int-silicom/drivers/net/ethernet/ti/Kconfig	2020-03-09 10:47:12.126803441 +0800
@@ -58,15 +58,19 @@
 	---help---
 	  This driver supports TI's CPSW ALE module.
 
+config BCM5421_SUPPORT
+	bool
+
 config TI_CPSW
 	tristate "TI CPSW Switch Support"
-	depends on ARCH_DAVINCI || ARCH_OMAP2PLUS
+	depends on ARCH_DAVINCI || ARCH_OMAP2PLUS || NET_NCSI
 	select TI_DAVINCI_CPDMA
 	select TI_DAVINCI_MDIO
 	select TI_CPSW_PHY_SEL
 	select TI_CPSW_ALE
 	select MFD_SYSCON
 	select REGMAP
+	select BCM5421_SUPPORT
 	---help---
 	  This driver supports TI's CPSW Ethernet Switch.
 
--- linux-ti2018.02-rc4-int-orig/net/ncsi/ncsi-aen.c	2018-07-15 00:46:30.000000000 +0800
+++ linux-ti2018.02-rc4-int-silicom/net/ncsi/ncsi-aen.c	2020-03-09 10:47:12.127803440 +0800
@@ -116,11 +116,11 @@
 
 	ncsi_stop_channel_monitor(nc);
 	spin_lock_irqsave(&nc->lock, flags);
-	nc->state = NCSI_CHANNEL_INVISIBLE;
+	ncsi_channel_state_set(nc, NCSI_CHANNEL_INVISIBLE);
 	spin_unlock_irqrestore(&nc->lock, flags);
 
 	spin_lock_irqsave(&ndp->lock, flags);
-	nc->state = NCSI_CHANNEL_INACTIVE;
+	ncsi_channel_state_set(nc, NCSI_CHANNEL_INACTIVE);
 	list_add_tail_rcu(&nc->link, &ndp->channel_queue);
 	spin_unlock_irqrestore(&ndp->lock, flags);
 
@@ -166,8 +166,8 @@
 	ncsi_stop_channel_monitor(nc);
 
 	spin_lock_irqsave(&nc->lock, flags);
-	nc->state = (ncm->data[3] & 0x1) ? NCSI_CHANNEL_INACTIVE :
-					   NCSI_CHANNEL_ACTIVE;
+	ncsi_channel_state_set(nc, (ncm->data[3] & 0x1) ? NCSI_CHANNEL_INACTIVE :
+					   NCSI_CHANNEL_ACTIVE);
 	spin_unlock_irqrestore(&nc->lock, flags);
 
 	spin_lock_irqsave(&ndp->lock, flags);
--- linux-ti2018.02-rc4-int-orig/net/ncsi/ncsi-cmd.c	2018-07-15 00:46:30.000000000 +0800
+++ linux-ti2018.02-rc4-int-silicom/net/ncsi/ncsi-cmd.c	2020-03-09 10:47:13.183802173 +0800
@@ -47,8 +47,7 @@
 	h->reserved     = 0;
 	h->id           = nca->id;
 	h->type         = nca->type;
-	h->channel      = NCSI_TO_CHANNEL(nca->package,
-					  nca->channel);
+	h->channel      = NCSI_TO_CHANNEL(nca->package, nca->channel);
 	h->length       = htons(nca->payload);
 	h->reserved1[0] = 0;
 	h->reserved1[1] = 0;
@@ -56,8 +55,18 @@
 	/* Fill with calculated checksum */
 	checksum = ncsi_calculate_checksum((unsigned char *)h,
 					   sizeof(*h) + nca->payload);
-	pchecksum = (__be32 *)((void *)h + sizeof(struct ncsi_pkt_hdr) +
-		    nca->payload);
+
+#ifdef NO_SILC_MOD
+	pchecksum = (__be32 *)((void *)(h + 1) + sizeof(struct ncsi_pkt_hdr) +
+			nca->payload);
+#else
+	/*
+	 * Blair Wang :
+	 *  The value of payload does not include the padding in NCSI packet.
+	 *  For Intel i210 oem command 0x20, it's payload length must is 7.
+	 **/
+	pchecksum = (__be32 *)((void *)(h + 1) + NCSI_PAYLOAD_ELEN(nca->payload));
+#endif
 	*pchecksum = htonl(checksum);
 }
 
@@ -211,6 +220,24 @@
 	return 0;
 }
 
+#ifndef NO_SILC_MOD
+static int ncsi_cmd_handler_oem_i210(struct sk_buff *skb,
+				 struct ncsi_cmd_arg *nca)
+{
+	struct ncsi_oem_i210_cmd_mgmt_pkt *cmd;
+
+	cmd = (struct ncsi_oem_i210_cmd_mgmt_pkt *)skb_put_zero(skb, sizeof(*cmd));
+	//see i210 data sheet 10.6.3
+	cmd->oem_id = htonl(0x157);
+	cmd->intel_cmd = 0x20U;
+	cmd->value1 = 0x0;
+	cmd->mgmt_ctl = 1;
+	ncsi_cmd_build_header(&cmd->cmd.common, nca);
+
+	return 0;
+}
+#endif
+
 static struct ncsi_cmd_handler {
 	unsigned char type;
 	int           payload;
@@ -244,7 +271,11 @@
 	{ NCSI_PKT_CMD_GNS,    0, ncsi_cmd_handler_default },
 	{ NCSI_PKT_CMD_GNPTS,  0, ncsi_cmd_handler_default },
 	{ NCSI_PKT_CMD_GPS,    0, ncsi_cmd_handler_default },
+#ifndef NO_SILC_MOD
+	{ NCSI_PKT_CMD_OEM,    7, ncsi_cmd_handler_oem_i210},
+#else
 	{ NCSI_PKT_CMD_OEM,    0, NULL                     },
+#endif
 	{ NCSI_PKT_CMD_PLDM,   0, NULL                     },
 	{ NCSI_PKT_CMD_GPUUID, 0, ncsi_cmd_handler_default }
 };
@@ -264,8 +295,9 @@
 	if (!nr)
 		return NULL;
 
+#ifdef NO_SILC_MOD
 	/* NCSI command packet has 16-bytes header, payload, 4 bytes checksum.
-	 * The packet needs padding if its payload is less than 26 bytes to
+	 * The packet needs padding if its payload is less than 28 bytes to
 	 * meet 64 bytes minimal ethernet frame length.
 	 */
 	len += sizeof(struct ncsi_cmd_pkt_hdr) + 4;
@@ -273,6 +305,17 @@
 		len += 26;
 	else
 		len += nca->payload;
+#else
+	/*
+	 * Blair Wang -
+	 *  We should meet the requirement for VLAN_ETH_ZLEN
+	 */
+	len += sizeof(struct ncsi_cmd_pkt_hdr) + 4;
+	if (NCSI_PAYLOAD_ELEN(nca->payload) < 30)
+		len += 30;
+	else
+		len += NCSI_PAYLOAD_ELEN(nca->payload);
+#endif
 
 	/* Allocate skb */
 	skb = alloc_skb(len, GFP_ATOMIC);
@@ -291,6 +334,377 @@
 	return nr;
 }
 
+#ifndef NO_SILC_MOD
+static struct ncsi_cmd_name {
+	unsigned char type;
+	char* name;
+	char* desc;
+} ncsi_cmd_names[] = {
+		{ NCSI_PKT_CMD_CIS   , "CIS   ", "ClrInitState"},
+		{ NCSI_PKT_CMD_SP    , "SP    ", "SelPkg      "},
+		{ NCSI_PKT_CMD_DP    , "DP    ", "DeSelPkg    "},
+		{ NCSI_PKT_CMD_EC    , "EC    ", "EnaChannel  "},
+		{ NCSI_PKT_CMD_DC    , "DC    ", "DisChannel  "},
+		{ NCSI_PKT_CMD_RC    , "RC    ", "ResetChannel"},
+		{ NCSI_PKT_CMD_ECNT  , "ECNT  ", "EnaChanNetTX"},
+		{ NCSI_PKT_CMD_DCNT  , "DCNT  ", "DisChanNetTX"},
+		{ NCSI_PKT_CMD_AE    , "AE    ", "AenEna      "},
+		{ NCSI_PKT_CMD_SL    , "SL    ", "SetLink     "},
+		{ NCSI_PKT_CMD_GLS   , "GLS   ", "GetLinkSta  "},
+		{ NCSI_PKT_CMD_SVF   , "SVF   ", "SetVLANFltr "},
+		{ NCSI_PKT_CMD_EV    , "EV    ", "EnaVLan     "},
+		{ NCSI_PKT_CMD_DV    , "DV    ", "DisVLan     "},
+		{ NCSI_PKT_CMD_SMA   , "SMA   ", "SetMacAddr  "},
+		{ NCSI_PKT_CMD_EBF   , "EBF   ", "EnaBcastFltr"},
+		{ NCSI_PKT_CMD_DBF   , "DBF   ", "DisBcastFltr"},
+		{ NCSI_PKT_CMD_EGMF  , "EGMF  ", "EnaGloMcastF"},
+		{ NCSI_PKT_CMD_DGMF  , "DGMF  ", "DisGloMcastF"},
+		{ NCSI_PKT_CMD_SNFC  , "SNFC  ", "SetFlowCtrl "},
+		{ NCSI_PKT_CMD_GVI   , "GVI   ", "GetVersion  "},
+		{ NCSI_PKT_CMD_GC    , "GC    ", "GetCapa     "},
+		{ NCSI_PKT_CMD_GP    , "GP    ", "GetParam    "},
+		{ NCSI_PKT_CMD_GCPS  , "GCPS  ", "GetCntlPktSt"},
+		{ NCSI_PKT_CMD_GNS   , "GNS   ", "GetNCSIPktSt"},
+		{ NCSI_PKT_CMD_GNPTS , "GNPTS ", "GetPassThrSt"},
+		{ NCSI_PKT_CMD_GPS   , "GPS   ", "GetPkgStatus"},
+		{ NCSI_PKT_CMD_OEM   , "OEM   ", "OEMCommand  "},
+		{ NCSI_PKT_CMD_PLDM  , "PLDM  ", "PLDM        "},
+		{ NCSI_PKT_CMD_GPUUID, "GPUUID", "GPUUID      "},
+		{ 0xFFU              , "AED   ", "AEN         "},
+};
+static char ncsi_cmd_type_name_hex[32];
+
+char* ncsi_cmd_type_name_get(unsigned char type)
+{
+	uint32_t i;
+	for (i = 0; i < ARRAY_SIZE(ncsi_cmd_names); i++) {
+		if (ncsi_cmd_names[i].type == type) {
+			return ncsi_cmd_names[i].desc;
+		}
+	}
+	sprintf(ncsi_cmd_type_name_hex,  "UNK:0x%02x   ", type);
+	return ncsi_cmd_type_name_hex;
+}
+
+
+char ncsi_xmit_cmd_dump_buf[2048];
+#define NCSI_DUMP_PRN(fmt, ...)	\
+	do{ buf_off += sprintf(buf + buf_off, fmt, ## __VA_ARGS__ ); } while(0)
+#define NCSI_DUMP_FIELD_STR(parent_type, field)	\
+	do{ struct parent_type* __p_parent_struct = p_ncsi_head; \
+		buf_off += sprintf(buf + buf_off, "%s[%s]", #field, __p_parent_struct->field ); } while(0)
+
+#define NCSI_DUMP_FIELD_U8(parent_type, field)	\
+	do{ struct parent_type* __p_parent_struct = p_ncsi_head; \
+		buf_off += sprintf(buf + buf_off, "%s[%02x]", #field, __p_parent_struct->field ); } while(0)
+
+#define NCSI_DUMP_FIELD_U32(parent_type, field)	\
+	do{ struct parent_type* __p_parent_struct = p_ncsi_head; \
+		buf_off += sprintf(buf + buf_off, "%s[%08x]", #field, ntohl(__p_parent_struct->field) ); } while(0)
+
+#define NCSI_DUMP_FIELD_U16(parent_type, field)	\
+	do{ struct parent_type* __p_parent_struct = p_ncsi_head; \
+		buf_off += sprintf(buf + buf_off, "%s[%04x]", #field, ntohs(__p_parent_struct->field) ); } while(0)
+
+#define NCSI_DUMP_FIELD_MAC(parent_type, field)	\
+	do{ struct parent_type* __p_parent_struct = p_ncsi_head; \
+		buf_off += sprintf(buf + buf_off, "%s[%02x:%02x:%02x:%02x:%02x:%02x]",\
+				#field, __p_parent_struct->field[0], __p_parent_struct->field[1], \
+				__p_parent_struct->field[2], __p_parent_struct->field[3], \
+				__p_parent_struct->field[4], __p_parent_struct->field[5]); } while(0)
+
+
+#ifdef NCSI_CMD_DUMP
+void ncsi_cmd_dump(struct net_device* n, void* pkt)
+{
+	void* p_ncsi_head =  pkt;
+	struct ncsi_pkt_hdr* h  = p_ncsi_head;
+	struct ncsi_rsp_pkt_hdr* rsp = p_ncsi_head;
+	struct ncsi_aen_pkt_hdr* aen_hdr = p_ncsi_head;
+	uint8_t cmd_type = h->type & 0x7fU;
+	uint8_t is_resp = h->type &0x80U;
+	uint8_t is_aen = h->type == 0xFFU;
+	char* buf = ncsi_xmit_cmd_dump_buf;
+	uint32_t buf_off = 0;
+	NCSI_DUMP_PRN("id[%02x] typ[%s] chn[%02x] len[%3u]",
+			h->id,
+			ncsi_cmd_type_name_get(cmd_type),
+			h->channel,
+			htons(h->length) & 0xFFF);
+	if(is_resp)
+		NCSI_DUMP_PRN("Rsp[%04x] Reason[%04x]", ntohs(rsp->code), ntohs(rsp->reason));
+	if(is_aen)
+	{
+		char* aen_name;
+		struct ncsi_aen_lsc_pkt *lsc;
+		switch(aen_hdr->type)
+		{
+		case NCSI_PKT_AEN_LSC:
+			lsc = p_ncsi_head;
+			aen_name = "LinkChg   ";
+			NCSI_DUMP_PRN("AType[%s] Link[%x] OemLink[%x]", aen_name, ntohl(lsc->status), ntohl(lsc->oem_status));
+			break;
+		case NCSI_PKT_AEN_CR:
+			aen_name = "CfgChg    ";
+			NCSI_DUMP_PRN("AType[%s]", aen_name);
+			break;
+		case NCSI_PKT_AEN_HNCDSC:
+			aen_name = "HostDrvChg";
+			NCSI_DUMP_PRN("AType[%s]", aen_name);
+			break;
+		}
+		return;
+	}
+
+	switch(h->type)
+	{
+	case NCSI_PKT_CMD_CIS:
+		break;
+	case NCSI_PKT_CMD_SP:
+		NCSI_DUMP_FIELD_U8(ncsi_cmd_sp_pkt, hw_arbitration);
+		break;
+	case NCSI_PKT_CMD_DP	 :
+		break;
+	case NCSI_PKT_CMD_EC	 :
+		break;
+	case NCSI_PKT_CMD_DC	 :
+		NCSI_DUMP_FIELD_U8(ncsi_cmd_dc_pkt, ald);
+		break;
+	case NCSI_PKT_CMD_RC	 :
+		break;
+	case NCSI_PKT_CMD_ECNT	 :
+		break;
+	case NCSI_PKT_CMD_DCNT	 :
+		break;
+	case NCSI_PKT_CMD_AE	 :
+		NCSI_DUMP_FIELD_U8(ncsi_cmd_ae_pkt, mc_id);
+		NCSI_DUMP_FIELD_U32(ncsi_cmd_ae_pkt, mode);
+		break;
+	case NCSI_PKT_CMD_SL	 :
+		NCSI_DUMP_FIELD_U32(ncsi_cmd_sl_pkt, mode);
+		NCSI_DUMP_FIELD_U32(ncsi_cmd_sl_pkt, oem_mode);
+		break;
+	case NCSI_PKT_CMD_GLS	 :
+		return;//don't dump gls
+		break;
+	case NCSI_PKT_CMD_SVF	 :
+		NCSI_DUMP_FIELD_U16(ncsi_cmd_svf_pkt, vlan);
+		NCSI_DUMP_FIELD_U8(ncsi_cmd_svf_pkt, index);
+		NCSI_DUMP_FIELD_U8(ncsi_cmd_svf_pkt, enable);
+		break;
+	case NCSI_PKT_CMD_EV	 :
+		NCSI_DUMP_FIELD_U8(ncsi_cmd_ev_pkt, mode);
+		break;
+	case NCSI_PKT_CMD_DV	 :
+		break;
+	case NCSI_PKT_CMD_SMA	 :
+		NCSI_DUMP_FIELD_MAC(ncsi_cmd_sma_pkt, mac);
+		NCSI_DUMP_FIELD_U8(ncsi_cmd_sma_pkt, index);
+		NCSI_DUMP_FIELD_U8(ncsi_cmd_sma_pkt, at_e);
+		break;
+	case NCSI_PKT_CMD_EBF	 :
+		NCSI_DUMP_FIELD_U32(ncsi_cmd_ebf_pkt, mode);
+		break;
+	case NCSI_PKT_CMD_DBF	 :
+		break;
+	case NCSI_PKT_CMD_EGMF	 :
+		NCSI_DUMP_FIELD_U32(ncsi_cmd_ebf_pkt, mode);
+		break;
+	case NCSI_PKT_CMD_DGMF	 :
+		break;
+	case NCSI_PKT_CMD_SNFC	 :
+		NCSI_DUMP_FIELD_U8(ncsi_cmd_snfc_pkt, mode);
+		break;
+	case NCSI_PKT_CMD_GVI	 :
+		break;
+	case NCSI_PKT_CMD_GC	 :
+		break;
+	case NCSI_PKT_CMD_GP	 :
+		break;
+	case NCSI_PKT_CMD_GCPS	 :
+		break;
+	case NCSI_PKT_CMD_GNS	 :
+		break;
+	case NCSI_PKT_CMD_GNPTS	 :
+		break;
+	case NCSI_PKT_CMD_GPS	 :
+		break;
+	case NCSI_PKT_CMD_OEM	 :
+		NCSI_DUMP_FIELD_U32(ncsi_oem_i210_cmd_mgmt_pkt, oem_id );
+		NCSI_DUMP_FIELD_U8(ncsi_oem_i210_cmd_mgmt_pkt, intel_cmd );
+		NCSI_DUMP_FIELD_U8(ncsi_oem_i210_cmd_mgmt_pkt, value1);
+		NCSI_DUMP_FIELD_U8(ncsi_oem_i210_cmd_mgmt_pkt, mgmt_ctl);
+		break;
+	case NCSI_PKT_CMD_PLDM	 :
+		break;
+	case NCSI_PKT_CMD_GPUUID :
+		break;
+
+	case NCSI_PKT_RSP_CIS	 :
+		break;
+	case NCSI_PKT_RSP_SP	 :
+		break;
+	case NCSI_PKT_RSP_DP	 :
+	case NCSI_PKT_RSP_EC	 :
+	case NCSI_PKT_RSP_DC	 :
+	case NCSI_PKT_RSP_RC	 :
+	case NCSI_PKT_RSP_ECNT	 :
+	case NCSI_PKT_RSP_DCNT	 :
+	case NCSI_PKT_RSP_AE	 :
+	case NCSI_PKT_RSP_SL	 :
+		break;
+	case NCSI_PKT_RSP_GLS	 :
+		return; //don't dump gls
+		NCSI_DUMP_FIELD_U32(ncsi_rsp_gls_pkt, status);
+		NCSI_DUMP_FIELD_U32(ncsi_rsp_gls_pkt, other);
+		NCSI_DUMP_FIELD_U32(ncsi_rsp_gls_pkt, oem_status);
+		break;
+	case NCSI_PKT_RSP_SVF	 :
+	case NCSI_PKT_RSP_EV	 :
+	case NCSI_PKT_RSP_DV	 :
+	case NCSI_PKT_RSP_SMA	 :
+	case NCSI_PKT_RSP_EBF	 :
+	case NCSI_PKT_RSP_DBF	 :
+	case NCSI_PKT_RSP_EGMF	 :
+	case NCSI_PKT_RSP_DGMF	 :
+	case NCSI_PKT_RSP_SNFC	 :
+		break;
+	case NCSI_PKT_RSP_GVI	 :
+		NCSI_DUMP_FIELD_U32(ncsi_rsp_gvi_pkt, ncsi_version);
+		NCSI_DUMP_FIELD_U8(ncsi_rsp_gvi_pkt, alpha2);
+		NCSI_DUMP_FIELD_STR(ncsi_rsp_gvi_pkt, fw_name);
+		NCSI_DUMP_FIELD_U32(ncsi_rsp_gvi_pkt, fw_version);
+		NCSI_DUMP_FIELD_U16(ncsi_rsp_gvi_pkt, pci_ids[0]);
+		NCSI_DUMP_FIELD_U16(ncsi_rsp_gvi_pkt, pci_ids[1]);
+		NCSI_DUMP_FIELD_U16(ncsi_rsp_gvi_pkt, pci_ids[2]);
+		NCSI_DUMP_FIELD_U16(ncsi_rsp_gvi_pkt, pci_ids[3]);
+		NCSI_DUMP_FIELD_U32(ncsi_rsp_gvi_pkt, mf_id);
+		break;
+	case NCSI_PKT_RSP_GC	 :
+		NCSI_DUMP_FIELD_U32(ncsi_rsp_gc_pkt, cap);
+		NCSI_DUMP_FIELD_U32(ncsi_rsp_gc_pkt, bc_cap);
+		NCSI_DUMP_FIELD_U32(ncsi_rsp_gc_pkt, mc_cap);
+		NCSI_DUMP_FIELD_U32(ncsi_rsp_gc_pkt, buf_cap);
+		NCSI_DUMP_FIELD_U32(ncsi_rsp_gc_pkt, aen_cap);
+		NCSI_DUMP_FIELD_U8(ncsi_rsp_gc_pkt, vlan_cnt);
+		NCSI_DUMP_FIELD_U8(ncsi_rsp_gc_pkt, mixed_cnt);
+		NCSI_DUMP_FIELD_U8(ncsi_rsp_gc_pkt, mc_cnt);
+		NCSI_DUMP_FIELD_U8(ncsi_rsp_gc_pkt, uc_cnt);
+		NCSI_DUMP_FIELD_U8(ncsi_rsp_gc_pkt, vlan_mode);
+		break;
+	case NCSI_PKT_RSP_GP	 :
+		NCSI_DUMP_FIELD_U8(ncsi_rsp_gp_pkt, mac_cnt);
+		NCSI_DUMP_FIELD_U8(ncsi_rsp_gp_pkt, mac_enable);
+		NCSI_DUMP_FIELD_U8(ncsi_rsp_gp_pkt, vlan_cnt);
+		NCSI_DUMP_FIELD_U16(ncsi_rsp_gp_pkt, vlan_enable);
+		NCSI_DUMP_FIELD_U32(ncsi_rsp_gp_pkt, link_mode);
+		NCSI_DUMP_FIELD_U32(ncsi_rsp_gp_pkt, bc_mode);
+		NCSI_DUMP_FIELD_U32(ncsi_rsp_gp_pkt, valid_modes);
+		NCSI_DUMP_FIELD_U8(ncsi_rsp_gp_pkt, vlan_mode);
+		NCSI_DUMP_FIELD_U8(ncsi_rsp_gp_pkt, fc_mode);
+		NCSI_DUMP_FIELD_U32(ncsi_rsp_gp_pkt, aen_mode);
+		NCSI_DUMP_FIELD_MAC(ncsi_rsp_gp_pkt, mac);
+		NCSI_DUMP_FIELD_U16(ncsi_rsp_gp_pkt, vlan);
+		break;
+	case NCSI_PKT_RSP_GCPS	 :
+		NCSI_DUMP_FIELD_U32(ncsi_rsp_gcps_pkt, cnt_hi         );
+		NCSI_DUMP_FIELD_U32(ncsi_rsp_gcps_pkt, cnt_lo         );
+		NCSI_DUMP_FIELD_U32(ncsi_rsp_gcps_pkt, rx_bytes       );
+		NCSI_DUMP_FIELD_U32(ncsi_rsp_gcps_pkt, tx_bytes       );
+		NCSI_DUMP_FIELD_U32(ncsi_rsp_gcps_pkt, rx_uc_pkts     );
+		NCSI_DUMP_FIELD_U32(ncsi_rsp_gcps_pkt, rx_mc_pkts     );
+		NCSI_DUMP_FIELD_U32(ncsi_rsp_gcps_pkt, rx_bc_pkts     );
+		NCSI_DUMP_FIELD_U32(ncsi_rsp_gcps_pkt, tx_uc_pkts     );
+		NCSI_DUMP_FIELD_U32(ncsi_rsp_gcps_pkt, tx_mc_pkts     );
+		NCSI_DUMP_FIELD_U32(ncsi_rsp_gcps_pkt, tx_bc_pkts     );
+		NCSI_DUMP_FIELD_U32(ncsi_rsp_gcps_pkt, fcs_err        );
+		NCSI_DUMP_FIELD_U32(ncsi_rsp_gcps_pkt, align_err      );
+		NCSI_DUMP_FIELD_U32(ncsi_rsp_gcps_pkt, false_carrier  );
+		NCSI_DUMP_FIELD_U32(ncsi_rsp_gcps_pkt, runt_pkts      );
+		NCSI_DUMP_FIELD_U32(ncsi_rsp_gcps_pkt, jabber_pkts    );
+		NCSI_DUMP_FIELD_U32(ncsi_rsp_gcps_pkt, rx_pause_xon   );
+		NCSI_DUMP_FIELD_U32(ncsi_rsp_gcps_pkt, rx_pause_xoff  );
+		NCSI_DUMP_FIELD_U32(ncsi_rsp_gcps_pkt, tx_pause_xon   );
+		NCSI_DUMP_FIELD_U32(ncsi_rsp_gcps_pkt, tx_pause_xoff  );
+		NCSI_DUMP_FIELD_U32(ncsi_rsp_gcps_pkt, tx_s_collision );
+		NCSI_DUMP_FIELD_U32(ncsi_rsp_gcps_pkt, tx_m_collision );
+		NCSI_DUMP_FIELD_U32(ncsi_rsp_gcps_pkt, l_collision    );
+		NCSI_DUMP_FIELD_U32(ncsi_rsp_gcps_pkt, e_collision    );
+		NCSI_DUMP_FIELD_U32(ncsi_rsp_gcps_pkt, rx_ctl_frames  );
+		NCSI_DUMP_FIELD_U32(ncsi_rsp_gcps_pkt, rx_64_frames   );
+		NCSI_DUMP_FIELD_U32(ncsi_rsp_gcps_pkt, rx_127_frames  );
+		NCSI_DUMP_FIELD_U32(ncsi_rsp_gcps_pkt, rx_255_frames  );
+		NCSI_DUMP_FIELD_U32(ncsi_rsp_gcps_pkt, rx_511_frames  );
+		NCSI_DUMP_FIELD_U32(ncsi_rsp_gcps_pkt, rx_1023_frames );
+		NCSI_DUMP_FIELD_U32(ncsi_rsp_gcps_pkt, rx_1522_frames );
+		NCSI_DUMP_FIELD_U32(ncsi_rsp_gcps_pkt, rx_9022_frames );
+		NCSI_DUMP_FIELD_U32(ncsi_rsp_gcps_pkt, tx_64_frames   );
+		NCSI_DUMP_FIELD_U32(ncsi_rsp_gcps_pkt, tx_127_frames  );
+		NCSI_DUMP_FIELD_U32(ncsi_rsp_gcps_pkt, tx_255_frames  );
+		NCSI_DUMP_FIELD_U32(ncsi_rsp_gcps_pkt, tx_511_frames  );
+		NCSI_DUMP_FIELD_U32(ncsi_rsp_gcps_pkt, tx_1023_frames );
+		NCSI_DUMP_FIELD_U32(ncsi_rsp_gcps_pkt, tx_1522_frames );
+		NCSI_DUMP_FIELD_U32(ncsi_rsp_gcps_pkt, tx_9022_frames );
+		NCSI_DUMP_FIELD_U32(ncsi_rsp_gcps_pkt, rx_valid_bytes );
+		NCSI_DUMP_FIELD_U32(ncsi_rsp_gcps_pkt, rx_runt_pkts   );
+		NCSI_DUMP_FIELD_U32(ncsi_rsp_gcps_pkt, rx_jabber_pkts );
+		break;
+	case NCSI_PKT_RSP_GNS	 :
+		NCSI_DUMP_FIELD_U32(ncsi_rsp_gns_pkt, rx_cmds );
+		NCSI_DUMP_FIELD_U32(ncsi_rsp_gns_pkt, dropped_cmds );
+		NCSI_DUMP_FIELD_U32(ncsi_rsp_gns_pkt, cmd_type_errs );
+		NCSI_DUMP_FIELD_U32(ncsi_rsp_gns_pkt, cmd_csum_errs );
+		NCSI_DUMP_FIELD_U32(ncsi_rsp_gns_pkt, rx_pkts );
+		NCSI_DUMP_FIELD_U32(ncsi_rsp_gns_pkt, tx_pkts );
+		NCSI_DUMP_FIELD_U32(ncsi_rsp_gns_pkt, tx_aen_pkts );
+		break;
+	case NCSI_PKT_RSP_GNPTS	 :
+		NCSI_DUMP_FIELD_U32(ncsi_rsp_gnpts_pkt, tx_pkts );
+		NCSI_DUMP_FIELD_U32(ncsi_rsp_gnpts_pkt, tx_dropped );
+		NCSI_DUMP_FIELD_U32(ncsi_rsp_gnpts_pkt, tx_channel_err );
+		NCSI_DUMP_FIELD_U32(ncsi_rsp_gnpts_pkt, tx_us_err );
+		NCSI_DUMP_FIELD_U32(ncsi_rsp_gnpts_pkt, rx_pkts );
+		NCSI_DUMP_FIELD_U32(ncsi_rsp_gnpts_pkt, rx_dropped );
+		NCSI_DUMP_FIELD_U32(ncsi_rsp_gnpts_pkt, rx_channel_err );
+		NCSI_DUMP_FIELD_U32(ncsi_rsp_gnpts_pkt, rx_us_err );
+		NCSI_DUMP_FIELD_U32(ncsi_rsp_gnpts_pkt, rx_os_err );
+		break;
+	case NCSI_PKT_RSP_GPS	 :
+		NCSI_DUMP_FIELD_U32(ncsi_rsp_gps_pkt, status );
+		break;
+	case NCSI_PKT_RSP_OEM	 :
+		NCSI_DUMP_FIELD_U32(ncsi_rsp_oem_i210_cmd_mgmt_pkt, oem_id );
+		NCSI_DUMP_FIELD_U8(ncsi_rsp_oem_i210_cmd_mgmt_pkt, intel_cmd );
+		NCSI_DUMP_FIELD_U8(ncsi_rsp_oem_i210_cmd_mgmt_pkt, value1);
+		break;
+	case NCSI_PKT_RSP_PLDM	 :
+	case NCSI_PKT_RSP_GPUUID :
+		break;
+	case NCSI_PKT_AEN:
+		switch(aen_hdr->type) {
+		case NCSI_PKT_AEN_LSC	: /*Link status change       */
+			NCSI_DUMP_PRN("[AEN_LSC]");
+			NCSI_DUMP_FIELD_U32(ncsi_aen_lsc_pkt, status );
+			NCSI_DUMP_FIELD_U32(ncsi_aen_lsc_pkt, oem_status );
+			break;
+		case NCSI_PKT_AEN_CR	: /* Configuration required   */
+			NCSI_DUMP_PRN("[AEN_CR]");
+			break;
+		case NCSI_PKT_AEN_HNCDSC: /* HNC driver status change */
+			NCSI_DUMP_PRN("[AEN_HNCDSC]");
+			NCSI_DUMP_FIELD_U32(ncsi_aen_hncdsc_pkt, status );
+			break;
+		}
+		break;
+	}
+
+	netdev_warn(n, "%s\n", ncsi_xmit_cmd_dump_buf);
+
+}
+EXPORT_SYMBOL_GPL(ncsi_cmd_dump);
+#endif	//NCSI_CMD_DUMP
+#endif	//NO_SILC_MOD
+
 int ncsi_xmit_cmd(struct ncsi_cmd_arg *nca)
 {
 	struct ncsi_request *nr;
@@ -344,6 +758,9 @@
 	mod_timer(&nr->timer, jiffies + 1 * HZ);
 
 	/* Send NCSI packet */
+#ifndef NO_SILC_MOD
+	ncsi_cmd_dump(nca->ndp->ndev.dev, eh+1);
+#endif
 	skb_get(nr->cmd);
 	ret = dev_queue_xmit(nr->cmd);
 	if (ret < 0) {
--- linux-ti2018.02-rc4-int-orig/net/ncsi/ncsi-rsp.c	2018-07-15 00:46:30.000000000 +0800
+++ linux-ti2018.02-rc4-int-silicom/net/ncsi/ncsi-rsp.c	2020-03-09 10:47:13.201802152 +0800
@@ -20,12 +20,18 @@
 #include "internal.h"
 #include "ncsi-pkt.h"
 
+
 static int ncsi_validate_rsp_pkt(struct ncsi_request *nr,
 				 unsigned short payload)
 {
 	struct ncsi_rsp_pkt_hdr *h;
+#ifdef NO_SILC_MOD
 	u32 checksum;
 	__be32 *pchecksum;
+#endif
+#ifdef SILC_EXTRA_DBG
+	unsigned expected_len;
+#endif
 
 	/* Check NCSI packet header. We don't need validate
 	 * the packet type, which should have been checked
@@ -37,6 +43,18 @@
 	if (ntohs(h->common.length) != payload)
 		return -EINVAL;
 
+#ifdef SILC_EXTRA_DBG
+	expected_len = ntohs(h->common.length) + skb_mac_header_len(nr->rsp) +
+			                    sizeof(h->common) + 4;
+	if (nr->rsp->len < expected_len) {
+		ncsi_warn("Failed : skb len %d, expected %d\n",
+					 nr->rsp->len, expected_len);
+
+    print_hex_dump(KERN_WARNING, "EE : ", DUMP_PREFIX_OFFSET,
+                   16, 1, skb_mac_header(nr->rsp), nr->rsp->len, 0);
+	}
+#endif
+
 	/* Check on code and reason */
 	if (ntohs(h->code) != NCSI_PKT_RSP_C_COMPLETED ||
 	    ntohs(h->reason) != NCSI_PKT_RSP_R_NO_ERROR)
@@ -46,7 +64,14 @@
 	 * sender doesn't support checksum according to NCSI
 	 * specification.
 	 */
-	pchecksum = (__be32 *)((void *)(h + 1) + payload - 4);
+  /*
+   * Blair Wang:
+   *  There're some data loss in the repsonse packet from Intel i210,
+   *  such as GetVersion, GetCapa and GetLinkSta.
+   *  So, disable the checking for checksum.
+   */
+#ifdef NO_SILC_MOD
+	pchecksum = (__be32 *)((void *)(h + 1) + payload);
 	if (ntohl(*pchecksum) == 0)
 		return 0;
 
@@ -54,6 +79,7 @@
 					   sizeof(*h) + payload - 4);
 	if (*pchecksum != htonl(checksum))
 		return -EINVAL;
+#endif
 
 	return 0;
 }
@@ -123,7 +149,7 @@
 	/* Change state of all channels attached to the package */
 	NCSI_FOR_EACH_CHANNEL(np, nc) {
 		spin_lock_irqsave(&nc->lock, flags);
-		nc->state = NCSI_CHANNEL_INACTIVE;
+		ncsi_channel_state_set(nc, NCSI_CHANNEL_INACTIVE);
 		spin_unlock_irqrestore(&nc->lock, flags);
 	}
 
@@ -149,6 +175,7 @@
 		return -EBUSY;
 
 	ncm->enable = 1;
+
 	return 0;
 }
 
@@ -195,7 +222,7 @@
 
 	/* Update state for the specified channel */
 	spin_lock_irqsave(&nc->lock, flags);
-	nc->state = NCSI_CHANNEL_INACTIVE;
+	ncsi_channel_state_set(nc, NCSI_CHANNEL_INACTIVE);
 	spin_unlock_irqrestore(&nc->lock, flags);
 
 	return 0;
@@ -310,15 +337,30 @@
 	ncsi_find_package_and_channel(ndp, rsp->rsp.common.channel,
 				      NULL, &nc);
 	if (!nc)
+#ifndef NO_SILC_MOD
+	{
+		ncsi_debug("ID %02x, channel not found for gls response", rsp->rsp.common.channel);
+#endif
 		return -ENODEV;
+#ifndef NO_SILC_MOD
+	}
+#endif
 
 	ncm = &nc->modes[NCSI_MODE_LINK];
 	ncm->data[2] = ntohl(rsp->status);
 	ncm->data[3] = ntohl(rsp->other);
 	ncm->data[4] = ntohl(rsp->oem_status);
+//	ncsi_debug("gls %08x", ncm->data[2]);
 
 	if (nr->flags & NCSI_REQ_FLAG_EVENT_DRIVEN)
+#ifndef NO_SILC_MOD
+	{
+		ncsi_debug("ID %02x, event driven, not resetting channel monitor state", rsp->rsp.common.channel);
+#endif
 		return 0;
+#ifndef NO_SILC_MOD
+	}
+#endif
 
 	/* Reset the channel monitor if it has been enabled */
 	spin_lock_irqsave(&nc->lock, flags);
@@ -341,7 +383,7 @@
 	/* Find the package and channel */
 	rsp = (struct ncsi_rsp_pkt *)skb_network_header(nr->rsp);
 	ncsi_find_package_and_channel(ndp, rsp->rsp.common.channel,
-				      NULL, &nc);
+																NULL, &nc);
 	if (!nc)
 		return -ENODEV;
 
@@ -349,7 +391,11 @@
 	ncf = nc->filters[NCSI_FILTER_VLAN];
 	if (!ncf)
 		return -ENOENT;
-	if (cmd->index >= ncf->total)
+	/*
+	 * Blair Wang :
+	 *   the cmd->index start from 1
+	 */
+	if (cmd->index > ncf->total)
 		return -ERANGE;
 
 	/* Add or remove the VLAN filter */
@@ -607,7 +653,9 @@
 	struct ncsi_dev_priv *ndp = nr->ndp;
 	struct ncsi_channel *nc;
 	struct ncsi_channel_version *ncv;
+#ifdef NO_SILC_MOD
 	int i;
+#endif
 
 	/* Find the channel */
 	rsp = (struct ncsi_rsp_gvi_pkt *)skb_network_header(nr->rsp);
@@ -622,9 +670,15 @@
 	ncv->alpha2 = rsp->alpha2;
 	memcpy(ncv->fw_name, rsp->fw_name, 12);
 	ncv->fw_version = ntohl(rsp->fw_version);
+#ifdef NO_SILC_MOD
 	for (i = 0; i < ARRAY_SIZE(ncv->pci_ids); i++)
 		ncv->pci_ids[i] = ntohs(rsp->pci_ids[i]);
 	ncv->mf_id = ntohl(rsp->mf_id);
+#else
+	/* Blair Wang : Workaround for i210 bug */
+	ncv->pci_ids[0] = ntohs(rsp->pci_ids[0]);
+	ncv->mf_id = 0xff;
+#endif
 
 	return 0;
 }
@@ -637,6 +691,9 @@
 	struct ncsi_channel_filter *ncf;
 	size_t size, entry_size;
 	int cnt, i;
+#ifndef NO_SILC_MOD
+	int j;
+#endif
 
 	/* Find the channel */
 	rsp = (struct ncsi_rsp_gc_pkt *)skb_network_header(nr->rsp);
@@ -653,13 +710,40 @@
 	nc->caps[NCSI_CAP_MC].cap = ntohl(rsp->mc_cap) &
 				    NCSI_CAP_MC_MASK;
 	nc->caps[NCSI_CAP_BUFFER].cap = ntohl(rsp->buf_cap);
-	nc->caps[NCSI_CAP_AEN].cap = ntohl(rsp->aen_cap) &
-				     NCSI_CAP_AEN_MASK;
-	nc->caps[NCSI_CAP_VLAN].cap = rsp->vlan_mode &
-				      NCSI_CAP_VLAN_MASK;
+#ifndef NO_SILC_MOD
+	/* Workaround for i210 bug - Blair Wang */
+	nc->caps[NCSI_CAP_AEN].cap = 0x01;
+	nc->caps[NCSI_CAP_VLAN].cap = 0;
+#else
+	nc->caps[NCSI_CAP_AEN].cap = ntohl(rsp->aen_cap) & NCSI_CAP_AEN_MASK;
+	nc->caps[NCSI_CAP_VLAN].cap = rsp->vlan_mode & NCSI_CAP_VLAN_MASK;
+#endif
 
 	/* Build filters */
 	for (i = 0; i < NCSI_FILTER_MAX; i++) {
+#ifndef NO_SILC_MOD
+		/* Workaround for i210 bug - Blair Wang */
+		switch (i) {
+		case NCSI_FILTER_VLAN:
+			cnt = 8;
+			entry_size = 2;
+		break;
+		case NCSI_FILTER_MIXED:
+			cnt = 0;
+			entry_size = 6;
+		break;
+		case NCSI_FILTER_MC:
+			cnt = 0;
+			entry_size = 6;
+		break;
+		case NCSI_FILTER_UC:
+			cnt = 0;
+			entry_size = 6;
+		break;
+		default:
+			continue;
+		}
+#else
 		switch (i) {
 		case NCSI_FILTER_VLAN:
 			cnt = rsp->vlan_cnt;
@@ -680,6 +764,7 @@
 		default:
 			continue;
 		}
+#endif
 
 		if (!cnt || nc->filters[i])
 			continue;
@@ -694,14 +779,25 @@
 
 		ncf->index = i;
 		ncf->total = cnt;
+#ifdef NO_SILC_MOD
 		if (i == NCSI_FILTER_VLAN) {
 			/* Set VLAN filters active so they are cleared in
 			 * first configuration state
 			 */
 			ncf->bitmap = U64_MAX;
 		} else {
-			ncf->bitmap = 0x0ul;
+			ncf->bitmap = 0x0ull;
 		}
+#else
+		if (i == NCSI_FILTER_VLAN) {
+			/* Set VLAN filters active so they are cleared in
+			 * first configuration state
+			 */
+			for (j = 0; j < ncf->total; j++)
+				set_bit(j, (void*)&ncf->bitmap);
+		}
+#endif
+
 		nc->filters[i] = ncf;
 	}
 
@@ -934,6 +1030,26 @@
 	return 0;
 }
 
+#ifndef NO_SILC_MOD
+static int ncsi_rsp_handler_oem(struct ncsi_request *nr)
+{
+	struct ncsi_rsp_oem_i210_cmd_mgmt_pkt *rsp;
+	struct ncsi_dev_priv *ndp = nr->ndp;
+	struct ncsi_package *np;
+
+	/* Find the package */
+	rsp = (struct ncsi_rsp_oem_i210_cmd_mgmt_pkt *)skb_network_header(nr->rsp);
+	ncsi_find_package_and_channel(ndp, rsp->rsp.common.channel,
+																&np, NULL);
+	if (!np)
+		return -ENODEV;
+
+	netdev_dbg(nr->ndp->ndev.dev, "NCSI oem i210 succ\n");
+
+	return 0;
+}
+#endif
+
 static struct ncsi_rsp_handler {
 	unsigned char	type;
 	int             payload;
@@ -966,7 +1082,11 @@
 	{ NCSI_PKT_RSP_GNS,   172, ncsi_rsp_handler_gns     },
 	{ NCSI_PKT_RSP_GNPTS, 172, ncsi_rsp_handler_gnpts   },
 	{ NCSI_PKT_RSP_GPS,     8, ncsi_rsp_handler_gps     },
+#ifdef NO_SILC_MOD
 	{ NCSI_PKT_RSP_OEM,     0, NULL                     },
+#else
+	{ NCSI_PKT_RSP_OEM,     10, ncsi_rsp_handler_oem     },
+#endif
 	{ NCSI_PKT_RSP_PLDM,    0, NULL                     },
 	{ NCSI_PKT_RSP_GPUUID, 20, ncsi_rsp_handler_gpuuid  }
 };
@@ -990,6 +1110,9 @@
 
 	/* Check if it is AEN packet */
 	hdr = (struct ncsi_pkt_hdr *)skb_network_header(skb);
+#ifndef NO_SILC_MOD
+	ncsi_cmd_dump(ndp->ndev.dev, hdr);
+#endif
 	if (hdr->type == NCSI_PKT_AEN)
 		return ncsi_aen_handler(ndp, skb);
 
--- linux-ti2018.02-rc4-int-orig/net/ncsi/ncsi-manage.c	2018-07-15 00:46:30.000000000 +0800
+++ linux-ti2018.02-rc4-int-silicom/net/ncsi/ncsi-manage.c	2020-03-09 10:47:13.220802129 +0800
@@ -38,7 +38,7 @@
 	return sizes[table];
 }
 
-u32 *ncsi_get_filter(struct ncsi_channel *nc, int table, int index)
+u8 *ncsi_get_filter(struct ncsi_channel *nc, int table, int index)
 {
 	struct ncsi_channel_filter *ncf;
 	int size;
@@ -146,6 +146,103 @@
 	return 0;
 }
 
+#ifndef NO_SILC_MOD
+static char* ncsi_state_name_get(int state)
+{
+	switch(state)
+	{
+	case ncsi_dev_state_registered:
+		return "registered";
+	case ncsi_dev_state_functional:
+		return "functional";
+	case ncsi_dev_state_probe	:
+		return "probe";
+	case ncsi_dev_state_config	:
+		return "config";
+	case ncsi_dev_state_suspend	:
+		return "suspend";
+
+	case ncsi_dev_state_probe_deselect:
+		return "probe_deselect";
+	case ncsi_dev_state_probe_package:
+		return "probe_package";
+	case ncsi_dev_state_probe_channel:
+		return "probe_channel";
+	case ncsi_dev_state_probe_cis:
+		return "probe_cis";
+	case ncsi_dev_state_probe_gvi:
+		return "probe_gvi";
+	case ncsi_dev_state_probe_gc:
+		return "probe_gc";
+	case ncsi_dev_state_probe_gls:
+		return "probe_gls";
+	case ncsi_dev_state_probe_dp:
+		return "probe_dp";
+	case ncsi_dev_state_config_sp	:
+		return "config_sp";
+	case ncsi_dev_state_config_ev	:
+		return "config_ev";
+	case ncsi_dev_state_config_cis	:
+		return "config_cis";
+	case ncsi_dev_state_config_clear_vids:
+		return "config_clear_vids";
+	case ncsi_dev_state_config_svf	:
+		return "config_svf";
+	case ncsi_dev_state_config_sma	:
+		return "config_sma";
+	case ncsi_dev_state_config_ebf	:
+		return "config_ebf";
+#if IS_ENABLED(CONFIG_IPV6)
+	case ncsi_dev_state_config_egmf	:
+		return "config_egmf";
+#endif
+	case ncsi_dev_state_config_ecnt	:
+		return "config_ecnt";
+	case ncsi_dev_state_config_ec	:
+		return "config_ec";
+	case ncsi_dev_state_config_ae	:
+		return "config_ae";
+	case ncsi_dev_state_config_gls	:
+		return "config_gls";
+	case ncsi_dev_state_config_intel_crit	:
+		return "config_intel_crit";
+	case ncsi_dev_state_config_done	:
+		return "config_done";
+	case ncsi_dev_state_suspend_select	:
+		return "suspend_select";
+	case ncsi_dev_state_suspend_gls	:
+		return "suspend_gls";
+	case ncsi_dev_state_suspend_dcnt	:
+		return "suspend_dcnt";
+	case ncsi_dev_state_suspend_dc	:
+		return "suspend_dc";
+	case ncsi_dev_state_suspend_deselect	:
+		return "suspend_deselect";
+	case ncsi_dev_state_suspend_done	:
+		return "suspend_done";
+	}
+	return "UNK";
+}
+
+#if 1
+#define ncsi_set_state(nd, new_state)	\
+	do { \
+		ncsi_debug("NCSI State changed: old %s, new %s", \
+		ncsi_state_name_get((nd)->state), ncsi_state_name_get(new_state)); \
+		(nd)->state=(new_state);\
+	}while(0)
+
+#else
+
+#define ncsi_set_state(nd, new_state)	\
+	do { \
+		(nd)->state=(new_state);\
+	}while(0)
+
+#endif
+
+#endif	//NO_SILC_MOD
+
 static void ncsi_report_link(struct ncsi_dev_priv *ndp, bool force_down)
 {
 	struct ncsi_dev *nd = &ndp->ndev;
@@ -153,7 +250,7 @@
 	struct ncsi_channel *nc;
 	unsigned long flags;
 
-	nd->state = ncsi_dev_state_functional;
+	ncsi_set_state(nd, ncsi_dev_state_functional);
 	if (force_down) {
 		nd->link_up = 0;
 		goto report;
@@ -184,6 +281,7 @@
 	nd->handler(nd);
 }
 
+
 static void ncsi_channel_monitor(unsigned long data)
 {
 	struct ncsi_channel *nc = (struct ncsi_channel *)data;
@@ -209,6 +307,7 @@
 	}
 	if (state != NCSI_CHANNEL_INACTIVE &&
 	    state != NCSI_CHANNEL_ACTIVE) {
+
 		ncsi_stop_channel_monitor(nc);
 		return;
 	}
@@ -303,13 +402,16 @@
 	int index;
 	unsigned long flags;
 
+#ifndef NO_SILC_MOD
+	ncsi_debug("NCSI pkg %u add channel %u", np->id, id);
+#endif
 	nc = kzalloc(sizeof(*nc), GFP_ATOMIC);
 	if (!nc)
 		return NULL;
 
 	nc->id = id;
 	nc->package = np;
-	nc->state = NCSI_CHANNEL_INACTIVE;
+	ncsi_channel_state_set(nc, NCSI_CHANNEL_INACTIVE);
 	nc->monitor.enabled = false;
 	setup_timer(&nc->monitor.timer,
 		    ncsi_channel_monitor, (unsigned long)nc);
@@ -325,11 +427,17 @@
 	if (tmp) {
 		spin_unlock_irqrestore(&np->lock, flags);
 		kfree(nc);
+#ifndef NO_SILC_MOD
+		ncsi_debug("NCSI pkg %u add channel %u, already exit", np->id, 	id);
+#endif
 		return tmp;
 	}
 
 	list_add_tail_rcu(&nc->node, &np->channels);
 	np->channel_num++;
+#ifndef NO_SILC_MOD
+	ncsi_debug("NCSI pkg %u added channel %u, total %u", np->id, id, np->channel_num);
+#endif
 	spin_unlock_irqrestore(&np->lock, flags);
 
 	return nc;
@@ -341,6 +449,9 @@
 	struct ncsi_channel_filter *ncf;
 	unsigned long flags;
 	int i;
+#ifndef NO_SILC_MOD
+	ncsi_debug("NCSI pkg %u rmv channel %u", np->id, nc->id);
+#endif
 
 	/* Release filters */
 	spin_lock_irqsave(&nc->lock, flags);
@@ -353,7 +464,7 @@
 		kfree(ncf);
 	}
 
-	nc->state = NCSI_CHANNEL_INACTIVE;
+	ncsi_channel_state_set(nc, NCSI_CHANNEL_INACTIVE);
 	spin_unlock_irqrestore(&nc->lock, flags);
 	ncsi_stop_channel_monitor(nc);
 
@@ -379,12 +490,36 @@
 	return NULL;
 }
 
+#ifndef NO_SILC_MOD
+
+void ncsi_oem_cmd_intel_crit(struct ncsi_dev_priv *ndp, struct ncsi_channel *nc)
+{
+//	struct ncsi_dev *nd = &ndp->ndev;
+	struct ncsi_package *np = nc->package;
+//	struct ncsi_channel *nc = ndp->active_channel;
+	struct ncsi_cmd_arg nca;
+//	int ret;
+
+	nca.ndp = ndp;
+	nca.req_flags = 0;
+	nca.type = NCSI_PKT_CMD_OEM;
+	nca.package = np->id;
+	nca.channel = nc->id;
+	ncsi_xmit_cmd(&nca);
+
+	return;
+}
+#endif
+
 struct ncsi_package *ncsi_add_package(struct ncsi_dev_priv *ndp,
 				      unsigned char id)
 {
 	struct ncsi_package *np, *tmp;
 	unsigned long flags;
 
+#ifndef NO_SILC_MOD
+	ncsi_debug("NCSI add pkg %u, total: %u", id, ndp->package_num);
+#endif
 	np = kzalloc(sizeof(*np), GFP_ATOMIC);
 	if (!np)
 		return NULL;
@@ -397,6 +532,9 @@
 	spin_lock_irqsave(&ndp->lock, flags);
 	tmp = ncsi_find_package(ndp, id);
 	if (tmp) {
+#ifndef NO_SILC_MOD
+		ncsi_debug("NCSI pkg %u exist", id);
+#endif
 		spin_unlock_irqrestore(&ndp->lock, flags);
 		kfree(np);
 		return tmp;
@@ -404,6 +542,9 @@
 
 	list_add_tail_rcu(&np->node, &ndp->packages);
 	ndp->package_num++;
+#ifndef NO_SILC_MOD
+	ncsi_debug("NCSI added pkg %u, total: %u", id, ndp->package_num);
+#endif
 	spin_unlock_irqrestore(&ndp->lock, flags);
 
 	return np;
@@ -415,6 +556,9 @@
 	struct ncsi_channel *nc, *tmp;
 	unsigned long flags;
 
+#ifndef NO_SILC_MOD
+	ncsi_debug("NCSI removing pkg %u , total: %u", np->id, ndp->package_num);
+#endif
 	/* Release all child channels */
 	list_for_each_entry_safe(nc, tmp, &np->channels, node)
 		ncsi_remove_channel(nc);
@@ -423,6 +567,9 @@
 	spin_lock_irqsave(&ndp->lock, flags);
 	list_del_rcu(&np->node);
 	ndp->package_num--;
+#ifndef NO_SILC_MOD
+	ncsi_debug("NCSI removed pkg %u , total: %u", np->id, ndp->package_num);
+#endif
 	spin_unlock_irqrestore(&ndp->lock, flags);
 
 	kfree(np);
@@ -561,7 +708,7 @@
 	nca.req_flags = NCSI_REQ_FLAG_EVENT_DRIVEN;
 	switch (nd->state) {
 	case ncsi_dev_state_suspend:
-		nd->state = ncsi_dev_state_suspend_select;
+		ncsi_set_state(nd, ncsi_dev_state_suspend_select);
 		/* Fall through */
 	case ncsi_dev_state_suspend_select:
 		ndp->pending_req_num = 1;
@@ -583,9 +730,9 @@
 		 * inactive channels can't be updated with LSC AEN in time.
 		 */
 		if (ndp->flags & NCSI_DEV_RESHUFFLE)
-			nd->state = ncsi_dev_state_suspend_gls;
+			ncsi_set_state(nd, ncsi_dev_state_suspend_gls);
 		else
-			nd->state = ncsi_dev_state_suspend_dcnt;
+			ncsi_set_state(nd, ncsi_dev_state_suspend_dcnt);
 		ret = ncsi_xmit_cmd(&nca);
 		if (ret)
 			goto error;
@@ -597,7 +744,7 @@
 		nca.type = NCSI_PKT_CMD_GLS;
 		nca.package = np->id;
 
-		nd->state = ncsi_dev_state_suspend_dcnt;
+		ncsi_set_state(nd, ncsi_dev_state_suspend_dcnt);
 		NCSI_FOR_EACH_CHANNEL(np, nc) {
 			nca.channel = nc->id;
 			ret = ncsi_xmit_cmd(&nca);
@@ -613,7 +760,7 @@
 		nca.package = np->id;
 		nca.channel = nc->id;
 
-		nd->state = ncsi_dev_state_suspend_dc;
+		ncsi_set_state(nd, ncsi_dev_state_suspend_dc);
 		ret = ncsi_xmit_cmd(&nca);
 		if (ret)
 			goto error;
@@ -627,7 +774,7 @@
 		nca.channel = nc->id;
 		nca.bytes[0] = 1;
 
-		nd->state = ncsi_dev_state_suspend_deselect;
+		ncsi_set_state(nd, ncsi_dev_state_suspend_deselect);
 		ret = ncsi_xmit_cmd(&nca);
 		if (ret)
 			goto error;
@@ -640,7 +787,7 @@
 		nca.package = np->id;
 		nca.channel = NCSI_RESERVED_CHANNEL;
 
-		nd->state = ncsi_dev_state_suspend_done;
+		ncsi_set_state(nd, ncsi_dev_state_suspend_done);
 		ret = ncsi_xmit_cmd(&nca);
 		if (ret)
 			goto error;
@@ -648,7 +795,7 @@
 		break;
 	case ncsi_dev_state_suspend_done:
 		spin_lock_irqsave(&nc->lock, flags);
-		nc->state = NCSI_CHANNEL_INACTIVE;
+		ncsi_channel_state_set(nc, NCSI_CHANNEL_INACTIVE);
 		spin_unlock_irqrestore(&nc->lock, flags);
 		ncsi_process_next_channel(ndp);
 
@@ -660,7 +807,7 @@
 
 	return;
 error:
-	nd->state = ncsi_dev_state_functional;
+	ncsi_set_state(nd, ncsi_dev_state_functional);
 }
 
 /* Check the VLAN filter bitmap for a set filter, and construct a
@@ -670,7 +817,7 @@
 			 struct ncsi_cmd_arg *nca)
 {
 	int index;
-	u32 *data;
+	u8 *data;
 	u16 vid;
 
 	index = ncsi_find_filter(nc, NCSI_FILTER_VLAN, NULL);
@@ -766,6 +913,7 @@
 	struct ncsi_cmd_arg nca;
 	unsigned char index;
 	unsigned long flags;
+	unsigned short new_state;
 	int ret;
 
 	nca.ndp = ndp;
@@ -787,7 +935,7 @@
 		if (ret)
 			goto error;
 
-		nd->state = ncsi_dev_state_config_cis;
+		ncsi_set_state(nd, ncsi_dev_state_config_cis);
 		break;
 	case ncsi_dev_state_config_cis:
 		ndp->pending_req_num = 1;
@@ -800,7 +948,7 @@
 		if (ret)
 			goto error;
 
-		nd->state = ncsi_dev_state_config_clear_vids;
+		ncsi_set_state(nd, ncsi_dev_state_config_clear_vids);
 		break;
 	case ncsi_dev_state_config_clear_vids:
 	case ncsi_dev_state_config_svf:
@@ -812,6 +960,9 @@
 #endif
 	case ncsi_dev_state_config_ecnt:
 	case ncsi_dev_state_config_ec:
+#ifndef NO_SILC_MOD
+	case ncsi_dev_state_config_intel_crit:
+#endif
 	case ncsi_dev_state_config_ae:
 	case ncsi_dev_state_config_gls:
 		ndp->pending_req_num = 1;
@@ -819,26 +970,28 @@
 		nca.package = np->id;
 		nca.channel = nc->id;
 
+		new_state = 0;
+
 		/* Clear any active filters on the channel before setting */
 		if (nd->state == ncsi_dev_state_config_clear_vids) {
 			ret = clear_one_vid(ndp, nc, &nca);
 			if (ret) {
-				nd->state = ncsi_dev_state_config_svf;
+				ncsi_set_state(nd, ncsi_dev_state_config_svf);
 				schedule_work(&ndp->work);
 				break;
 			}
 			/* Repeat */
-			nd->state = ncsi_dev_state_config_clear_vids;
+			new_state = ncsi_dev_state_config_clear_vids;
 		/* Add known VLAN tags to the filter */
 		} else if (nd->state == ncsi_dev_state_config_svf) {
 			ret = set_one_vid(ndp, nc, &nca);
 			if (ret) {
-				nd->state = ncsi_dev_state_config_ev;
+				ncsi_set_state(nd, ncsi_dev_state_config_ev);
 				schedule_work(&ndp->work);
 				break;
 			}
 			/* Repeat */
-			nd->state = ncsi_dev_state_config_svf;
+			new_state = ncsi_dev_state_config_svf;
 		/* Enable/Disable the VLAN filter */
 		} else if (nd->state == ncsi_dev_state_config_ev) {
 			if (list_empty(&ndp->vlan_vids)) {
@@ -847,7 +1000,7 @@
 				nca.type = NCSI_PKT_CMD_EV;
 				nca.bytes[3] = NCSI_CAP_VLAN_NO;
 			}
-			nd->state = ncsi_dev_state_config_sma;
+			new_state = ncsi_dev_state_config_sma;
 		} else if (nd->state == ncsi_dev_state_config_sma) {
 		/* Use first entry in unicast filter table. Note that
 		 * the MAC filter table starts from entry 1 instead of
@@ -858,45 +1011,63 @@
 				nca.bytes[index] = dev->dev_addr[index];
 			nca.bytes[6] = 0x1;
 			nca.bytes[7] = 0x1;
-			nd->state = ncsi_dev_state_config_ebf;
+			new_state = ncsi_dev_state_config_ebf;
 		} else if (nd->state == ncsi_dev_state_config_ebf) {
 			nca.type = NCSI_PKT_CMD_EBF;
 			nca.dwords[0] = nc->caps[NCSI_CAP_BC].cap;
-			nd->state = ncsi_dev_state_config_ecnt;
+			new_state = ncsi_dev_state_config_ecnt;
 #if IS_ENABLED(CONFIG_IPV6)
 			if (ndp->inet6_addr_num > 0 &&
 			    (nc->caps[NCSI_CAP_GENERIC].cap &
 			     NCSI_CAP_GENERIC_MC))
-				nd->state = ncsi_dev_state_config_egmf;
+				new_state = ncsi_dev_state_config_egmf;
 			else
-				nd->state = ncsi_dev_state_config_ecnt;
+				new_state = ncsi_dev_state_config_ecnt;
 		} else if (nd->state == ncsi_dev_state_config_egmf) {
 			nca.type = NCSI_PKT_CMD_EGMF;
 			nca.dwords[0] = nc->caps[NCSI_CAP_MC].cap;
-			nd->state = ncsi_dev_state_config_ecnt;
+			new_state = ncsi_dev_state_config_ecnt;
 #endif /* CONFIG_IPV6 */
 		} else if (nd->state == ncsi_dev_state_config_ecnt) {
 			nca.type = NCSI_PKT_CMD_ECNT;
-			nd->state = ncsi_dev_state_config_ec;
+			new_state = ncsi_dev_state_config_ec;
 		} else if (nd->state == ncsi_dev_state_config_ec) {
 			/* Enable AEN if it's supported */
 			nca.type = NCSI_PKT_CMD_EC;
-			nd->state = ncsi_dev_state_config_ae;
-			if (!(nc->caps[NCSI_CAP_AEN].cap & NCSI_CAP_AEN_MASK))
-				nd->state = ncsi_dev_state_config_gls;
+			if (nc->caps[NCSI_CAP_AEN].cap & NCSI_CAP_AEN_MASK)
+				new_state = ncsi_dev_state_config_ae;
+			else
+#ifdef NO_SILC_MOD
+				new_state = ncsi_dev_state_config_gls;
+#else
+				new_state = ncsi_dev_state_config_intel_crit;
+#endif
 		} else if (nd->state == ncsi_dev_state_config_ae) {
-			nca.type = NCSI_PKT_CMD_AE;
-			nca.bytes[0] = 0;
-			nca.dwords[1] = nc->caps[NCSI_CAP_AEN].cap;
-			nd->state = ncsi_dev_state_config_gls;
+				nca.type = NCSI_PKT_CMD_AE;
+				nca.bytes[0] = 0;
+				nca.dwords[1] = nc->caps[NCSI_CAP_AEN].cap;
+#ifndef NO_SILC_MOD
+			new_state = ncsi_dev_state_config_intel_crit;
+		} else if (nd->state == ncsi_dev_state_config_intel_crit) {
+			nca.type = NCSI_PKT_CMD_OEM;
+#endif
+			new_state = ncsi_dev_state_config_gls;
 		} else if (nd->state == ncsi_dev_state_config_gls) {
+			printk(KERN_ERR "State gls\n");
 			nca.type = NCSI_PKT_CMD_GLS;
-			nd->state = ncsi_dev_state_config_done;
+			new_state = ncsi_dev_state_config_done;
 		}
 
 		ret = ncsi_xmit_cmd(&nca);
 		if (ret)
 			goto error;
+
+		/*
+		 * Blair Wang :
+		 *   Only change state after xmit succ
+		 */
+		ncsi_set_state(nd, new_state);
+
 		break;
 	case ncsi_dev_state_config_done:
 		spin_lock_irqsave(&nc->lock, flags);
@@ -921,10 +1092,10 @@
 
 		if (nc->modes[NCSI_MODE_LINK].data[2] & 0x1) {
 			hot_nc = nc;
-			nc->state = NCSI_CHANNEL_ACTIVE;
+			ncsi_channel_state_set(nc, NCSI_CHANNEL_ACTIVE);
 		} else {
 			hot_nc = NULL;
-			nc->state = NCSI_CHANNEL_INACTIVE;
+			ncsi_channel_state_set(nc, NCSI_CHANNEL_INACTIVE);
 		}
 		spin_unlock_irqrestore(&nc->lock, flags);
 
@@ -1075,7 +1246,7 @@
 	nca.req_flags = NCSI_REQ_FLAG_EVENT_DRIVEN;
 	switch (nd->state) {
 	case ncsi_dev_state_probe:
-		nd->state = ncsi_dev_state_probe_deselect;
+		ncsi_set_state(nd, ncsi_dev_state_probe_deselect);
 		/* Fall through */
 	case ncsi_dev_state_probe_deselect:
 		ndp->pending_req_num = 8;
@@ -1090,7 +1261,7 @@
 				goto error;
 		}
 
-		nd->state = ncsi_dev_state_probe_package;
+		ncsi_set_state(nd, ncsi_dev_state_probe_package);
 		break;
 	case ncsi_dev_state_probe_package:
 		ndp->pending_req_num = 16;
@@ -1115,7 +1286,7 @@
 				goto error;
 		}
 
-		nd->state = ncsi_dev_state_probe_channel;
+		ncsi_set_state(nd, ncsi_dev_state_probe_channel);
 		break;
 	case ncsi_dev_state_probe_channel:
 		if (!ndp->active_package)
@@ -1156,7 +1327,7 @@
 		if (ret)
 			goto error;
 
-		nd->state = ncsi_dev_state_probe_cis;
+		ncsi_set_state(nd, ncsi_dev_state_probe_cis);
 		break;
 	case ncsi_dev_state_probe_cis:
 		ndp->pending_req_num = NCSI_RESERVED_CHANNEL;
@@ -1171,7 +1342,7 @@
 				goto error;
 		}
 
-		nd->state = ncsi_dev_state_probe_gvi;
+		ncsi_set_state(nd, ncsi_dev_state_probe_gvi);
 		break;
 	case ncsi_dev_state_probe_gvi:
 	case ncsi_dev_state_probe_gc:
@@ -1196,11 +1367,11 @@
 		}
 
 		if (nd->state == ncsi_dev_state_probe_gvi)
-			nd->state = ncsi_dev_state_probe_gc;
+			ncsi_set_state(nd, ncsi_dev_state_probe_gc);
 		else if (nd->state == ncsi_dev_state_probe_gc)
-			nd->state = ncsi_dev_state_probe_gls;
+			ncsi_set_state(nd, ncsi_dev_state_probe_gls);
 		else
-			nd->state = ncsi_dev_state_probe_dp;
+			ncsi_set_state(nd, ncsi_dev_state_probe_dp);
 		break;
 	case ncsi_dev_state_probe_dp:
 		ndp->pending_req_num = 1;
@@ -1214,7 +1385,7 @@
 			goto error;
 
 		/* Scan channels in next package */
-		nd->state = ncsi_dev_state_probe_channel;
+		ncsi_set_state(nd, ncsi_dev_state_probe_channel);
 		break;
 	default:
 		netdev_warn(nd->dev, "Wrong NCSI state 0x%0x in enumeration\n",
@@ -1267,7 +1438,7 @@
 
 	spin_lock_irqsave(&nc->lock, flags);
 	old_state = nc->state;
-	nc->state = NCSI_CHANNEL_INVISIBLE;
+	ncsi_channel_state_set(nc, NCSI_CHANNEL_INVISIBLE);
 	spin_unlock_irqrestore(&nc->lock, flags);
 
 	ndp->active_channel = nc;
@@ -1275,11 +1446,11 @@
 
 	switch (old_state) {
 	case NCSI_CHANNEL_INACTIVE:
-		ndp->ndev.state = ncsi_dev_state_config;
+		ncsi_set_state(&ndp->ndev, ncsi_dev_state_config);
 		ncsi_configure_channel(ndp);
 		break;
 	case NCSI_CHANNEL_ACTIVE:
-		ndp->ndev.state = ncsi_dev_state_suspend;
+		ncsi_set_state(&ndp->ndev, ncsi_dev_state_suspend);
 		ncsi_suspend_channel(ndp);
 		break;
 	default:
@@ -1527,7 +1698,7 @@
 		return NULL;
 
 	nd = &ndp->ndev;
-	nd->state = ncsi_dev_state_registered;
+	ncsi_set_state(nd, ncsi_dev_state_registered);
 	nd->dev = dev;
 	nd->handler = handler;
 	ndp->pending_req_num = 0;
@@ -1576,7 +1747,7 @@
 		return -ENOTTY;
 
 	if (!(ndp->flags & NCSI_DEV_PROBED)) {
-		nd->state = ncsi_dev_state_probe;
+		ncsi_set_state(nd, ncsi_dev_state_probe);
 		schedule_work(&ndp->work);
 		return 0;
 	}
@@ -1607,7 +1778,7 @@
 			spin_lock_irqsave(&nc->lock, flags);
 			chained = !list_empty(&nc->link);
 			old_state = nc->state;
-			nc->state = NCSI_CHANNEL_INACTIVE;
+			ncsi_channel_state_set(nc, NCSI_CHANNEL_INACTIVE);
 			spin_unlock_irqrestore(&nc->lock, flags);
 
 			WARN_ON_ONCE(chained ||
--- linux-ti2018.02-rc4-int-orig/net/ncsi/ncsi-pkt.h	2018-07-15 00:46:30.000000000 +0800
+++ linux-ti2018.02-rc4-int-silicom/net/ncsi/ncsi-pkt.h	2020-03-09 10:47:13.238802108 +0800
@@ -326,6 +326,31 @@
 	unsigned char           pad[18];
 };
 
+#ifndef NO_SILC_MOD
+/*
+ * Blair Wang:
+ *  The offset of checksum should be 4bytes aligned
+ */
+struct ncsi_oem_i210_cmd_mgmt_pkt {
+	struct ncsi_cmd_pkt_hdr cmd;      /* Command header */
+	__be32					oem_id;		/* must be 0x157 */
+	unsigned char			intel_cmd;	/* must be 0x20 */
+	unsigned char			value1;		/* must be 0x0*/
+	unsigned char			mgmt_ctl;	/* 1 to enable critical session mode*/
+	unsigned char     pad;
+	__be32            checksum;
+};
+struct ncsi_rsp_oem_i210_cmd_mgmt_pkt {
+	struct ncsi_rsp_pkt_hdr rsp;      /* Response header             */
+	__be32					oem_id;		/* must be 0x157 */
+	unsigned char			intel_cmd;	/* must be 0x20 */
+	unsigned char			value1;		/* must be 0x0*/
+	unsigned char     pad[2];
+	__be32            checksum;
+};
+
+#endif
+
 /* NCSI packet revision */
 #define NCSI_PKT_REVISION	0x01
 
@@ -412,4 +437,12 @@
 #define NCSI_PKT_AEN_CR		0x01 /* Configuration required   */
 #define NCSI_PKT_AEN_HNCDSC	0x02 /* HNC driver status change */
 
+#ifndef NO_SILC_MOD
+/*
+ * Blair Wang:
+ *  The value of payload does not include the padding in NCSI packet.
+ */
+#define NCSI_PAYLOAD_ELEN(p) (((p) + 3) & 0xFFFC)
+#endif
+
 #endif /* __NCSI_PKT_H__ */
--- linux-ti2018.02-rc4-int-orig/net/ncsi/internal.h	2018-07-15 00:46:30.000000000 +0800
+++ linux-ti2018.02-rc4-int-silicom/net/ncsi/internal.h	2020-03-09 10:47:13.255802087 +0800
@@ -98,11 +98,16 @@
 	u32 data[8];	/* Data entries                */
 };
 
+/*
+ * Blair Wang :
+ *   the field 'data' should be u8 type.
+ */
 struct ncsi_channel_filter {
 	u32 index;	/* Index of channel filters          */
 	u32 total;	/* Total entries in the filter table */
 	u64 bitmap;	/* Bitmap of valid entries           */
-	u32 data[];	/* Data for the valid entries        */
+	//u32  data[];	/* Data for the valid entries        */
+	u8  data[];	/* Data for the valid entries        */
 };
 
 struct ncsi_channel_stats {
@@ -246,6 +251,9 @@
 #endif
 	ncsi_dev_state_config_ecnt,
 	ncsi_dev_state_config_ec,
+#ifndef NO_SILC_MOD
+	ncsi_dev_state_config_intel_crit,
+#endif
 	ncsi_dev_state_config_ae,
 	ncsi_dev_state_config_gls,
 	ncsi_dev_state_config_done,
@@ -349,4 +357,33 @@
 		 struct packet_type *pt, struct net_device *orig_dev);
 int ncsi_aen_handler(struct ncsi_dev_priv *ndp, struct sk_buff *skb);
 
+#ifndef NO_SILC_MOD
+#define ncsi_debug(fmt, ...)	printk(KERN_NOTICE "[%s:%u] "fmt "\n", __func__, __LINE__, ## __VA_ARGS__)
+#define ncsi_warn(fmt, ...)	printk(KERN_WARNING "[%s:%u] "fmt "\n", __func__, __LINE__, ## __VA_ARGS__)
+
+static inline char* ncsi_channel_state_name_get(int state)
+{
+	switch(state) {
+	case NCSI_CHANNEL_INACTIVE:
+		return "CHANNEL_INACTIVE ";
+	case NCSI_CHANNEL_ACTIVE:
+		return "CHANNEL_ACTIVE   ";
+	case NCSI_CHANNEL_INVISIBLE:
+		return "CHANNEL_INVISIBLE";
+	}
+	return "UNKNOWN       ";
+}
+#define ncsi_channel_state_set(nc, new_state)	\
+	do { \
+	ncsi_debug("Channel State Change, pkg %u, chn %u, old state %s new_state %s", \
+			(nc)->package->id, (nc)->id, ncsi_channel_state_name_get(nc->state), ncsi_channel_state_name_get(new_state)); \
+			(nc)->state = new_state; \
+	}while(0)
+
+
+void ncsi_oem_cmd_intel_crit(struct ncsi_dev_priv *ndp, struct ncsi_channel *nc);
+
+//#define SILC_EXTRA_DBG
+
+#endif
 #endif /* __NCSI_INTERNAL_H__ */
--- linux-ti2018.02-rc4-int-orig/net/ncsi/Kconfig	2018-07-15 00:46:30.000000000 +0800
+++ linux-ti2018.02-rc4-int-silicom/net/ncsi/Kconfig	2020-03-09 10:47:13.273802066 +0800
@@ -3,7 +3,7 @@
 #
 
 config NET_NCSI
-	bool "NCSI interface support"
+	tristate "NCSI interface support"
 	depends on INET
 	---help---
 	  This module provides NCSI (Network Controller Sideband Interface)
--- linux-ti2018.02-rc4-int-orig/net/ncsi/Makefile	2018-07-15 00:46:30.000000000 +0800
+++ linux-ti2018.02-rc4-int-silicom/net/ncsi/Makefile	2020-03-09 10:47:13.290802045 +0800
@@ -1,4 +1,6 @@
 #
 # Makefile for NCSI API
 #
-obj-$(CONFIG_NET_NCSI) += ncsi-cmd.o ncsi-rsp.o ncsi-aen.o ncsi-manage.o
+#obj-$(CONFIG_NET_NCSI) += ncsi-cmd.o ncsi-rsp.o ncsi-aen.o ncsi-manage.o
+ncsi-objs := ncsi-cmd.o ncsi-rsp.o ncsi-aen.o ncsi-manage.o
+obj-$(CONFIG_NET_NCSI)	+= ncsi.o
--- linux-ti2018.02-rc4-int-orig/include/net/ncsi.h	2018-07-15 00:46:30.000000000 +0800
+++ linux-ti2018.02-rc4-int-silicom/include/net/ncsi.h	2020-03-09 10:47:13.291802044 +0800
@@ -28,7 +28,7 @@
 	void		  (*handler)(struct ncsi_dev *ndev);
 };
 
-#ifdef CONFIG_NET_NCSI
+#if defined(CONFIG_NET_NCSI) || defined(CONFIG_NET_NCSI_MODULE)
 int ncsi_vlan_rx_add_vid(struct net_device *dev, __be16 proto, u16 vid);
 int ncsi_vlan_rx_kill_vid(struct net_device *dev, __be16 proto, u16 vid);
 struct ncsi_dev *ncsi_register_dev(struct net_device *dev,
@@ -36,6 +36,16 @@
 int ncsi_start_dev(struct ncsi_dev *nd);
 void ncsi_stop_dev(struct ncsi_dev *nd);
 void ncsi_unregister_dev(struct ncsi_dev *nd);
+
+#ifndef NO_SILC_MOD
+#undef NCSI_CMD_DUMP
+#ifdef NCSI_CMD_DUMP
+void ncsi_cmd_dump(struct net_device* n, void* pkt);
+#else
+#define ncsi_cmd_dump(n, pkt)
+#endif
+#endif
+
 #else /* !CONFIG_NET_NCSI */
 static inline int ncsi_vlan_rx_add_vid(struct net_device *dev, __be16 proto, u16 vid)
 {
